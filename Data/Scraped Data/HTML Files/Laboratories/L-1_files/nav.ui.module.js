(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function() {

	angular.module('nav-ui').controller('ContentController', ContentController);

	ContentController.$inject = [ '$scope', 'PageBuilderService', 'ContentResultsService', '$state','ProviderSearchCriteriaService','$location',
			'$translate', '$rootScope', 'configuration', '$controller', '$compile', 'AnalyticsService', '$sessionStorage', 'NavSpinnerService','LanguageDataService','$timeout'];

	function ContentController($scope, PageBuilderService, ContentResultsService, $state,ProviderSearchCriteriaService,$location,
			$translate, $rootScope, configuration, $controller, $compile, AnalyticsService, $sessionStorage, NavSpinnerService,LanguageDataService,$timeout) {

			var ctrl = this;
			var redirectToMyplanportalSwitch;
			ctrl.message = {};
			ctrl.message.text = '';

			NavSpinnerService.spin();
			ctrl.showCenterContentPage = showCenterContentPage;
			var page = $state.params.page;

			var thisSite_id = $state.params.site_id;	
				
			// The below is to bypass the details page in direct url for safari new tab issue
			var isNewTabDetails = false;
			if(page && (page == 'providerDetails' || page == 'providerOrgDetails' || page == 'providerHospDetails')){
				// alert("Please ignore this alert. Debug for inside page check ");
				isNewTabDetails = true;
			}

			// Check Page Parameter
			if (page == null || page == undefined) {
				var leavingUrl;
				if(thisSite_id !== undefined){	
					leavingUrl = $state.href('leavingPage',{page:'leavingPage',language:'en',site_id:thisSite_id});
				}else{						
					leavingUrl = $state.href('leavingPage',{page:'leavingPage',language:'en',site_id:'dse'});
				}
				NavSpinnerService.stop();
				window.open(leavingUrl,"_self");
				return;
			}

			// If this is not disclaimer Page then Check Site_id Parameter						
			if($state.current.name != "disclaimerPage"){
					var customSiteIdList= configuration.customSiteIds;
					var isSiteIdCorrect = false;
					for(var index in customSiteIdList){
						if (thisSite_id == customSiteIdList[index]) {
							isSiteIdCorrect = true;
							break;
						}
					}
					if(isSiteIdCorrect == false){
						leavingUrl = $state.href('leavingPage',{page:'leavingPage',language:'en',site_id:'dse'});
						window.open(leavingUrl,"_self");
						NavSpinnerService.stop();
					}
			}


			var lang = $state.params.language;
			if (lang == null || lang == undefined || lang !== "es") {
				lang = ""; // blank defaults to English
			} else { // since language is specified, set that language for HTML
				// text
				$translate.use(lang);
			}

			var contentId = "";
			if (page) {
				var contentId = page;
			} else {
				contentId = $state.params.contentId;
			}

			if (contentId != null && contentId != undefined) {
				showCenterContentPage(contentId, lang);
			}

			function copyRightFooterInit() {
				$scope.currDateyear = new Date();
				$scope.currBrand = " Aetna Inc.";
			};
			copyRightFooterInit();
			setPageTitle();



			/* Do menu change when state change starts */
			// $rootScope.$emit("CallParentMethod", {});
			/* Do menu change when state change end */

			function showCenterContentPage(contentId, contentLang) {
				// if the default language (English) is specified, it needs to be
				// blank
				if (contentLang === 'en') {
					contentLang = '';
				}

				// *** step gap
				// Only providerSearch is set up with Spanish files. All other pages
				// will
				// break until they have content in the Spanish folder
				// changed this as we have other pagenames that are in spanish.
				if (contentId.indexOf('provider') == -1
						&& !(contentId === 'directoryAndResources'
								|| contentId === 'qualityAndCostInfo'
								|| contentId === 'savingsAndDiscounts' || contentId === 'importantInfo')) {
					contentLang = '';
				}
				var contentType = 'biz';
				$scope.contentId = contentId;

				if(isNewTabDetails==true || contentId=='providerSearchLanding' || contentId === 'directoryAndResources'
						|| contentId === 'qualityAndCostInfo'
						|| contentId === 'savingsAndDiscounts' || contentId === 'importantInfo' || contentId === 'standardDisclaimer' || contentId === 'leavingPage' || contentId === 'planSponsorLinkOne'
							|| contentId.indexOf("planSponsorLink") !== -1){
								
							// alert("Please ignore this alert. Debug for inside isNewTabDetails==true ");
							getCenterContent(contentId, contentType, contentLang);

				}
				else{
					$scope.criteria = ProviderSearchCriteriaService.getCriteria();
					$scope.languageData = LanguageDataService.getLanguageData();
					 redirectToMyplanportalSwitch = $scope.languageData.SWITCH_REDIRECT_TO_MYPLANPORTAL;
                     redirectiToMyPlanPortal(redirectToMyplanportalSwitch);
					var siteId = $scope.criteria.siteId;
					var language = $scope.criteria.language;
					if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
						NavSpinnerService.stop();
						//below code is to redirect to landing page if no location is found
						 return $location.path('/contentPage').search({page: 'providerSearchLanding',site_id:siteId,language:language});
					}
					else{
						getCenterContent(contentId, contentType, contentLang);
					}
				}
			}
			function getCenterContent(contentId, contentType, contentLang){

									ContentResultsService.getContent(contentId, contentType, contentLang)
						 			 .then(
						 				 		function success(result) {
						     		 				// promise was fullfilled (regardless of outcome)
						     		 				// checks for information will be peformed here
						 				 			 $timeout(function() {
						 				 				PageBuilderService.buildPageWithParameters(result,$state.params.parameters);
							 				 			AnalyticsService.trackCenterContent(contentId, result);
														if(contentId != 'providerResults' && contentId != 'providerSearchPlanList' && contentId != 'providerDetails' && contentId != 'providerHospDetails' && contentId != 'providerOrgDetails' && contentId != 'providerSearch'){
																NavSpinnerService.stop();
														}
														$('#firstElement').focus();
						 				 			 }, 100);
						 			 		},
						 				 		function error (errorMsg) {
						 			 			// handle errors here
						   		 				//$log.error(errorMsg.statusText);
						   			 				ctrl.message.text = errorMsg.statusText;
														NavSpinnerService.stop();
						 				 		}
						 				 );
			}
			function setPageTitle(){
	        	 var contentPage = $location.search().page;
	 			  if(!contentPage){
		       			 var urlLink = window.location.href.split("=");
		       			 contentPage = urlLink[urlLink.length-1];
	 			  }
	 			  $rootScope.pageTitle = "Directory of Health Care Professionals";
	 			  $scope.criteria = ProviderSearchCriteriaService.getCriteria();
	 			  $scope.languageData = LanguageDataService.getLanguageData();
	 			  if($scope.languageData){
	 				  if($scope.languageData["HEADER_TITLE_"+contentPage]){
	 					  $rootScope.pageTitle = $scope.languageData["HEADER_TITLE_"+contentPage];
	 				  }
	 				  else{
	 					  $rootScope.pageTitle = $scope.languageData.HEADER_TITLE_DEFAULT;
	 				  }
	 			   }
	         }
			 function redirectiToMyPlanPortal(redirectToMyplanportalSwitch){
				 var currentHost = $location.host();
					if(redirectToMyplanportalSwitch != null && redirectToMyplanportalSwitch != undefined && redirectToMyplanportalSwitch != "" &&
							redirectToMyplanportalSwitch == "ON" && currentHost.indexOf("www.aetna.com") != -1){
						var currentUrl = window.location.href;
						var newUrl = currentUrl.replace("www.aetna.com","www.myplanportal.com");
						window.location.href = newUrl;
					}
			}

	}
})();

},{}],2:[function(require,module,exports){
(function() {
	angular
	.module('nav-ui')
	.controller('DebugController', DebugController);

	DebugController.$inject = ['ProviderResultsService', '$rootScope','$scope','$http','$q','NavSpinnerService'];

	function DebugController(ProviderResultsService,$rootScope,$scope,$http,$q,NavSpinnerService) {
		$rootScope.lastUpdatedDate=ProviderResultsService.getUpdatedDate();

		$rootScope.lastUpdatedDate=ProviderResultsService.getUpdatedDate();

		$scope.apicURL = " ";
		$scope.clientId="f19a9467-c2c7-489c-9866-ce4459418960";
		$scope.clientSecret="";

		$scope.callAPI = function (  )
		{
			NavSpinnerService.spin();
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: $scope.apicURL,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : $scope.clientId,
					'X-IBM-Client-Secret' : $scope.clientSecret
				}
			}) .then(
					function success(response)
					{
						$scope.apicResponse = "Status :  " + JSON.stringify(response.status) + " Status Text"+
						JSON.stringify(response.statusText)  + " Response" + JSON.stringify(response);
						NavSpinnerService.stop();
						return deferred.promise;
					},
					function error(response)
					{
						$scope.apicResponse = "Status :  " + JSON.stringify(response.status) + " Status Text"+
						JSON.stringify(response.statusText)  + " Response" + JSON.stringify(response);
						NavSpinnerService.stop();
						return deferred.promise;
					});
		};
	}
})();

},{}],3:[function(require,module,exports){
(function() {

	angular.module('nav-ui').controller('DisclaimerController',
			DisclaimerController);

	DisclaimerController.$inject = [ '$scope', '$window', '$state',
			'$rootScope', 'NavSpinnerService', '$sessionStorage', '$http',
			'ProviderSearchCriteriaService', '$location', 'LanguageDataService', 'ContentResultsService' ];

	function DisclaimerController($scope, $window, $state, $rootScope,
			NavSpinnerService, $sessionStorage, $http,
			ProviderSearchCriteriaService, $location, LanguageDataService, ContentResultsService) {
		$rootScope.tt = false;
		$rootScope.shw = true;
		var pageTitle;
		var continueText;
		var cancelText;

		var lang = $state.params.language;
		if (lang == null || lang == undefined || lang !== "es") {
			lang = ""; // blank defaults to English
		}
		// var vlanguageData = LanguageDataService.getLanguageData();
		//
		// if(vlanguageData == '' || vlanguageData == null || vlanguageData == undefined){
			// NavSpinnerService.spin();
			var contentId = 'developer';
			var contentType = 'dev';
			var contentLang = '';

			$scope.languageData = {};

			ContentResultsService.getContent(contentId, contentType, contentLang)
				.then(
					function success(result) {

					  $sessionStorage.languageData = result;
					  $scope.languageData = result;
					  LanguageDataService.setLanguageData(result);

					  var page = $state.params.page;
					  var devContent = $scope.languageData;

					  // $sessionStorage.DisclaimerButtons = {};
					  // $sessionStorage.DisclaimerButtons.continueTxt=devContent.CONTINUE_BUTTON;
					  // $sessionStorage.DisclaimerButtons.cancelTxt=devContent.DP_CANCEL;

					  if(window.location.href.indexOf("redirect=true") > -1 ||
							  (devContent.SWITCH_REDIRECT_TO_OLD_DSE == "ON" && window.location.href.indexOf("redirect=false") == -1 )){
						  window.location.href = devContent.OLD_DSE_URL;
					   }
					   // NavSpinnerService.stop();



					   var urlForSite = window.location.href;
					   $scope.showForPhaseOneSite = false;
					   if(urlForSite.indexOf("disclaimerPage") > -1){
							$scope.showForPhaseOneSite = true;
					   }else{
							if(urlForSite.indexOf("leavingPage") > -1 ){	
									var phaseTwoSwitch = $scope.languageData.SWITCH_REDIRECT_TO_MYPLANPORTAL;
									if(phaseTwoSwitch == "ON"){
											$scope.showForPhaseOneSite = false;
									}else{				
											$scope.showForPhaseOneSite = true;
									}
							}
						}

					},
					function error(errorMsg) {
						// NavSpinnerService.stop();
						$log.error(errorMsg.statusText);
						ctrl.message.text = errorMsg.statusText;
					}
				);
		// }else{
		// 	$scope.languageData = vlanguageData;
		// }

		// if ($scope.languageData != undefined && $scope.languageData != null
		// 		&& $scope.languageData != ""
		// 			&& $scope.languageData.CONTINUE_BUTTON_ENGLISH != undefined){
		// 	if(lang == null || lang == 'en'){
		// 		pageTitle = $scope.languageData.HEADER_TITLE_DEFAULT_ENGLISH;
		// 		continueText = $scope.languageData.CONTINUE_BUTTON_ENGLISH;
		// 		cancelText = $scope.languageData.DP_CANCEL_ENGLISH;
		// 	}else{
		// 		pageTitle = $scope.languageData.HEADER_TITLE_DEFAULT_SPANISH;
		// 		continueText = $scope.languageData.CONTINUE_BUTTON_SPANISH;
		// 		cancelText = $scope.languageData.DP_CANCEL_SPANISH;
		// 	}
		// }else{
		// 	if(lang == null || lang == undefined || lang == 'en'){
		// 		pageTitle = "For Your Information";
		// 		continueText = "Continue";
		// 		cancelText = "Cancel";
		// 	}else{
		// 		pageTitle = "Para su informaci&oacute;n";
		// 		continueText = "Continuar";
		// 		cancelText = "Cancelar";
		// 	}
		// }
		// $scope.pageTitle = pageTitle;
		// $scope.continueText = continueText;
		// $scope.cancelText = cancelText;

		var outsideButtons = document.getElementById("disclaimerButtons");
		$(".whiteBoxBlock").append(outsideButtons);


		// Branding API

		if (sessionStorage.navbrandingCharacteristicsResponse != undefined) {
			var branding = JSON
					.parse(sessionStorage.navbrandingCharacteristicsResponse);

			var getAPIArray = branding.readCorrespondenceARMSRulesResponse.correspondenceARMSRulesCharacteristics;
			for (var i = 0; i < getAPIArray.length; i++) {
				if (getAPIArray[i].name == "Secure Logo Location") {
					$scope.logoLocation = getAPIArray[i].value;
				}
				if (getAPIArray[i].name == "LogoFileName") {
					$scope.logoName = getAPIArray[i].value;
				}
				if (getAPIArray[i].name == "OrgName") {
					$rootScope.organization = getAPIArray[i].value;
					$rootScope.tt = false;
					$rootScope.shw = true;
				}
				$scope.logoImg = $scope.logoLocation + $scope.logoName;
			}

		}

		$scope.close = function() {
			var win = window.open("", "_top", "", "_true");
			win.opener = true;
			win.close();
		};		

		// var url = $state.params.storeURL;

		var url = window.location.href;
		if(url.indexOf("&storeURL=") > -1){
			url = url.split("&storeURL=")[1];
		}
		url = url.split("~2F").join("/");
		url = url.split("%2F").join("/");

		document.title = "Disclaimer";

		$scope.disclaimerContinue = function() {
			window.location.href = decodeURIComponent(url);
		};

	};

})();

},{}],4:[function(require,module,exports){
(function() {
	angular
	.module('nav-ui')
	.controller('FooterController', FooterController);
	FooterController.$inject = ['$scope', 'PageBuilderService', '$state', 'ContentResultsService', '$http', 'configuration'];
	function FooterController($scope, PageBuilderService, $state, ContentResultsService, $http, configuration) {
		var ctrl = this;
		ctrl.showFooter = showFooter;
		ctrl.message = {};
		ctrl.message.text = '';

		var thisSite_id = $state.params.site_id;

		// Check Site_id Parameter			
		var customSiteIdList= configuration.customSiteIds;
		var isSiteIdCorrect = false;
		for(var index in customSiteIdList){
			if (thisSite_id == customSiteIdList[index]) {
				isSiteIdCorrect = true;
				break;
			}
		}
		if(isSiteIdCorrect == true && $state.params.page !== undefined){			
			showFooter();
		}

		function showFooter() {
			var contentId = 'footerChrome';
			var contentType = 'biz';
			var contentLang = '';
			ContentResultsService.getContent(contentId, contentType, contentLang)
			.then(
					function success(result) {
						// promise was fullfilled (regardless of outcome)
						// checks for information will be peformed here
						PageBuilderService.buildPage(result);
					},
					function error (errorMsg) {
						// handle errors here
						ctrl.message.text = errorMsg.statusText;
					}
			);
		}
//below if condition is to check if the device is mobile or desktop
		if(!( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) {
			//Code for scroller on page
			$(".upPointer img").on('mouseover', function(e) {
				$(this).attr('src','images/up_scroll_arrow_Active.png')
			});
			$(".downPointer img").on('mouseover', function(e) {
				$(this).attr('src','images/down_scroll_arrow_Active.png');
			});
			$(".upPointer img").on('mouseout', function(e) {
				$(this).attr('src','images/up_scroll_arrow.png')
			});
			$(".downPointer img").on('mouseout', function(e) {
				$(this).attr('src','images/down_scroll_arrow.png');
			});
		}

			if ($(document).scrollTop() > $(window).height() / 2) {
				$('.fixedScroller').addClass('flotedScrollTop');
			} else {
				$('.fixedScroller').removeClass('flotedScrollTop');
			}

			$(window).scroll(function() {
				if (!$(document).scrollTop() == 0) {
					$(".upPointer").addClass('show');
				} else {
					$(".upPointer").removeClass('show');
				}
				if ($(document).height() - $(window).height() === $(document).scrollTop()) {
					$('.fixedScroller').addClass('end');
				} else {
					$('.fixedScroller').removeClass('end');
				}
			});

			$('.fixedScroller span').on('click', function() {

				var winHeight = $(window).height();
				if ($(this).parent().hasClass('downPointer')) {
					$('body,html').animate({
					   scrollTop: $(document).height()
					}, 1000);
				} else {
					$('body,html').animate({
						scrollTop: 0
					}, 1000);
				}
			});
			/*functionality for accessibility*/
        $('.fixedScroller a').on('keyup', function(event) {
            if(event.which==13 || event.which==32){
                var winHeight = $(window).height();
                if ($(this).hasClass('downPointer')) {
                    $('body,html').animate({
                       scrollTop: $(document).height()
                    }, 1000);
                } else {
                    $('body,html').animate({
                        scrollTop: 0
                    }, 1000);
                }
            }
	});
	}
})();

},{}],5:[function(require,module,exports){
(function() {
	angular.module('nav-ui').controller('medicareCountyController', medicareCountyController);

	medicareCountyController.$inject = ['$scope', 'configuration', '$sessionStorage',
	                                    'ProviderSearchCriteriaService', '$q', '$state', '$log', '$rootScope', '$http',
	                                    'ProviderResultsService', '$translate', '$sce', '$timeout', '$window', 'AnalyticsService', '$location', 'NavSpinnerService', 'PlanListService', 'CommonUtilsService', 'mapsService', '$compile', 'LanguageDataService'
	                                    ];

	function medicareCountyController($scope, configuration, $sessionStorage,
			ProviderSearchCriteriaService, $q, $state, $log, $rootScope, $http,
			ProviderResultsService, $translate, $sce, $timeout, $window, AnalyticsService, $location, NavSpinnerService, PlanListService, CommonUtilsService, mapsService, $compile, LanguageDataService) {

		var ctrl = this;
		$scope.$watch("ctrl.noResultsSearch", function() {
			if (ctrl && ctrl.noResultsSearch && $scope.criteria.typeAheadSearch.length >= 3) {
				AnalyticsService.trackError({
					errorFor: 'typeahead search',
					errorMsg: 'noMatchInSearchTypeahead',
					searchTerm: $scope.criteria.typeAheadSearch,
					state: 'error'
				});
			}
		});

		$rootScope.$on("destroyScope", function() {
			$scope.$destroy();
		});
		$scope.isFirstRunForLandingPageByPass = true;
		$scope.isFirstRunForLandingPageByPassSyncCalls;
		$scope.showLocation = false;
		ctrl.showRestrictedMessage = false;
		var flagForSess = sessionStorage.getItem('boolForGeo');
		if( document.getElementById('dynamicTemplate')  )
			document.getElementById('dynamicTemplate').style.display = 'none';
		if (window.history && window.history.pushState) {
			//window.history.pushState('forward', null, './#forward');
			$(window).on('popstate', function() {
				angular.element(".modal-backdrop").css("display", "none");
				// var historyObj = window.history;
				// if(location.href=="url"){
				// 		history.go(-1);
				// 	}
			});
		}
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.planCriteria = ProviderSearchCriteriaService.getPlanCriteria();
		$scope.criteria.medicare.planTypeaHeadLocation = '';
		$scope.criteria.medicare.medicareLandingUrl = window.location.href;
		$scope.languageData = LanguageDataService.getLanguageData();
		var currentPage = $location.search().page;
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		if(window.location.href.indexOf("medicareaep=true") > -1 || $sessionStorage.medicareaep == 'true')
		{
			var currentYear = (new Date()).getFullYear();
			var nextYear = currentYear + 1;
			$scope.years=[currentYear,nextYear];
			$sessionStorage.medicareaep = 'true';
		}
		else{if($scope.languageData.MED_YEARS_TO_DISPLAY != null && $scope.languageData.MED_YEARS_TO_DISPLAY != undefined)
			{
				$scope.years=$scope.languageData.MED_YEARS_TO_DISPLAY.split(",");
			}else{
				var currentYear = (new Date()).getFullYear();
				if(currentYear >= '2020'){
					$scope.years=['2020'];
				}else{
					$scope.years=['2019','2020'];
				}
			}
		}
		$scope.criteria.planProductCode = '';
		$scope.criteria.medicare.medOrDen = -1;
		var language = $scope.criteria.language;
		$scope.isLocationError = false;
		$scope.isCountyError = false;
		var memberPleat = false;
		var geoPleat = false;
		var perResidencePleat = false;
		var isLocationboxClicked = false;
		//var currentLocationAllowed = "";
		clicked = false;
		var geoTemplate = '';
		$scope.counties = '';
		var isJustDebugAdded = false;
		var typeAheadResults = '';
		$scope.areTypeAheadResultsReturned = true;

		if (window.location.href.indexOf("providerSearchLanding") !== -1) {
			$scope.criteria.typeAheadSearch = ''; // value in the search box
			$scope.criteria.typeAheadLocation = ''; // value in the location box
			$scope.criteria.typeAheadLocationClicked = null; // what was clicked on for location search
			$scope.criteria.typeAheadLocationResults = {};
			if ($sessionStorage.criteria && $sessionStorage.criteria.typeAheadLocationResults) {
				$sessionStorage.criteria.typeAheadLocationResults = {};
			}
		}

		if(window.location.href.indexOf("debug=true") > -1){
			$scope.criteria.medicare.isDebug = true; // Show debug Info
		}else if(window.location.href.indexOf("debug=false") > -1){
			$scope.criteria.medicare.isDebug = false; // DO NOT show debug Info
		}else {
			if(configuration.debugPlanInfo == "true"){ //config.json (prod : false and QA : true)
				$scope.criteria.medicare.isDebug = true; // Show debug Info
			} else{
				$scope.criteria.medicare.isDebug = false;// DO NOT show debug Info
			}
		}

		// $scope.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;
		if ($sessionStorage.criteria) {
			$sessionStorage.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;
		}
		var clearSess = function() {
			if (flagForSess == "true") {
				$scope.criteria.typeaheadLocation = "";
				sessionStorage.setItem('boolForGeo', "false");
			}
			if (window.performance) {}
			if (performance.navigation.type == 1) {
				$scope.criteria.typeaheadLocation = "";
			} else {}
		}
		clearSess();
		if (window.location.href.indexOf("providerSearchLanding") != -1) {

			var isMainWhiteBlockOne = document.getElementById("mainWhiteBlockOne");
			if (isMainWhiteBlockOne == undefined) {
				$('.aet-content-fluid.linkBlockStyle.container > div:lt(1), .aet-content-fluid.linkBlockStyle.container > h2:lt(1), .aet-content-fluid.linkBlockStyle.container > p:lt(2)').wrapAll('<div class="whiteBoxBlock container widthAdj" id="mainWhiteBlockOne"></div>');
				//for footer
				/* Most  custom sites will not have the extra links so added check for usefulRescources */
				if ($("[nvstyle='homePgExtraLinks']").length != 0) {
					$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //'Important Information' block
					$("[nvstyle='homePgExtraLinks']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //Extra links on Landing Page
					if ($("[nvstyle='usefulResourcesContent']").length != 0) {
						$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //'Other useful resources' block
					}
					// $("#emptyLink").first().attr("style","padding:3px 20px !important; width:240px !important;");
					//$("#buttonEmptyLink").addClass("landingBtnWidth txtAlgCntr");
					//$("#emptyLink").addClass("BtnWidth txtAlgCntr");
				} else {
					if ($("[nvstyle='usefulResourcesContent']").length != 0) {
						$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
						$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
					} else {
						if ($(".customLinkDiv").length != 0) {
							$(".customLinkDiv").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //For Important Info block if Other Useful resources block is not present.
						} else
							$("#mainWhiteBlockOne").next().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //For Important Info block if Other Useful resources block is not present.
					}
				}
				// $("[nvstyle='customCenterLink']:first").prepend("<br/><br/>");
				//$("[nvstyle='customCenterImg']").nextAll().wrap('<div class="customLinkDisplay"></div>');
				$("[nvstyle='customCenterImg']").first().css("display", "block");
				$("[nvstyle='customCenterImg']").first().css("padding-bottom", "20px");
				// $("[nvstyle='customCenterLink']").after("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;");
				// $("[type='columnTwo']").addClass('sectionPartition');
				$("[type='columnTwo']").addClass('sectionPartition landingMarT15 columnTwoTablet columnTabletWidth');
				$(".purplePleat h2.firstPleatHead").nextAll().wrapAll("<div class='minHt420' id='firstPleatBody'></div>");

				if((navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)) && $(window).width() < 992 ){
					$scope.criteria.medicare = {
							memberPleat: false,
							geoPleat: false,
							perResidencePleat: false
					}

					if (window.location.href.indexOf("openPleats") != -1) {
						memberPleat = false;
						geoPleat = false;
						perResidencePleat = false;
					} else {
						memberPleat = $scope.criteria.medicare.memberPleat;
						geoPleat = $scope.criteria.medicare.geoPleat;
						perResidencePleat = $scope.criteria.medicare.perResidencePleat;
					}

					if (memberPleat === false) {
						$("#firstPleatBody").hide();
					}
					if (geoPleat === false) {
						$(".secondPleatBody").hide();
					}


					$(".firstPleatHead").attr("tabindex", "0");
					$(".secondPleatHead").attr("tabindex", "0");
					$(".thirdPleatBody").attr("tabindex", "0");

					$(".firstPleatHead").keypress(function(e) {
						if (e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
							memberPleat = !memberPleat;
							$scope.criteria.medicare.memberPleat = !memberPleat;
							$("#firstPleatBody").toggle(1000);
						}
					});

					$(".secondPleatHead").keypress(function(e) {
						if (e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
							geoPleat = !geoPleat;
							$scope.criteria.medicare.geoPleat = !geoPleat;
							$(".secondPleatBody").toggle(1000);
						}
					});

					$(".firstPleatHead").click(function() {
						memberPleat = !memberPleat;
						$scope.criteria.medicare.memberPleat = !memberPleat;
						$("#firstPleatBody").toggle(1000);
					});
					$(".secondPleatHead").click(function() {
						geoPleat = !geoPleat;
						$scope.criteria.medicare.geoPleat = !geoPleat;
						$(".secondPleatBody").toggle(1000);
					});
				}

				$("#firstPleatBody").wrap("<div class='customFltLt'></div>");

				$("#firstPleatBody > a:lt(2), #firstPleatBody > span:lt(1)").wrapAll('<div class="col-lg-12 col-xs-12 col-sm-12 col-md-12 pad0 padT10 padB20" id="landingbuttonBlock"></div>');

				$("[nvstyle='secure_button']").wrap("<div class='col-lg-6 col-md-12 col-sm-12  col-xs-12 pad0 secureButtonBlk' id='secureButtonBlock'></div>");
				$("#secureButtonBlock").next('span').next().addBack().wrapAll("<div class='col-lg-6 col-md-12 col-sm-12  col-xs-12 pad0 padL10 registerButtonBlk'></div>");

				$('.customFltLt').prev().addClass('greyshdw');
				$('.secondPleatHead').addClass('greyshdw');
				// $("[nvstyle='homePageUnordered']:first").nextAll(':lt(2)').wrapAll( "<div class='customFltRt'></div>" );

			}
		}

		// Empty href Issue on landing Page buttons Medicare
		$("[linkToReplace]").each(function() {
			if($(this).children().attr("href")==""){
				var curLink = $(this).attr("linkToReplace");
				$(this).children().attr("href",curLink);	
				$(this).children().attr("target","_blank");			
				$(this).wrap( "<a href="+curLink+" target='_blank'></a>" );
				$(this).removeAttr("linkToReplace");
			}else{
				$(this).removeAttr("linkToReplace");
			}
		});
		
		var tempVar1 = $("[nvstyle='usefulResourcesContent']");
		if (tempVar1 && tempVar1.length) {
			if (tempVar1[0].children[0].innerHTML == "") {
				tempVar1.css("display", "none")
			}
		}

		if ($state.params.language != null && $state.params.language != undefined) {
			$scope.criteria.lang = $state.params.language;
			var lang = $translate.use();
			lang = $state.params.language;
		} else {
			$scope.criteria.lang = "en";
			var lang = $translate.use();
			lang = "en";
		}

		if ($translate.use() == 'es')
			event = "SP_PRVINQ";
		else
			event = "PRVINQUIRY";
		//call the events api.
		var eventType = "";
		// a flag which indicates if the user just selected a location.  It will be set when the user selects
		// a location and reset when the user does something that activates type-ahead again.
		var justSelectedLocationFlag = false;
		this.disableLocationJustSelected = function() {
			$scope.disableText = true;
			$scope.isShowCounty = false;
			$scope.counties = '';
			$scope.county = '';
			justSelectedLocationFlag = false;
			$scope.isLocationError = false;
			$scope.isCountyError = false;
			//$scope.slider.options.disabled = false;
		}

		$scope.getTypeAheadLocationInfo = function(val) {
			ProviderSearchCriteriaService.getTypeAheadLocationInfo(val).then(
					function success(result) {
						typeAheadResults = result;
						$scope.areTypeAheadResultsReturned = $scope.criteria.medicare.areTypeAheadResultsReturned;
						NavSpinnerService.stop();
					},
					function error() {
						NavSpinnerService.stop();
					});
			return ProviderSearchCriteriaService.getTypeAheadLocationInfo(val);
		};

		$scope.setTypeAheadForLocation = function(item) {
			var debug = $state.params.debug;
			$scope.isLocationError = false;
			$scope.isCountyError = false;
			ProviderSearchCriteriaService.setTypeAheadForLocation(item);
			$scope.slider.options.disabled = item.subcategory === 'county' || item.subcategory === 'state';
			$rootScope.$broadcast('rzSliderForceRender');
			$scope.criteria.typeAheadLocation = $scope.criteria.medicare.planTypeaHeadLocation;
			justSelectedLocationFlag = true;
			if (item.subcategory !== 'county') {

				NavSpinnerService.spin();
				ProviderSearchCriteriaService.getCounties(item,debug).then(
						function success(result) {
							if(result.CountyList && result.CountyList.counties && result.CountyList.counties.county){
							for (var i = 0; i < result.CountyList.counties.county.length; i++) {
								//if (item.subcategory == result.results[i].type) {
									$scope.counties = result.CountyList.counties.county;
									if ($scope.counties.length == 1) {
										$scope.county = $scope.counties[0];
									}

								//}
							}
						}
							$scope.isShowCounty = true;
							NavSpinnerService.stop();
							document.getElementById('dynamicTemplate').scrollIntoView();
							document.getElementById('planSelectionBtn').focus();
						},
						function error() {
							NavSpinnerService.stop();
						});
			} else {
				$scope.isShowCounty = false;
				var defCounty ={};
				defCounty.displayName = item.label;
				defCounty.name = item.county;
				defCounty.stateAbbr = item.stateabbr;
				$scope.selectedCounty(defCounty);
			}
		};

		$scope.selectedCounty = function(county){
			$scope.isCountyError = false;
			$scope.county = county;
		};

		$scope.disablePlanButtons = function() {
			if ($scope.criteria.medicare.planTypeaHeadLocation && ($scope.criteria.typeAheadLocationClicked && $scope.criteria.typeAheadLocationClicked.subcategory && $scope.criteria.typeAheadLocationClicked.subcategory != 'county')) {
				if($scope.county){
					return false;
				} else{
					return true;
				}

			} else if ($scope.criteria.medicare.planTypeaHeadLocation && ($scope.criteria.typeAheadLocationClicked && $scope.criteria.typeAheadLocationClicked.subcategory && $scope.criteria.typeAheadLocationClicked.subcategory == 'county')){
				return false;
			} else {
				return true;
			}
		};


		$scope.reportError = function(typeaheadLocation, errorMsg, errorFor) {
			AnalyticsService.trackError({
				errorFor: errorFor,
				errorMsg: errorMsg,
				geoSearchTerm: typeaheadLocation,
				state: 'error'
			});
		};

		/*Slider object declaration*/
		$scope.slider = {
			value: 25,
			options: {
				floor: 0,
				ceil: 100,
				step: 1,
				showSelectionBar: true,
				translate: function(value) {
					return value + ' ' + ($scope.criteria.language == 'en' ? 'Miles' : 'Millas');
				}
			}
		};

		var changeLocationPopover = {
				templateUrl: 'changeLocation.html'
		};

		$scope.showAllItems = function(group, count) {
			return ProviderSearchCriteriaService.showAllItems(group, count);
		};

		$scope.clickViewMore = function(group, limit) {
			return ProviderSearchCriteriaService.clickViewMore(group, limit);
		};

		$rootScope.closeSpinner = function() {
			CommonUtilsService.closeSpinner();
		}
		//medicare plan selection
		$scope.selectedPlan = function(planYear, category, index){
			
			if( $state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) 
			   && $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPass 
			  && ( $state.params.useNewBypassMethod == undefined || $state.params.useNewBypassMethod == false) )
			{
				NavSpinnerService.spin();
			}
			$scope.selectedIndex = index;
			PlanListService.selectedPlan(planYear,category,index);
			$scope.isShowCounty = PlanListService.getShowCounty();
			$scope.slider.value = 25;
			$timeout(function () {
				$scope.$broadcast('rzSliderForceRender');
			});
			var isOpened = PlanListService.getGeoTemplate();
			 if(!isOpened){
				 $(".thirdPleatBody").toggle(1000);
				 PlanListService.setGeoTemplate(!isOpened);
			 }
			angular.element(document.getElementById("medZip")).focus();
			
			$scope.skipGeoSelectionPage();
		};

		$scope.skipPlanSelect= function(){
			ProviderSearchCriteriaService.setDistance($scope.slider.value);
			if($scope.counties!='' && $scope.counties.length>0 || ($scope.county!=null && $scope.county!="")) {
				//Set sessionStorage.criteria id not already set*/
				if($sessionStorage.criteria == undefined)
				{
					$sessionStorage.criteria = $scope.criteria;

				}

				/*Set default value of typeahead to user entered location*/
				if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
					$scope.criteria.typeAheadLocationResults = $scope.criteria.medicare.planTypeaHeadLocation;
				}

				if($scope.county!=null && $scope.county!="")
				{
					$scope.criteria.medicare.county = $scope.county.name;
					$scope.criteria.medicare.state = $scope.county.stateAbbr;
				}
				else
				{
					$scope.isCountyError = true;
					return $scope.isCountyError;
				}

				selPlan = "";
				$scope.isPlanSelected= false;
				ProviderSearchCriteriaService.setPlanProductCode(selPlan);
				ProviderSearchCriteriaService.setPlanPipeName('');
				ProviderSearchCriteriaService.setPlanName("No plan chosen | ");

				/* Setting values in $sessionStorage to avoid sporadic IE issues */
				$scope.criteria.planProductCode = selPlan;
				$scope.criteria.planPipeName = '';
				$scope.criteria.planName =  "No plan chosen | ";
				$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
				fetchPlans('skipPlans');
			}
			else if($scope.criteria.medicare.planTypeaHeadLocation && typeAheadResults && typeAheadResults.length == 0)
				$scope.areTypeAheadResultsReturned = false;
			else
				$scope.isLocationError = true;

		};
		$scope.count = 0;

		$scope.skipLandingPage = function (){
			//ACNLA5_0602 code change start
			//ProviderSearchCriteriaService.setDistance($scope.slider.value);
			ProviderSearchCriteriaService.setDistance($scope.criteria.distance);
			//ACNLA5_0602 code change end
			year = $state.params.year;
			category = $state.params.category;

			index = -1;

			if( year && category && 
					( category == 'i' || category == 'I' || category == 'G' || category == 'g' ))
			{
				if( category == 'i' )
				{
					$state.params.category = 'I';
					category = 'I';
				}
				if( category == 'g' )
				{
					$state.params.category = 'G';
					category = 'G';
				}
				for(var i=0; i<$scope.years.length;i++)
				{
					if(year==$scope.years[i])
					{
						index = i;
						$scope.selectedPlan(year,category,index);
						$scope.count = $scope.count+1;
						break;
					}
				}
			}
			
			if ( $scope.count == 0 )
			{
				return;
			}
		};
		
		$scope.skipGeoSelectionPage = function ()
		{
			
			if( $state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) 
					   && $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPass
			  		&& ( $state.params.useNewBypassMethod == undefined || $state.params.useNewBypassMethod == false) )
			{
				var zip = $state.params.ZipCode+ '';
				
				if( zip.indexOf('.') > -1 )
				{
					NavSpinnerService.stop();
					return;
				}
				if( zip.length == 1 )
				{
					document.getElementById("medZip").value = $state.params.ZipCode;
					NavSpinnerService.stop();
					return;
				}
				
				$scope.isFirstRunForLandingPageByPass = false;
				
				NavSpinnerService.spin();
				document.getElementById("medZip").value = $state.params.ZipCode;
				var element = document.getElementById('medZip');
				var evt = document.createEvent('HTMLEvents');
				evt.initEvent('change', false, true);
				element.dispatchEvent(evt);

				/*var item = getTypeAheadLocationInfo($state.params.ZipCode );
				item = item;*/

				ProviderSearchCriteriaService.getTypeAheadLocationInfo($state.params.ZipCode).then(
						function success(result) {
							typeAheadResults = result;
							$scope.areTypeAheadResultsReturned = $scope.criteria.medicare.areTypeAheadResultsReturned;
							if( typeAheadResults && typeAheadResults.length == 1 && typeAheadResults[0] &&
							  typeAheadResults[0].zipcode && typeAheadResults[0].zipcode == $state.params.ZipCode )
							{
								var item = typeAheadResults[0]

								$scope.criteria.medicare.planTypeaHeadLocation = item;
								/*var element = document.getElementsByClassName('typeahead_grouping active')[0];
								console.log(" Selected Item" + element)
								var evt = document.createEvent('HTMLEvents');
								evt.initEvent('click', false, true);
								element.dispatchEvent(evt);*/

								//$scope.setTypeAheadForLocation( typeAheadResults[0] );
								{
										var debug = $state.params.debug;
										$scope.isLocationError = false;
										$scope.isCountyError = false;
										ProviderSearchCriteriaService.setTypeAheadForLocation(item);
										$scope.slider.options.disabled = item.subcategory === 'county' || item.subcategory === 'state';
										$rootScope.$broadcast('rzSliderForceRender');
										$scope.criteria.typeAheadLocation = $scope.criteria.medicare.planTypeaHeadLocation;
	
										justSelectedLocationFlag = true;
										if (item.subcategory !== 'county') {
	
//											NavSpinnerService.spin();
											ProviderSearchCriteriaService.getCounties(item,debug).then(
													function success(result) {
														if(result.CountyList && result.CountyList.counties && result.CountyList.counties.county){
															for (var i = 0; i < result.CountyList.counties.county.length; i++) {
																$scope.counties = result.CountyList.counties.county;
																if ($scope.counties.length == 1) {
																	$scope.county = $scope.counties[0];
	
																	/*var element = document.getElementsByClassName('typeahead_grouping active')[0];
																	console.log(" Selected Item" + element)
																	var evt = document.createEvent('HTMLEvents');
																	evt.initEvent('click', false, true);
																	element.dispatchEvent(evt);*/
																}
															}
	
															if ($scope.counties.length > 1)
																$scope.isCountyError = true;
															{
	
																var element = document.getElementsByClassName('typeahead_grouping active')[0];
																if( element )
																{ 
																	var evt = document.createEvent('HTMLEvents');
																	evt.initEvent('click', false, true);
																	element.dispatchEvent(evt);
																}
	
															}
														}
														$scope.isShowCounty = true;
														if( document.getElementById('dynamicTemplate') )
															document.getElementById('dynamicTemplate').scrollIntoView();
														document.getElementById('planSelectionBtn').focus();
														NavSpinnerService.stop();
	
														element = document.getElementById('planSelectionBtn');
														console.log(" Selected Item" + element)
														var evt = document.createEvent('HTMLEvents');
														evt.initEvent('click', false, true);
														element.dispatchEvent(evt);
														//$scope.continueToPLanSelection();
														
														NavSpinnerService.stop();
													},
													function error() {
														NavSpinnerService.stop();
													});
										}
								}

							}
							else
							{
								NavSpinnerService.stop();
								NavSpinnerService.stop();
							}
						},
						function error() {
							NavSpinnerService.stop();
						});
			}
			
		};

		$scope.bypassLandingPage = function (){
			if( $state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) 
					   && $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPassSyncCalls == undefined
					   && $state.params.useNewBypassMethod )
			{
				$scope.isFirstRunForLandingPageByPassSyncCalls = true;
				skipGeoSelectionPageSyncCalls();
			}
			else
				return;
		};
		
/*		async function skipGeoSelectionPageSyncCalls(){

			if( $state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) 
					&& $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPassSyncCalls
					&& $state.params.useNewBypassMethod )
			{

				{
					ProviderSearchCriteriaService.setDistance($scope.criteria.distance);
					year = $state.params.year;
					category = $state.params.category;

					index = -1;

					if( year && category && 
							( category == 'i' || category == 'I' || category == 'G' || category == 'g' ))
					{
						for(var i=0; i<$scope.years.length;i++)
						{
							if(year==$scope.years[i])
							{
								index = i;
								//$scope.selectedPlan(year,category,index);
								{
									$scope.selectedIndex = index;
									PlanListService.selectedPlan(year,category,index);
									$scope.isShowCounty = PlanListService.getShowCounty();
									$scope.slider.value = 25;
								}
								break;
							}
						}
						if ( index == -1 )
						{
							$scope.count = 0;
							$state.params.useNewBypassMethod = false;
							//$scope.skipLandingPage();
							$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
								year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
							return -1;
						}
					}
					else
					{
						$scope.count = 0;
						$state.params.useNewBypassMethod = false;
						//$scope.skipLandingPage();
						$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
							year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
						return -1;
					}
				}

				var zip = $state.params.ZipCode+ '';
				if( zip.indexOf('.') > -1 )
				{
					NavSpinnerService.stop();
					$scope.count = 0;
					$state.params.useNewBypassMethod = false;
					//$scope.skipLandingPage();
					$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
						year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
					return -1;
				}
				if( zip.length == 1 )
				{
					document.getElementById("medZip").value = $state.params.ZipCode;
					NavSpinnerService.stop();
					$scope.count = 0;
					$state.params.useNewBypassMethod = false;
					//$scope.skipLandingPage();
					$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
						year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
					//NavSpinnerService.stop();
					return -1;
				}

				$scope.isFirstRunForLandingPageByPassSyncCalls = false;

				NavSpinnerService.spin();

				var item; 

				await ProviderSearchCriteriaService.getTypeAheadLocationInfo($state.params.ZipCode).then(
						//ProviderSearchCriteriaService.getTypeAheadLocationInfo($state.params.ZipCode).then(
						function success(result) {
							typeAheadResults = result;
							$scope.areTypeAheadResultsReturned = $scope.criteria.medicare.areTypeAheadResultsReturned;
							if( typeAheadResults && typeAheadResults.length == 1 && typeAheadResults[0] &&
									typeAheadResults[0].zipcode && typeAheadResults[0].zipcode == $state.params.ZipCode)
							{
								item = typeAheadResults[0]

								$scope.criteria.medicare.planTypeaHeadLocation = item;
							}
							else 
							{
								NavSpinnerService.stop();
								$scope.count = 0;
								$state.params.useNewBypassMethod = false;
								//$scope.skipLandingPage();
								$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
									year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
								NavSpinnerService.stop();
								return -1;
							}
						},
						function error() {
							NavSpinnerService.stop();
						});

				if( typeAheadResults && typeAheadResults.length == 1 && typeAheadResults[0] &&
						typeAheadResults[0].zipcode && typeAheadResults[0].zipcode == $state.params.ZipCode )
				{
					{
						var debug = $state.params.debug;
						$scope.isLocationError = false;
						$scope.isCountyError = false;
						ProviderSearchCriteriaService.setTypeAheadForLocation(item);
						$scope.slider.options.disabled = item.subcategory === 'county' || item.subcategory === 'state';
						$rootScope.$broadcast('rzSliderForceRender');
						$scope.criteria.typeAheadLocation = $scope.criteria.medicare.planTypeaHeadLocation;

						justSelectedLocationFlag = true;
						if (item.subcategory !== 'county') {

							await ProviderSearchCriteriaService.getCounties(item,debug).then(

									function success(result) {
										if(result.CountyList && result.CountyList.counties && result.CountyList.counties.county){
											for (var i = 0; i < result.CountyList.counties.county.length; i++) {
												$scope.counties = result.CountyList.counties.county;
												if ($scope.counties.length == 1) {
													$scope.county = $scope.counties[0];
												}
											}

											if ($scope.counties.length > 1)
											{
												$scope.isCountyError = true;
												NavSpinnerService.stop();
												$scope.count = 0;
												$state.params.useNewBypassMethod = false;
												//$scope.skipLandingPage();
												$state.go('contentPage',{page:'providerSearchLanding',site_id:siteId,language:language,
													year:$state.params.year,category:$state.params.category,ZipCode:$state.params.ZipCode,useNewBypassMethod:''});
												NavSpinnerService.stop();
												return -1;

											}
										}

										$scope.isShowCounty = true;

										if ($scope.counties.length == 1)
										{
											ProviderSearchCriteriaService.setDistance($scope.slider.value);
											if(($scope.counties!='' && $scope.counties.length>0) || ($scope.county!=null && $scope.county!="")) {
												if($sessionStorage.criteria == undefined)
												{
													$sessionStorage.criteria = $scope.criteria;

												}

												if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
													$scope.criteria.typeAheadLocationResults = $scope.criteria.medicare.planTypeaHeadLocation;
												}
												if($scope.county!=null && $scope.county!="")
												{
													$scope.criteria.medicare.county = $scope.county.name;
													$scope.criteria.medicare.state = $scope.county.stateAbbr;
												}
												else
												{
													$scope.isCountyError = true;
													return $scope.isCountyError;
												}

												$scope.criteria.dummyPlanCode = '';
												$scope.criteria.planName = '';
												$scope.criteria.planProductCode = '';
												$scope.listOfPlans = '';
											}
											else if($scope.criteria.medicare.planTypeaHeadLocation && typeAheadResults && typeAheadResults.length == 0)
												$scope.areTypeAheadResultsReturned = false;
											else
												$scope.isLocationError = true;

										}

										{}

										NavSpinnerService.stop();
									},
									function error() {
										NavSpinnerService.stop();
									});
						}


					}

					if ($scope.counties.length == 1)
					{

						NavSpinnerService.spin();

						PlanListService.getPlanList()
						.then(
								function success(response){

									$scope.planList = response.data.DocfindSearchPlanList.plans;
									var planList = response.data.DocfindSearchPlanList.plans;
									var planArrList = PlanListService.setPlansArr(planList);
									$scope.planCriteria.planArray = planArrList;

									var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;
									if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
										processDebugInfo = processDebugInfo.values.value;
									}else{
										for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
											if(processDebugInfo[tempI].name == "DiagnosticInfo"){
												processDebugInfo = processDebugInfo[tempI].values.value;
												break;
											}
										}
									}
									$scope.planCriteria.planDebugInfo = processDebugInfo;

									if(planArrList.length > 1){
										$scope.criteria.isSinglePlan = false;
										ProviderSearchCriteriaService.setIsSinglePlan(false);
									}else{
										$scope.criteria.isSinglePlan = true;
										ProviderSearchCriteriaService.setIsSinglePlan(true);
									}
									{
										ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
										$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language,
											year:'',category:'',ZipCode:'',useNewBypassMethod:''});
									}
									NavSpinnerService.stop();
								},
								function error(response){
									console.log("Error in fetching Plans :  ");
									console.log(response);
									NavSpinnerService.stop();
									$scope.planCriteria.planArray = 'ERROR';
									$scope.planCriteria.planDebugInfo = [];
									$scope.criteria.planValFromURL = '';
									//$state.go('contentPage',{page:'providerSearchPlanList'});
									if(data && data == 'skipPlans'){

									} else {
										var siteId = $scope.criteria.siteId;
										var language = $scope.criteria.language;
										$state.go('contentPage',{page:'providerSearchPlanList',siteId:siteId,language:language,
											year:'',category:'',ZipCode:'',useNewBypassMethod:'' });
									}
								}
						);
					}
				}
			}
		};*/
		/**
		 * converted https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&spec=false&loose=false&code_lz=IYZwngdgxgBAZgV2gFwJYHsIxAa1QBwHEBTdAZWIBtio1MAFYAc2LMigGFhLKQAKAJQBvAFABIMQHpJAEhBR0-YgDpcBEuSo06ERixgBeeEloYsg0RLGo4fGHOTBkK_MABOwALYhlALQIc6AAmxDAAZGH2II7Oyq4e3n4BwaEAhEYA5BnhkamoIABywAV8Dk4u7l4-_viBIQIw4lZiMK0RUTEVCdXJITAAfEYADDlRCkrK-QBiqG7RAEpIU-huADLAEEGoEEx6xABCYIwgIGzQXDwgTVato2Wx8VXKCCDEBcQA7oeuJwCyxMgABbBGACa6WKzXMQQqz0NzoABuqBCbgo7iggI4blQzmxwAobiRUBUr2QABF8o5oMRSvJFCooNjcahgMottENsSBABuKFiMDEdyGDrlOKVRIC9y85piKDlJgrMDC-5dJ5y5wKtxgXl87YhAAewoAtABGHUymx2SVuUbq4iapXtPkSOx2h2GTKobIAH29MDdio9MAyAEkfX6A1qgxlCOH_fLAwZMkxsgIwTKYVY4Cs-AihagDENuTBUAAeOTjFTWnzUHZA7moADUjfTGed1ls1qTFfpymrAG1UABdVttmVWPXEQ1GVDS8dSWR0iavai0YhBeiUDZ8a0AGkjYF3k_1PPb0LPYh7y60a6CIc2U-Fx7n883G1WlIJRJJN-cG63EA7oKbj7gmWpHg-J4vuOV4qPkZDAh8gRIMgSpGG-EAftEX6oMSygsMgCHoEh6AoWAgjQTKsGqJQyLEG4yh5pQCChEYABMACslFWAAvmeABGbiCjg3FiHx47ic0kkSNJYhQnmNoAF4EMqHIPOKPS1CkjbBhk0GWjAyn4JMkEAPK2BkygZA0_QwKaoJQpmYhFAiZD4NsED0TheHRIoFF8kJyAIG4EDQbJBlGcotZMECQYmg5zROUE6BQAgnjEBAyD4QCACi1DpZlhwhkEfAAETpUENSlQIjHcCxqmdGK3RJFpISUS5bkeV59HfqoyB-aeMqBcFoVQrJULUdMswLEsKzrJs2y7MwBxHKApzsBcvDCnA3CvNBUIde5ECeaiPW4SSR3-fJ-bOJ4xZ8lCwAfMAOIwHCiJ0ad6KYky9Est5KgEQAKmASgAIKAoKQSrClThmPe2a0o1jyJDUdTEDVQIZXwULSG98JIiiaJuBiWI4n9-JnXhwOg8QENQzD6rwxAiMqk1TxoykmOQ4BzqICgZjYAgUDEicfBCSACCUMgDRORIqHg5DwBBPMxCS9LIDChLUvIKJ1HuMQIOK1Dqvq8gICq0FIXrqplbKIy5N4soFW4QbygG0bdNKyras6xbAIjeuokGQrXsm77GujKH9PK6bftRRlMWAnFCXjnLEjk54wrR97cca_2QxDmeZ7UQ7zKsi7cpCXEAGe8AAASDOwzoT63aJslWFQrztunznAK5R0nQDfUDaJYjDSF7fOjxu58yYLf0fCbiCDA6eHV1p2EudI_4P5EmDZCiV8gpMAhPxCBMA1oooz4Z8X5Rk0gIzcOYDlbhL9tu3EA_S5wSAyGZTAG_D-Rgdq8G_nyd6hNurfTJuXYepJPYxyCMsNYzczB8EzgfKw1EQC0RRMoRQOhb75GAPxagQRW7EE8KoBA_EDwekyAoMicZM60PoWBNCSZgxqWIHpPkMh4ToEInbGQgl0DKzlNEPgGQ3CKTIPg-iqDiSqwfG4ayP87ZlwpsoHOTcmaYFtr2bRTtK5u3wLXWmDd9Ev1GnyAAVi8Qiv51zPx0FMLcl8jDIDcCxSiNgYCYNuuwhh6QmGkUAdZVeIhnRPResgfGH0ibAVJr9PEw8CIALQGrIJ1Ddx3yYNzbGzppBQM-sTVJjt_pU0BgCLJqAcmZ3ycQc-hTdE8xxvOMQ_NTCGMliLNW_BtbS1lheS0wyspZLAFhBJ7QJnKCmTM-2ETsmazmRHSZKzpmUmWShBpPhmGAOEBebpKxAkn1QMKIsJYYClhgPMxZOzDmrN2YAhOdZATFibC2aJXScG_1easrWGyFlbKWc8_ZgLtQnI7IE0uKzIXRVitwk0oy_n_K0VsoxEwIVqwLkOMevETl8ROQE2kmK9lq3eUnAYMBUUnN7hi3s-QpnALOd43xED0WXjQOlUiyA-A9JbivRlTKJhiPhJI0AArZHyMUW4ZRxBVEog0TCni2CukwvXsdbqW8fL9V3hq-cE87GSAAFTcpPloAqCSjDJVSja7KyA8rUIyubQ4HAtwnCKOlGRodgDewAPpMHhAgI6l9gCmARHwgQ-LCUSCtQiW1p8UppTdfbIS5QcrRsyjI-uQNfirGzW6kAqruXECTSZHExbc0ZCgLRKAOAMi7ngF_FtPiWJGvHNa9N7JXDIAxDWgVFaZbcjNZIGJ6KO5SQvI_IiJEyLZ05YS6QBl7Vpsyk6l1NqiolQyEESAXhcJA2oRY8oUTRzjmkGIddjqCLbrdbumRB6IBHqgCezwZ7nDWVUIydAPB7z9QAGoNI-HvLp0hb3pvvflR9YBioyLPRACgq4dD7GQBAH92ZUr8C7VYaQ2qh41J3ldP50h4WZW2CxIG6B6DzRQ9oDBeGJCiBOWU5JsC0nVL1T-cklJOQ0lwfK2qzEMbxstOS4xCK1bpCyHcAFuKayJyBP0IYDRfRwoU1s9IEApaUHkxSwB6RSrVTRei6QFAEmvBOGYMg_UPAsAzVU4AJZKEQGETAbgmaD3YABOOmFlo5CDNs_Z5aTny5BiQCEOA2x1yXvnKKiQQWbOYDsysMLJiWTYoZFx4A5op0wvNZZ0-xAdo6xgExeq6A4AwH9d7Wr6AYAvHojAN19EbaUHQZgfzAXbCl1y7o2myC3FmDzubKKZCqBBhMzADT_XnODeNsrEbmAxs1km_p7humeCzb9PN8ui2w7La6xANbE3-JTe4VF0rsWgjHO5ZeBTA29HHYMadjZmsjD7Z0WY6uSG66N1e7Y-NYlCuSBgMV55SpgD4HwPCOHLJnCUDAL1yTOLtMGG2_p9o8KyLGeqjCxLj2tEDd-wyLFX2tNkWUK-9KIPifGNJ-uV21deHZahX1coYN-KCRB9OmUXdiAwvPA9hnEwWVbLZTaDlfjhfjwDiFMYzL_6S_fisenJLuXfadkENKngjgAXRsKLIIPtcshrhsH1rFdKm6ewtpD71de0CN5kfhWuAW0WiOZDCn2bdg7gACDEPvwNdP553cBJY-t24O2Ti3EAAc2Jbu0F7PszZrMiCns7SLk7cLUzC_WQkkG5w-5bQOlDQFf3jYL_PAL8grYgFLpdsuLxh7kn8wjureq-UNWPGeZ4hWC0XjmMz84O-by7wakPMp1WUWkuNZo0gA8DsBMHy9rGZRj4QZdU8kCAIzIyQCDCMzBB8nacU-cA--nC1FkMtW-BMCvGOSXAFSGZnApAPfiArw2ROFZGSFKMWmwFSK-e-OySGIAY8J8r-lI7-n-3-QQv-yg_-UAgBQQwBR-YBAEEBZ4UBAEYM78b-6EoB2ExGpIPu-By80B0QzG1ESGcCOiSGFBwAaEMAjBBBlI-W44UB8IN-ZILSF8CMjWRgEscBKgCBjgSBABeo6BxBWUnuyAghOU-oGIGwLANYlIihyhgIqhXK84locOKUgyfBrSgh1KyKRg12gBNs7QBhvB_BTAphlWasMA6QTWD4VhlCNhPBRh9hjhdUVKThLhFh7ht292XSthPhJhLMQhrB3hJwxhAh0RImLEPgThvegujK2Yy8J8t0-AIYVyxYuR-RdyER8RvhSR2ehRp6IYzYYRXS-hcRIACRDh0R_YRRQ4NOXgrERgpUFIzA7m0QuEgh1UiWpRTR5R2YwoYxzRghbR1RHRThqR_hIOgkwk8areYeYetBhuA2SGMx0RUxjR-x2YnBFotgbBawOy2etKqKjKZurI8Ei01AGEn84ChK7GMCJMP0zmCCAIIYpwTxxAGEgqX8zGPEGRs60eOijxOwzxAETeuhr4BM5SKS3x8CpBfxAJsJQJAEfAHaYmZ4YevcHxX0Xx9B6SxGmSuWggqgHwOIGING86YMPAGBEAOArxe0z-jUCoMiCgmUbqewzaQgrgLAAAXBkAYdAqSUHrIc2iAOTIGsiKKfKc4MVLuABEwAgMtKKRqVqSwLPNytaOKc2geMabuJzCEGac1u8F8KDGtP8ECMEMaTPoSWeJvqQZPnhn3hfvPIPmrsvCIQ_hjL3HySAP-ioJ1kwGVI3tsPAIHoCItG9FgTAKKa0NVGPKGeGVFOgFGYGV_gSV0u6TxiRjQS_jsfbnge_MwcbjlPMPMKZPMG7vONsRsOSebnsRMTEf2ASs_iThWRsEBtwFMPCJ4AAKrzCrDG5NlXqLjcnoC8mYDOCZSCm7jCnakSnIkcZfEYHRAZAun1G2DiEubtBHnRhqD4A-7WTr7zg8StYR69wnwqnEDFTs6ZashPnFSQFCi6nLSvkDY_ksBjxsw8l1qLkCnLRCkinEDimSkonfQ7nIBynkzFTKnIVBDqmqF6nQUAXEAGnoowBGlZCgQaiKhmkWnQVEXWmfDfD2kAjAhBDGkwD7nji3D84dw77NBjRQjXCSQ8TchAA&debug=false&forceAllTransforms=true&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2%2Cenv&prettier=false&targets=&version=7.11.5&externalPlugins=*/
		"use strict";

		"use strict";

		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

		function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

		function skipGeoSelectionPageSyncCalls() {
		  return _skipGeoSelectionPageSyncCalls.apply(this, arguments);
		}

		function _skipGeoSelectionPageSyncCalls() {
		  _skipGeoSelectionPageSyncCalls = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
		    var i, zip, item, debug;
		    return regeneratorRuntime.wrap(function _callee$(_context) {
		      while (1) {
		        switch (_context.prev = _context.next) {
		          case 0:
		            if (!($state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) && $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPassSyncCalls && $state.params.useNewBypassMethod)) {
		              _context.next = 60;
		              break;
		            }

		            ProviderSearchCriteriaService.setDistance($scope.criteria.distance);
		            year = $state.params.year;
		            category = $state.params.category;
		            index = -1;

		            if (!(year && category && (category == 'i' || category == 'I' || category == 'G' || category == 'g'))) {
		              _context.next = 25;
		              break;
		            }

		            i = 0;

		          case 7:
		            if (!(i < $scope.years.length)) {
		              _context.next = 18;
		              break;
		            }

		            if (!(year == $scope.years[i])) {
		              _context.next = 15;
		              break;
		            }

		            index = i; //$scope.selectedPlan(year,category,index);

		            $scope.selectedIndex = index;
		            PlanListService.selectedPlan(year, category, index);
		            $scope.isShowCounty = PlanListService.getShowCounty();
		            $scope.slider.value = 25;
		            return _context.abrupt("break", 18);

		          case 15:
		            i++;
		            _context.next = 7;
		            break;

		          case 18:
		            if (!(index == -1)) {
		              _context.next = 23;
		              break;
		            }

		            $scope.count = 0;
		            $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		            $state.go('contentPage', {
		              page: 'providerSearchLanding',
		              site_id: siteId,
		              language: language,
		              year: $state.params.year,
		              category: $state.params.category,
		              ZipCode: $state.params.ZipCode,
		              useNewBypassMethod: ''
		            },{location: 'replace'});
		            return _context.abrupt("return", -1);

		          case 23:
		            _context.next = 29;
		            break;

		          case 25:
		            $scope.count = 0;
		            $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		            $state.go('contentPage', {
		              page: 'providerSearchLanding',
		              site_id: siteId,
		              language: language,
		              year: $state.params.year,
		              category: $state.params.category,
		              ZipCode: $state.params.ZipCode,
		              useNewBypassMethod: ''
		            },{location: 'replace'});
		            return _context.abrupt("return", -1);

		          case 29:
		            zip = $state.params.ZipCode + '';

		            if (!(zip.indexOf('.') > -1)) {
		              _context.next = 36;
		              break;
		            }

		            NavSpinnerService.stop();
		            $scope.count = 0;
		            $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		            $state.go('contentPage', {
		              page: 'providerSearchLanding',
		              site_id: siteId,
		              language: language,
		              year: $state.params.year,
		              category: $state.params.category,
		              ZipCode: $state.params.ZipCode,
		              useNewBypassMethod: ''
		            },{location: 'replace'});
		            return _context.abrupt("return", -1);

		          case 36:
		            if (!(zip.length == 1)) {
		              _context.next = 43;
		              break;
		            }

		            document.getElementById("medZip").value = $state.params.ZipCode;
		            NavSpinnerService.stop();
		            $scope.count = 0;
		            $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		            $state.go('contentPage', {
		              page: 'providerSearchLanding',
		              site_id: siteId,
		              language: language,
		              year: $state.params.year,
		              category: $state.params.category,
		              ZipCode: $state.params.ZipCode,
		              useNewBypassMethod: ''
		            },{location: 'replace'}); //NavSpinnerService.stop();

		            return _context.abrupt("return", -1);

		          case 43:
		            $scope.isFirstRunForLandingPageByPassSyncCalls = false;
		            NavSpinnerService.spin();
		            _context.next = 47;
		            return ProviderSearchCriteriaService.getTypeAheadLocationInfo($state.params.ZipCode).then( //ProviderSearchCriteriaService.getTypeAheadLocationInfo($state.params.ZipCode).then(
		            function success(result) {
		              typeAheadResults = result;
		              $scope.areTypeAheadResultsReturned = $scope.criteria.medicare.areTypeAheadResultsReturned;

		              if (typeAheadResults && typeAheadResults.length == 1 && typeAheadResults[0] && typeAheadResults[0].zipcode && typeAheadResults[0].zipcode == $state.params.ZipCode) {
		                item = typeAheadResults[0];
		                $scope.criteria.medicare.planTypeaHeadLocation = item;
		              } else {
		                NavSpinnerService.stop();
		                $scope.count = 0;
		                $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		                $state.go('contentPage', {
		                  page: 'providerSearchLanding',
		                  site_id: siteId,
		                  language: language,
		                  year: $state.params.year,
		                  category: $state.params.category,
		                  ZipCode: $state.params.ZipCode,
		                  useNewBypassMethod: ''
		                },{location: 'replace'});
		                NavSpinnerService.stop();
		                return -1;
		              }
		            }, function error() {
		              NavSpinnerService.stop();
		            });

		          case 47:
		            if (!(typeAheadResults && typeAheadResults.length == 1 && typeAheadResults[0] && typeAheadResults[0].zipcode && typeAheadResults[0].zipcode == $state.params.ZipCode)) {
		              _context.next = 60;
		              break;
		            }

		            debug = $state.params.debug;
		            $scope.isLocationError = false;
		            $scope.isCountyError = false;
		            ProviderSearchCriteriaService.setTypeAheadForLocation(item);
		            $scope.slider.options.disabled = item.subcategory === 'county' || item.subcategory === 'state';
		            $rootScope.$broadcast('rzSliderForceRender');
		            $scope.criteria.typeAheadLocation = $scope.criteria.medicare.planTypeaHeadLocation;
		            justSelectedLocationFlag = true;

		            if (!(item.subcategory !== 'county')) {
		              _context.next = 59;
		              break;
		            }

		            _context.next = 59;
		            return ProviderSearchCriteriaService.getCounties(item, debug).then(function success(result) {
		              if (result.CountyList && result.CountyList.counties && result.CountyList.counties.county) {
		                for (var i = 0; i < result.CountyList.counties.county.length; i++) {
		                  $scope.counties = result.CountyList.counties.county;

		                  if ($scope.counties.length == 1) {
		                    $scope.county = $scope.counties[0];
		                  }
		                }

		                if ($scope.counties.length > 1) {
		                  $scope.isCountyError = true;
		                  NavSpinnerService.stop();
		                  $scope.count = 0;
		                  $state.params.useNewBypassMethod = false; //$scope.skipLandingPage();

		                  $state.go('contentPage', {
		                    page: 'providerSearchLanding',
		                    site_id: siteId,
		                    language: language,
		                    year: $state.params.year,
		                    category: $state.params.category,
		                    ZipCode: $state.params.ZipCode,
		                    useNewBypassMethod: ''
		                  },
				{location: 'replace'});
		                  NavSpinnerService.stop();
		                  return -1;
		                }
		              }

		              $scope.isShowCounty = true;

		              if ($scope.counties.length == 1) {
		                ProviderSearchCriteriaService.setDistance($scope.slider.value);

		                if ($scope.counties != '' && $scope.counties.length > 0 || $scope.county != null && $scope.county != "") {
		                  if ($sessionStorage.criteria == undefined) {
		                    $sessionStorage.criteria = $scope.criteria;
		                  }

		                  if ($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined) {
		                    $scope.criteria.typeAheadLocationResults = $scope.criteria.medicare.planTypeaHeadLocation;
		                  }

		                  if ($scope.county != null && $scope.county != "") {
		                    $scope.criteria.medicare.county = $scope.county.name;
		                    $scope.criteria.medicare.state = $scope.county.stateAbbr;
		                  } else {
		                    $scope.isCountyError = true;
		                    return $scope.isCountyError;
		                  }

		                  $scope.criteria.dummyPlanCode = '';
		                  $scope.criteria.planName = '';
		                  $scope.criteria.planProductCode = '';
		                  $scope.listOfPlans = '';
		                } else if ($scope.criteria.medicare.planTypeaHeadLocation && typeAheadResults && typeAheadResults.length == 0) $scope.areTypeAheadResultsReturned = false;else $scope.isLocationError = true;
		              }

		              {}
		              NavSpinnerService.stop();
		            }, function error() {
		              NavSpinnerService.stop();
		            });

		          case 59:
		            if ($scope.counties.length == 1) {
		              NavSpinnerService.spin();
		              PlanListService.getPlanList().then(function success(response) {
		                $scope.planList = response.data.DocfindSearchPlanList.plans;
		                var planList = response.data.DocfindSearchPlanList.plans;
		                var planArrList = PlanListService.setPlansArr(planList);
		                $scope.planCriteria.planArray = planArrList;
		                var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

		                if (processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined) {
		                  processDebugInfo = processDebugInfo.values.value;
		                } else {
		                  for (var tempI = 0; tempI < processDebugInfo.length; tempI++) {
		                    if (processDebugInfo[tempI].name == "DiagnosticInfo") {
		                      processDebugInfo = processDebugInfo[tempI].values.value;
		                      break;
		                    }
		                  }
		                }

		                $scope.planCriteria.planDebugInfo = processDebugInfo;

		                if (planArrList.length > 1) {
		                  $scope.criteria.isSinglePlan = false;
		                  ProviderSearchCriteriaService.setIsSinglePlan(false);
		                } else {
		                  $scope.criteria.isSinglePlan = true;
		                  ProviderSearchCriteriaService.setIsSinglePlan(true);
		                }

		                {
		                  ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
		                  $state.go('contentPage', {
		                    page: 'providerSearchPlanList',
		                    site_id: siteId,
		                    language: language,
		                    year: '',
		                    category: '',
		                    ZipCode: '',
		                    useNewBypassMethod: ''
		                  },
				{location: 'replace'});
		                }
		                NavSpinnerService.stop();
		              }, function error(response) {
		                console.log("Error in fetching Plans :  ");
		                console.log(response);
		                NavSpinnerService.stop();
		                $scope.planCriteria.planArray = 'ERROR';
		                $scope.planCriteria.planDebugInfo = [];
		                $scope.criteria.planValFromURL = ''; //$state.go('contentPage',{page:'providerSearchPlanList'});

		                if (data && data == 'skipPlans') {} else {
		                  var siteId = $scope.criteria.siteId;
		                  var language = $scope.criteria.language;
		                  $state.go('contentPage', {
		                    page: 'providerSearchPlanList',
		                    siteId: siteId,
		                    language: language,
		                    year: '',
		                    category: '',
		                    ZipCode: '',
		                    useNewBypassMethod: ''
		                  });
		                }
		              });
		            }

		          case 60:
		          case "end":
		            return _context.stop();
		        }
		      }
		    }, _callee);
		  }));
		  return _skipGeoSelectionPageSyncCalls.apply(this, arguments);
		}

		;


		    function fetchPlans(data){
				NavSpinnerService.spin();

				PlanListService.getPlanList()
				.then(
						function success(response){

							$scope.planList = response.data.DocfindSearchPlanList.plans;
							var planList = response.data.DocfindSearchPlanList.plans;
							var planArrList = PlanListService.setPlansArr(planList);
							$scope.planCriteria.planArray = planArrList;

							var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;
							if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
								processDebugInfo = processDebugInfo.values.value;
							}else{
								for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
									if(processDebugInfo[tempI].name == "DiagnosticInfo"){
										processDebugInfo = processDebugInfo[tempI].values.value;
										break;
									}
								}
							}
							$scope.planCriteria.planDebugInfo = processDebugInfo;

							if(planArrList.length > 1){
								$scope.criteria.isSinglePlan = false;
								ProviderSearchCriteriaService.setIsSinglePlan(false);
							}else{
								$scope.criteria.isSinglePlan = true;
								ProviderSearchCriteriaService.setIsSinglePlan(true);
							}
							if(data && data == 'skipPlans'){

							} else {
							ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
							$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language,
										year:'',category:'',ZipCode:''});
							}
							NavSpinnerService.stop();
						},
						function error(response){
							console.log("Error in fetching Plans :  ");
							console.log(response);
							NavSpinnerService.stop();
							$scope.planCriteria.planArray = 'ERROR';
							$scope.planCriteria.planDebugInfo = [];
							$scope.criteria.planValFromURL = '';
							//$state.go('contentPage',{page:'providerSearchPlanList'});
							if(data && data == 'skipPlans'){

							} else {
							var siteId = $scope.criteria.siteId;
							var language = $scope.criteria.language;
							$state.go('contentPage',{page:'providerSearchPlanList',siteId:siteId,language:language,
										 year:'',category:'',ZipCode:''});
						   }
						}
				);

			}
			$scope.continueToPLanSelection = function (){
				ProviderSearchCriteriaService.setDistance($scope.slider.value);
				if(($scope.counties!='' && $scope.counties.length>0) || ($scope.county!=null && $scope.county!="")) {
					//Set sessionStorage.criteria id not already set*/
					if($sessionStorage.criteria == undefined)
					{
						$sessionStorage.criteria = $scope.criteria;

					}
					/*Set default value of typeahead to user entered location*/

					if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
						$scope.criteria.typeAheadLocationResults = $scope.criteria.medicare.planTypeaHeadLocation;
					}
					// Set county appropriately
					if($scope.county!=null && $scope.county!="")
					{
						$scope.criteria.medicare.county = $scope.county.name;
						$scope.criteria.medicare.state = $scope.county.stateAbbr;
					}
					else
						{
							$scope.isCountyError = true;
							return $scope.isCountyError;
						}

					$scope.criteria.dummyPlanCode = '';
					$scope.criteria.planName = '';
					$scope.criteria.planProductCode = '';
					$scope.listOfPlans = '';
					fetchPlans();
				}
				else if($scope.criteria.medicare.planTypeaHeadLocation && typeAheadResults && typeAheadResults.length == 0)
					$scope.areTypeAheadResultsReturned = false;
				else
					$scope.isLocationError = true;



			};

			$scope.disableErrorMessage = function()
			{
				$scope.isLocationError = false;
				$scope.isCountyError = false;
				$scope.isShowCounty = false;
				$scope.areTypeAheadResultsReturned = true;
			};
		
			if (window.location.href.indexOf("providerSearchLanding") !== -1 && 
					 $state.params.ZipCode && $state.params.ZipCode != '' && !isNaN($state.params.ZipCode) 
					   && $state.params.ZipCode >= 0 && $scope.isFirstRunForLandingPageByPassSyncCalls == undefined
					   && $state.params.useNewBypassMethod ) {
				$scope.bypassLandingPage();
				
			}

		}



	})();

},{}],6:[function(require,module,exports){
(function() {
	angular.module('nav-ui').controller('PlansListController', PlansListController);

	PlansListController.$inject = ['$scope','$state','$http','$rootScope','PlanListService','$sessionStorage',
	                               'NavSpinnerService','ProviderSearchCriteriaService','configuration', '$filter','$window','AnalyticsService','$filter','LanguageDataService','$timeout','$state'];

	function PlansListController($scope,$state,$http,$rootScope,PlanListService,$sessionStorage,
			NavSpinnerService, ProviderSearchCriteriaService,configuration, $filter, $window, AnalyticsService,$filter,LanguageDataService,$timeout,$state) {
		$rootScope.$on("destroyScope", function(){
			$scope.$destroy();
		});
		var selPlan = "";
		var fixedPlanName = "";
		var redirectUrl = "";
		var externalUrl = "";
		$scope.dynamicPlanLinks = [];
		var siteId = $scope.criteria.siteId;
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.planCriteria = ProviderSearchCriteriaService.getPlanCriteria();
		$scope.languageData = LanguageDataService.getLanguageData();
		$scope.isClickedOnPlanTile = false;
		var language = $scope.criteria.language;
		isPlanModalOpen = false;
		$scope.searchPlanInput = '';
		$scope.isSubPlanSelected=false;
		$scope.isSubTypeError = false;
		$scope.planListCollapsed = true;
		/* Initialising variables for Pleat */
		$scope.CountDisplay = 4;
		$scope.pleatMAPD = false;
		$scope.pleatMA = false;
		$scope.pleatPDP = false;
		$scope.pleatSkipPlan = false;
		$scope.showPlanDebbugger = false;
		$scope.isShowContextualText = true;
		$scope.isError = false;
		$scope.showUpperError=false;
		
		if($scope.criteria.planProductCode == ''){
			$scope.isPlanSelected = false;
			selPlan = "";
		}else{
			$scope.isPlanSelected = true;
			selPlan = $scope.criteria.dummyPlanCode;
		}
		
		for (var i in $scope.planCriteria.planArray) {
				$scope.planCriteria.planArray[i].collapseHeader=true;
		}
		
		//We dont need fromGeo and hence removing it. The call is already made on previous controller before sending it here 
		if(window.location.href.indexOf("providerSearchPlanList") > -1){

			if(($scope.criteria.medicare.isLangCode != $scope.criteria.language) || $scope.planCriteria.planArray == undefined || $scope.planCriteria.planArray == null || $scope.planCriteria.planArray == [] ||  $scope.planCriteria.planArray.length ==0){
				fetchPlans();
				$scope.criteria.medicare.isLangCode = $state.params.language;
			}
		}
		
		/*Contextual help text is showing based on devices...*/
		if(navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)){
						
					$scope.isShowContextualText = false;	
		} else {
			$scope.isShowContextualText = true;
		}
					
		
		if(window.location.href.indexOf("debug=true") > -1){
			$scope.showPlanDebbuggerSwitch=true; // Show debug Info
		}else if(window.location.href.indexOf("debug=false") > -1){
			$scope.showPlanDebbuggerSwitch=false; // DO NOT show debug Info
		}else {
			if(configuration.debugPlanInfo == "true"){ //config.json (prod : false and QA : true)
				$scope.showPlanDebbuggerSwitch=true; // Show debug Info
			} else{
				$scope.showPlanDebbuggerSwitch=false; // DO NOT show debug Info
			}
		}
		
		var onLoadVar = 0;
		$scope.showDebugger = function(){
		   	if($scope.planCriteria.planDebugInfo){
				$scope.showPlanDebbugger = !$scope.showPlanDebbugger;
			}
		};
		
		$scope.goToProductType = function(mode, count) {
			if(count && count!=0){
			switch(mode) {
			case 1:
				$timeout(function() {
					$('#main-div #mapdTile').addClass('active in animate-linear');
					$('#main-div #mapdTile').addClass('active');
                    $('#mapdTileDiv').attr('aria-selected','true');                                                    
					$('#main-div #maTile,#main-div #pdpTile').removeClass('active');
					$('#maTileDiv,#pddTileDiv').attr('aria-selected','false');
					var tileLeft = parseInt($('#mapdTileDiv').offset().left);
					var tileWidth = parseInt($('#mapdTileDiv').width());
					var tileMargin = parseInt($('#mapdTile').css('margin-left'));
					var positionTile = (tileLeft + (tileWidth/2));
					if($(window).width() > 420) {
                        $('.downArrowIndicator').animate({left:positionTile},1000);
                    }
				},500);
				$scope.pleatMAPD = true;
				$scope.pleatMA = false;
				$scope.pleatPDP = false;
				$scope.pleatSkipPlan = false;
				if(!$scope.$$phase) {
					$scope.$apply();
				}
				break;
			case 2:
				$timeout(function() {
					$('#main-div #maTile').addClass('active in animate-linear');
					$('#main-div #maTile').addClass('active');
					$('#maTileDiv').attr('aria-selected','true');  
					$('#main-div #mapdTile,#main-div #pdpTile').removeClass('active');
					$('#mapdTileDiv,#pdpTileDiv').attr('aria-selected','false');
					var tileLeft = parseInt($('#maTileDiv').offset().left);
					var tileWidth = parseInt($('#maTileDiv').width());
					var tileMargin = parseInt($('#maTile').css('margin-left'));
					var positionTile = (tileLeft + (tileWidth/2));
					if($(window).width() > 420) {
                        $('.downArrowIndicator').animate({left:positionTile},1000);
                    }
				},500);
				/*if($('#main-div').find('div').hasClass('arrow-up'+Position)) {
					$('#main-div').removeClass('arrow-up'+Position);
				}
				$('#main-div #'+DispalyArr[mode-1]).removeClass('arrow-up'+(mode-1)).addClass('arrow-up'+Position);
				*/
				onLoadVar++;
				$scope.pleatMAPD = false;
				$scope.pleatMA = true;
				$scope.pleatPDP = false;
				$scope.pleatSkipPlan = false;
				if(!$scope.$$phase) {
					$scope.$apply();
				}
				break;
			case 3:
				$timeout(function() {
					$('#main-div #pdpTile').addClass('active in');
					$('#main-div #pdpTile').addClass('active');
					$('#pdpTileDiv').attr('aria-selected','true');
					$('#main-div #mapdTile,#main-div #maTile').removeClass('active');
					$('#mapdTileDiv,#maTileDiv').attr('aria-selected','false');
					var tileLeft = parseInt($('#pdpTileDiv').offset().left);
					var tileWidth = parseInt($('#pdpTileDiv').width());
					var tileMargin = parseInt($('#pdpTile').css('margin-left'));
					var positionTile = (tileLeft + (tileWidth/2));
					if($(window).width() > 420) {
                        $('.downArrowIndicator').animate({left:positionTile},1000);
                    }
				},500);
				/*if($('#main-div').find('div').hasClass('arrow-up'+Position)) {
					$('#main-div').removeClass('arrow-up'+Position);
				}
				$('#main-div #'+DispalyArr[mode-1]).removeClass('arrow-up'+(mode-1)).addClass('arrow-up'+Position);
				*/
				$scope.pleatMAPD = false;
				$scope.pleatMA = false;
				$scope.pleatPDP = true;
				$scope.pleatSkipPlan = false;
				onLoadVar++;
				if(!$scope.$$phase) {
					$scope.$apply();
				}
				break;
			}
			if($(this).parent('li').hasClass('active')){
                $(this).attr('aria-selected','true');                                                    
                 }else{
                $(this).attr('aria-selected','false');                                                   
              }	
			}			  
		};
		
		
		$scope.setPlan = function(selectedPlan, pId){
			$scope.isSubTypeError = false;
			$scope.isError = false;
			$scope.showUpperError=false;
			$scope.checkedPlanCode = pId;
			fixedPlanName = selectedPlan;
			$scope.criteria.medicare.fixedPlanName = selectedPlan;
			$scope.isSubPlanSelected=false;
			if(selectedPlan.planType && selectedPlan.planType == 'B'){
				// ACNLA5_0401 Changes Start
				$scope.dynamicPlanLinks = [];
				// ACNLA5_0401 Changes End
				for(var i =0; i<selectedPlan.link.length; i++){
					var dynObj = {};
					dynObj.externalUrl = selectedPlan.link[i].externalUrl;
					dynObj.redirectUrl = selectedPlan.link[i].redirectUrl;
					$scope.dynamicPlanLinks.push(dynObj);
					$scope.isPlanSelected = true;
				}
			} else{
				$scope.dynamicPlanLinks = [];
				redirectUrl = selectedPlan.redirectUrl;
			
				externalUrl = selectedPlan.externalUrl;
				$scope.isPlanSelected = true;
				$scope.isSubTypeError = false;
			}
			selPlan = pId;
			$scope.criteria.medicare.medOrDen = -1;
		};

		$scope.selectedSubType = function(index){
			$scope.criteria.medicare.medOrDen = index;
			redirectUrl = $scope.dynamicPlanLinks[index].redirectUrl;
			externalUrl = $scope.dynamicPlanLinks[index].externalUrl;
			fixedPlanName.redirectUrl = redirectUrl;
			fixedPlanName.externalUrl = externalUrl;
			$scope.isPlanSelected = true;
			$scope.isSubPlanSelected=true;
			$scope.isSubTypeError = false;
		};
		
		if($scope.isPlanSelected)
		{
			var medOrDen = -1;
			if($scope.criteria.medicare.medOrDen>=0)
				medOrDen = $scope.criteria.medicare.medOrDen;
			$scope.setPlan($scope.criteria.medicare.fixedPlanName,selPlan);
			if(medOrDen>=0)
				$scope.selectedSubType(medOrDen);
		}
		
		function createdseWSURl()
		{
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;
			var dseWSUrl = configuration.dseWSUrlPlanList + "site_id="+siteId+"&language="+lang+"&";
			
			if(criteria.planValFromURL == null || criteria.planValFromURL == ''){

				/* Added for Medicare project */
				if($state.params.site_id == 'medicare')
				{
					//dseWSUrl = configuration.plansListURL;
					dseWSUrl = dseWSUrl + "year="+criteria.medicare.planYear;
					dseWSUrl = dseWSUrl + "&category="+criteria.medicare.category;
					dseWSUrl = dseWSUrl + "&county="+(criteria.medicare.county).toUpperCase();
					dseWSUrl = dseWSUrl + "&state="+criteria.medicare.state;
					//if(criteria.medicare.isDebug)
					{
						//dseWSUrl = dseWSUrl + "&debug=true";//+criteria.medicare.isDebug;
					}
				}
				/* End - Added for Medicare project */
				else if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
					dseWSUrl = dseWSUrl + "postalCode="+criteria.typeAheadLocationResults.zipcode;
				}else if(criteria.typeAheadLocationResults.stateabbr != '' && criteria.typeAheadLocationResults.stateabbr != undefined){
					dseWSUrl = dseWSUrl + "state="+criteria.typeAheadLocationResults.stateabbr;
				}
			}
			
			var returnValue = {
					key : "DSE.WS Service",
					type : "url",
					value : dseWSUrl
			};
			
			return returnValue;
		};
		
		function fetchPlans() {
			NavSpinnerService.spin();
			PlanListService.getPlanList()
			.then(
					function success(response){
						if($scope.criteria.planProductCode == ''){
							$scope.isPlanSelected = false;
							selPlan = "";
						}else{
							$scope.isPlanSelected = true;
							selPlan = $scope.criteria.dummyPlanCode;
						}

						ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;

						var planList = response.data.DocfindSearchPlanList.plans;
						$scope.planCriteria.planArray = PlanListService.setPlansArr(planList);
						var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

						if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
							processDebugInfo = processDebugInfo.values.value;
							
							if( response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value.length != undefined 
									&& response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value.length == 1 )
							{
								var dseWSURL = createdseWSURl();
								processDebugInfo = [dseWSURL];
							}
							
						}else{
							
							var disagnosticInfoFound = false;
							for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
								if(processDebugInfo[tempI].name == "DiagnosticInfo"){
									processDebugInfo = processDebugInfo[tempI].values.value;
									
									disagnosticInfoFound = true;
									break;
								}
							}
							
							if( !disagnosticInfoFound )
							{
								var dseWSURL = createdseWSURl();
								processDebugInfo = [dseWSURL];
							}
						}
						$scope.planCriteria.planDebugInfo = processDebugInfo;
						if($scope.planCriteria.planArray && $scope.planCriteria.planArray.length != 0){
						for (var i in $scope.planCriteria.planArray) {
							$scope.planCriteria.planArray[i].collapseHeader=true;
						}
						}
						//$scope.showPlansInGeo();

						NavSpinnerService.stop();
					},
					function error(response){
						$scope.planCriteria.planArray = 'ERROR';
						$scope.planCriteria.planDebugInfo = [];
						NavSpinnerService.stop();
					}
			);
		};

		/*Getting sub header plans*/
		$scope.subHeaderPlans = function(plans){
			// If there is no subheader or plans 
			if(plans[0].subHeaderName!=null)
			{
				if(!angular.isArray(plans.subHeaderName))
					plans.subHeaderName = [plans.subHeaderName];
				$scope.subPlansList = plans;
				$scope.isClickedOnPlanTile = true;
				
				//Reset any selected plans the user as clicked on a tile. 
				$scope.isPlanSelected = false;
				selPlan = "";							
				fixedPlanName = "";
				$scope.criteria.medicare.fixedPlanName = "";
				$scope.isSubTypeError = false;
				$scope.checkedPlanCode = "";
				$scope.isError = false;
				$scope.showUpperError=false;
			}
		};

		$scope.continueWithPlan= function(button){
			if($scope.isPlanSelected)
			{
				if(fixedPlanName !='' && (fixedPlanName.planType != undefined && (fixedPlanName.planType == 'B' && $scope.isSubPlanSelected ) || (fixedPlanName.planType != 'B' && $scope.isPlanSelected)))
				{
					//$scope.isSubPlanSelected=false;
					var isInformationalPage = false;
					var newRedirectURL = '';
					$scope.planListCollapsed = true;
					$scope.isSubTypeError = false;
					AnalyticsService.trackForm({
						name: 'plan selection',
						plan:fixedPlanName.displayName,
						productCode:fixedPlanName.productCode,
						pipeName: fixedPlanName.pipeName,
						site_id: siteId,
						searchBoxTerm: $scope.searchPlanInput,
						state: 'completed'
					});
					if(fixedPlanName.redirectUrl != null && fixedPlanName.redirectUrl != '' && fixedPlanName.redirectUrl != 'N'){

						if(fixedPlanName.redirectUrl.contains("<INFO>_")){
							isInformationalPage = true;
							newRedirectURL = fixedPlanName.redirectUrl;

							fixedPlanName.redirectUrl = newRedirectURL;
						}
						else {
							isInformationalPage = false;
						}
						if(fixedPlanName.externalUrl != null && fixedPlanName.externalUrl === 'Y'){
							showDisclaimer(fixedPlanName.redirectUrl);
							//showDisclaimer($scope.redirectUrl,'standard',null)
						}
						else{

							$window.open(fixedPlanName.redirectUrl, "_blank");

							//$window.open($scope.fixedPlanName.redirectUrl, "_blank");
							//ProviderResultsService.openURL($scope.redirectUrl);
						}
					}

					/*var isIE = detectIE();

			if( isIE )
			{
				$scope.$apply();
			}*/

					if(fixedPlanName.redirectUrl != null && fixedPlanName.redirectUrl != '' && !isInformationalPage && fixedPlanName.redirectUrl != 'N'){
						//do nothing

					}
					else {

						if(fixedPlanName.displayName != '' && fixedPlanName.displayName != undefined){
							ProviderSearchCriteriaService.setPlanProductCode(fixedPlanName.productCode);
							ProviderSearchCriteriaService.setPlanPipeName(fixedPlanName.pipeName);
							ProviderSearchCriteriaService.setPlanName(fixedPlanName.displayName);

							/* Plan selected but still does not show up on UI fix :
							 * Although the ProviderSearchCriteriaService criteria object is set above, the UI need $scope.criteria and
							 * $sessionStorage.criteria for various flows and purpose due to the way these variables have been used.
							 * Also ProviderSearchCriteriaService.setCriteria(); was added to update the $sessionStorage.criteria
							 * BUt the ProviderSearchCriteriaService.criteria does not get updated in IE causing issues.
							 * Spo explicitly setting both  $scope.criteria and $sessionStorage.criteria below. */
							$scope.criteria.planProductCode = fixedPlanName.productCode;
							$scope.criteria.planName = fixedPlanName.displayName;
							$scope.criteria.planPipeName = fixedPlanName.pipeName;
							$scope.criteria.pinDisplay = fixedPlanName.pinDisplay;
							/*$sessionStorage.criteria.planProductCode = fixedPlanName.productCode;
					$sessionStorage.criteria.planName = fixedPlanName.displayName;
					$sessionStorage.criteria.planPipeName = fixedPlanName.pipeName;*/
							// console.log("2 . ProviderSearchCriteriaService.getPlanName()" + ProviderSearchCriteriaService.getPlanName() +
							// 		" fixedPlanName.displayName " + fixedPlanName.displayName);

							/*console.log($scope.fixedPlanName.productCode + " Continue with Plan " + JSON.stringify(ProviderSearchCriteriaService.getCriteria()));*/

							/* Commenting for now since the variable $sessionStorage.criteria gets update above. */
							//ProviderSearchCriteriaService.setCriteria();

							// console.log(" SessionStorage " + $sessionStorage.criteria.planProductCode
							// 		+ "   " + JSON.stringify($sessionStorage.criteria.planName)
							// 		);
							/* End : Plan selected but still does not show up on UI fix */
						}
						$scope.criteria.dummyPlanCode = selPlan;
						$scope.checkedPlanCode = selPlan;

						//if(!isPlanModalOpen){
						$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
						// $state.go('provSearch');
						/*}else{
					isPlanModalOpen = false;
					if(window.location.href.indexOf("providerDetails") > -1 ||
							window.location.href.indexOf("providerHospDetails") > -1 ||
							window.location.href.indexOf("providerOrgDetails") > -1){
						$state.go('contentPage',{"page":'providerResults',site_id:siteId,language:language});
					}
				}*/
					}
				}
			
			else
			{
				$scope.isSubTypeError = true;
			}
			}
			else{
				if(button=='upperButton'){
					$scope.showUpperError=true;
					$scope.isError = false;
				}
				else {
					$scope.showUpperError=false;
				    $scope.isError = true;
				}
			}
		};

		function showDisclaimer(url){
			var disclaimerUrl = $state.href('disclaimerPage', {page: 'standardDisclaimer', storeURL: url,language:language});
			window.open(disclaimerUrl, '_blank');
		}
		$scope.translateLongDesc = function(index){
			return (document.getElementById('longDesc-' + index).innerText);
			
		}; 

		$scope.skipPlanSelect= function(){
			$scope.criteria.planValFromURL = '';
			$scope.criteria.dummyPlanCode = '';
			$scope.checkedPlanCode = '';
			selPlan = "";
			$scope.isPlanSelected = false;
			ProviderSearchCriteriaService.setPlanProductCode(selPlan);
			ProviderSearchCriteriaService.setPlanPipeName('');
			ProviderSearchCriteriaService.setPlanName("No plan chosen | ");

			/* Setting values in $sessionStorage to avoid sporadic IE issues */
			$scope.criteria.planProductCode = selPlan;
			$scope.criteria.planPipeName = '';
			$scope.criteria.planName =  "No plan chosen | ";
			$scope.criteria.pinDisplay="N";

			/*$sessionStorage.criteria.planProductCode = selPlan;
			$sessionStorage.criteria.planPipeName = '';
			$sessionStorage.criteria.planName = "No plan chosen | ";
			/* Setting values in $sessionStorage to avoid sporadic IE issues - End */

			/*console.log( "Session  :" + $sessionStorage.criteria.planProductCode + "  " +
					+ $sessionStorage.criteria.planPipeName + "   "  +
					+ $sessionStorage.criteria.planName + "   " );

			console.log( "service  :" + $scope.criteria.planProductCode + "  " +
					+ $scope.criteria.planPipeName + "   "  +
					+ $scope.criteria.planName + "   " );*/

			//if(!isPlanModalOpen){
			$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
			//}
			if(window.location.href.indexOf("providerResults") > -1){
				$scope.criteria=ProviderSearchCriteriaService.getCriteria();
				$rootScope.planChangeClick(true,"skip");
			}
		};
		
		$scope.expandOrCollapse = function()
		{
			$scope.isError = false; 
			$scope.showUpperError=false;
			//value[0].collapseHeader = !value[0].collapseHeader
		}



	}

})();

},{}],7:[function(require,module,exports){
(function() {
    angular
      .module('nav-ui')
      .controller('newMenuController', newMenuController);

    newMenuController.$inject = ['$scope', '$rootScope', '$compile', 'ContentResultsService', 'PageBuilderService', '$state', 'AnalyticsService', '$sessionStorage', '$timeout', 'ContentIdListService','$location','ProviderSearchCriteriaService','CommonUtilsService','LanguageDataService'];

    function newMenuController($scope, $rootScope, $compile, ContentResultsService, PageBuilderService, $state, AnalyticsService, $sessionStorage, $timeout, ContentIdListService,$location,ProviderSearchCriteriaService,CommonUtilsService,LanguageDataService) {
        var ctrl = this;
        $scope.breadCrums = [];
        // $('.unbindRedundantClick').unbind('click');
        $('.unbindRedundantClick').off('click');
        ctrl.showMenu = showMenu;
        ctrl.message = {};
        ctrl.message.text = '';
        var myArray = [];
        var siteIdInUrl = $state.params.site_id;
        var langInUrl = $state.params.language;
		if (langInUrl == null || langInUrl == undefined || langInUrl !== "es") {
			langInUrl = "en";
		}
        if(siteIdInUrl == undefined){
        	siteIdInUrl = "dse";
        }
        if(langInUrl  == undefined){
          langInUrl = "en";
        }
        showMenu();
        function showMenu() {

            var contentId = 'navigation';
            var contentType = 'biz';
            var contentLang = '';

            ContentResultsService.getContent(contentId, contentType, contentLang)
                .then(

                    function success(result) {
                        // promise was fullfilled (regardless of outcome)
                        // checks for information will be peformed here
                        PageBuilderService.buildPage(result);

                        //$scope.pageTitleActivity();
                    },
                    function error(errorMsg) {
                        // handle errors here
                        ctrl.message.text = errorMsg.statusText;
                    }
                );
        }
        //Menu functions
        var menuClassArray = {
            'canbActive': 0
        };

        //New array for meu title active color
		var menuClassArrayForMapping =
		  [{
			key: "Find Care"
		    ,value: "canbActive"
		   }];

        /* Change page title based on contentId starts */
        function titleTextChnage(className) {


            var parentDiv = $(this).parents('.aet-content-header');
            var child = angular.element(parentDiv.children()[0]);
            var grandchild = angular.element(child.children()[0]);
            var greatGrandChild1 = angular.element(grandchild.children()[0]);
            var greatGrandChild = angular.element(grandchild.children()[1]);

            //menu active color
            var targetul = angular.element(greatGrandChild1.children('ul'));
            angular.element(targetul.children('li').attr('class', 'col-xs-12 home_group pad0  ng-scope'));
            angular.element(targetul.children('li')).first().attr('class', 'inactive clearfix ng-scope');
            angular.element(targetul.children('li')).last().attr('class', 'col-xs-12 pad0 home-mobile-list ng-scope');

			//Managing color mapping for less menu items
				var menuItemsPlaceHolder=[];
				var menuItemsDynamicArray=[];
				var i=2;
				for (i=2;i<targetul.children('li').length;i++)
				{
					var anchorTag= angular.element(targetul.children()[i])
					//var anchorTitle=anchorTag[0].children[0].title;
			       //fix for IE related color coding
				   var anchorTitle = anchorTag[0].children[0].children[1].children[0].children[0].innerText;
					menuItemsPlaceHolder.push(anchorTitle);
				};

				for(var i=0;i<menuItemsPlaceHolder.length;i++)
				{
					menuClassArrayForMapping.forEach(function(entry) {
                          if(menuItemsPlaceHolder[i]==entry.key)
							menuItemsDynamicArray.push(entry.value);
                    });
				}

			var targetLi = angular.element(targetul.children('li')[(menuItemsDynamicArray.indexOf(className)+1)]);

			if(targetLi[0].innerText!= "Menu"){
				targetLi.addClass(className);
			}

            //display menu title and menu image
            angular.element('.aet-content-header').css('display', 'block');
            angular.element(greatGrandChild.children('h1').css('display', 'none'));
            angular.element(greatGrandChild.children('h1.' + className + 'Marker').css('display', 'block'));
            //secendy menu display
            var anchorGrandParentDiv = angular.element('.second-navigation');
            var anchorParentDiv = angular.element(anchorGrandParentDiv.children()[0]);
            angular.element(anchorParentDiv.children('a').css('display', 'none'));
            angular.element(anchorParentDiv.children('a.' + className + 'Marker').css('display', 'inline-block'));
			  //To Add Scroll Functionality
            $scope.DisplayScroll();

        }

        /* Change page title based on contentId end */

        /* hide the page title and title bar color starts */
        $scope.pageTitleForlogin = function() {

                angular.element('h1.canbActiveMarker, h1.blueActiveMarker, h1.purpleActiveMarker, h1.greenActiveMarker, h1.tealActiveMarker, a.canbActiveMarker, a.blueActiveMarker, a.purpleActiveMarker, a.greenActiveMarker, a.tealActiveMarker').css('display', 'none');

                angular.element('.aet-content-header').css('display', 'none');

                var targetlis = angular.element('ul.menu-list').children('li');

                angular.element(targetlis.attr('class', "col-xs-12 home_group pad0 ng-scope"));

                angular.element(targetlis).first().attr('class', "inactive clearfix ng-scope");
                angular.element(targetlis).last().attr('class', "col-xs-12 pad0 home-mobile-list ng-scope");

                //$sessionStorage.menuColor    =   '';
                $scope.menuColor = $sessionStorage.menuColor;

            }
            /* hide the page title and title bar color end */

        /* Change page title based on navkey starts */
        function changePageTitleUsingNavkey(pageTitle, className, imgUrl) {
            var parentDiv = $(this).parents('.aet-content-header');
            var child = angular.element(parentDiv.children()[0]);
            var grandchild = angular.element(child.children()[0]);
            var greatGrandChild1 = angular.element(grandchild.children()[0]);
            var greatGrandChild = angular.element(grandchild.children()[1]);
            angular.element(greatGrandChild.children('h1').css('display', 'none'));

            //menu active color
            var targetul = angular.element(greatGrandChild1.children('ul'));
            angular.element(targetul.children('li').attr('class', 'col-xs-12 home_group pad0  ng-scope'));
            angular.element(targetul.children('li')).first().attr('class', 'inactive clearfix ng-scope');
            angular.element(targetul.children('li')).last().attr('class', 'col-xs-12 pad0 home-mobile-list ng-scope');
            var targetLi = angular.element(targetul.children('li')[menuClassArray[className] + 1]);
            targetLi.addClass(className);

            angular.element('h1.commonMarker').html('');
            angular.element('h1.commonMarker').append('<img src="' + imgUrl + '" />');
            angular.element('h1.commonMarker').append(pageTitle);
            angular.element(greatGrandChild.children('h1').css('display', 'none'));
            angular.element('h1.commonMarker').css('display', 'block');
        }
        /* Change page title based on navkey end */

        /* Display secondary menu */
        $scope.secondaryMenuDisplay = function(className) {
            //secendy menu display
            var anchorGrandParentDiv = angular.element('.second-navigation');
            var anchorParentDiv = angular.element(anchorGrandParentDiv.children()[0]);
            angular.element(anchorParentDiv.children('a').css('display', 'none'));
            angular.element(anchorParentDiv.children('a.' + className + 'Marker').css('display', 'inline-block'));
        }

        /* menu change activity starts */
        $scope.pageTitleActivity = function() {

			$scope.DisplayScroll();

            // create breadCrums array to display bread Crums.
			var criteria = ProviderSearchCriteriaService.getCriteria();
    	var languageData = LanguageDataService.getLanguageData();

            myArray = $sessionStorage.breadcrumbArray;

            var newArray = [];
            if(myArray != undefined){
	            for(var i=0 ; i< myArray.length; i++)
	            {
	            	//Update language in the url
	            	if(myArray[i].url != undefined && myArray[i].url != ''){						
						if((myArray[i].url.indexOf("providerResults")  != -1)&&(myArray[i].url.indexOf("&brC=true")  == -1)){
							myArray[i].url = myArray[i].url+"&brC=true";
						}
	            		myArray[i].url = CommonUtilsService.replaceParamValInStringFromUrl(myArray[i].url, 'site_id', siteIdInUrl);
	            		myArray[i].url = CommonUtilsService.replaceParamValInStringFromUrl(myArray[i].url, 'language', langInUrl);
	            	}
	                if(myArray[i].navKey =='P1P1' && (criteria.isSinglePlan == true || languageData.SWITCH_SUPRESS_CHANGE_PLAN  == 'ON')){
	                	//dont push 'Select a plan' link since site is having single plan
	                }else{
	                	newArray.push(myArray[i]);
	                }
	            }
            }
            $scope.breadCrums = newArray;
            var contentId = "";
            var page = $state.params.page;
            if (page) {
				contentId = page;				
            } else {
                contentId = $state.params.contentId;
            }

            if (contentId != null && contentId != undefined) {
                //To hide the title menu bar and breadcrumb for Home page in both desktop and mobile
                if (contentId == 'homePageNew' ||contentId == 'homePageModified') {
                    angular.element('#aet-newMenu').hide();
                    angular.element('.second-navigation').hide();
                    angular.element('.breadcrumb_block').hide();
                    angular.element(angular.element('.menu-button').parent()).hide();
                } else {
                    $timeout(function() {
                        //angular.element('#aet-newMenu').show();
                        angular.element('.second-navigation').show();
						angular.element('.breadcrumb_block').show();

                        angular.element(angular.element('.menu-button').parent()).show();


                        //Logic for click on primary or secondary menu
                        var pageTitleList = angular.element(document).find('.mobileClick');
                        var getLi = '',
                            mobiViewDiv = '',
                            mobiViewA = '';
                        angular.element('.subMenuMobiView').attr('class', 'ng-scope center-block pad0 col-xs-12 subMenuMobiView');
                        $.each(pageTitleList, function() {

                            //if(contentId=='findUrgentCare' || contentId=='providerSearch'){
                             //if (contentId == 'findUrgentCare' || contentId == 'providerSearch' ||  contentId =='providerMedical')

							 var showMenu = false;
							for(i=0;i<=ContentIdListService.findCareContentIdArray().length;i++)
							{
								if(contentId.indexOf(ContentIdListService.findCareContentIdArray()[i])!= undefined  && contentId.indexOf(ContentIdListService.findCareContentIdArray()[i])!= -1 )
										showMenu=true;
							}
							if(showMenu){
								if ($(this).attr('nvstyle') == 'canbActive') {

								    if (($sessionStorage.breadcrumbArrayLength != undefined && $sessionStorage.breadcrumbArrayLength > 1) && ($sessionStorage.pageTitle != undefined && $sessionStorage.pageTitle != '')) {
										changePageTitleUsingNavkey.call(this, $sessionStorage.pageTitle, 'canbActive', 'images/homeicons/findcare_icon_transparent.png');
										$sessionStorage.menuColor = 'canbpink-header';
										$scope.menuColor = $sessionStorage.menuColor;
										$scope.secondaryMenuDisplay('canbActive');
								    } else {
										titleTextChnage.call(this, 'canbActive');
										$sessionStorage.menuColor = 'canbpink-header';
										$scope.menuColor = $sessionStorage.menuColor;
								    }
									getLi = angular.element('li.canbActive');

								    mobiViewDiv = angular.element(getLi.children('div'));
								    mobiViewA = angular.element(mobiViewDiv.children('a'));

									var $secondaryMenus = angular.element('a.canbActiveMarker');
									angular.element('a.canbActiveMarker').attr('class', 'ng-scope canbActiveMarker sec-level-nav');
									angular.element('a.canbActiveMarker').attr('aria-selected', 'false');

								    $.each($secondaryMenus, function(key) {
								        //if($(this).html()=='Overview'){
										//Accesibilty fix to remove title from secondary menu tabs
										$(this).attr('title', '');
								        if (key == 0) {
								            $(this).attr('class', 'ng-scope canbActiveMarker borderLeftGrey sec-level-nav');
								            $(this).attr('aria-selected', 'false');
								        }
								        var $selectedElement = $(this).attr('href');
								        if ($(this).attr('href') && $(this).attr('href').indexOf(contentId) != -1) {
								            //if($(this).html()=='Overview'){
								            if (key == 0) {
								                $(this).attr('class', 'ng-scope canbActiveMarker borderLeftGrey sec-level-nav canbLevel');
								                $(this).attr('aria-selected', 'true');
								            } else {
								                $(this).attr('class', 'ng-scope canbActiveMarker sec-level-nav canbLevel');
								                $(this).attr('aria-selected', 'true');
								            }
								            mobiViewA[key].attributes['class'].nodeValue='ng-scope center-block pad0 col-xs-12 purpleActive subMenuMobiView';
								        }
										//Provider tab Active display-Start
										else{
										var CheckURL=window.location.href;
										var pattern = /provider/;
										var exists = pattern.test(CheckURL);
										if(exists)
										{
										  if($(this)[0].innerText=="Find a Provider"){
										     $(this).attr('class', 'ng-scope canbActiveMarker borderLeftGrey sec-level-nav canbLevel');
										    }
                                        }
										}
										//Provider tab Active display-End
								    });
								}
									$scope.DisplayScroll();
			                    }
								else if (ContentIdListService.OthersContentIdArray().indexOf(contentId)!= undefined && ContentIdListService.OthersContentIdArray().indexOf(contentId)!= -1)
								{
	                            	 $scope.pageTitleForlogin();
	                                 var parentDiv = $(this).parents('.aet-content-header');
	                                 var child = angular.element(parentDiv.children()[0]);
	                                 var grandchild = angular.element(child.children()[0]);
	                                 var greatGrandChild1 = angular.element(grandchild.children()[0]);
	                                 var greatGrandChild = angular.element(grandchild.children()[1]);
	                                 angular.element('.aet-content-header').css('display', 'block');
	                                 //display menu title and menu image
	                                 angular.element(greatGrandChild.children('h1').css('display', 'none'));
	                                 angular.element('h1.commonMarker').html(changePageTitleUsingNavkey.call(this, $sessionStorage.pageTitle, 'canbActive', 'images/homeicons/findcare_icon_transparent.png'));
	                                 $sessionStorage.menuColor = 'canbpink-header';
	                                 $scope.menuColor = $sessionStorage.menuColor;
	                                 angular.element(greatGrandChild.children('h1.commonMarker').css('display', 'block'));
								}
								else {
	                                /*if($(window).width() >= 768){
	                                    $scope.pageTitleForlogin();
	                                }*/
	                                $scope.pageTitleForlogin();
	                                var parentDiv = $(this).parents('.aet-content-header');
	                                var child = angular.element(parentDiv.children()[0]);
	                                var grandchild = angular.element(child.children()[0]);
	                                var greatGrandChild1 = angular.element(grandchild.children()[0]);
	                                var greatGrandChild = angular.element(grandchild.children()[1]);
	                                angular.element('.aet-content-header').css('display', 'block');
	                                //display menu title and menu image
	                                angular.element(greatGrandChild.children('h1').css('display', 'none'));
	                                if(undefined != parentDiv.context.baseURI && parentDiv.context.baseURI.indexOf("provider")>=0){
	                                	angular.element('h1.commonMarker').html(changePageTitleUsingNavkey.call(this, $sessionStorage.pageTitle, 'canbActive', 'images/homeicons/findcare_icon_transparent.png'));
	                                	$sessionStorage.menuColor = 'canbpink-header';
	                                }
	                                else{
	                                	angular.element('h1.commonMarker').html($sessionStorage.pageTitle);
	                                	$sessionStorage.menuColor = 'gryblue-header';
	                                }
	                                $scope.menuColor = $sessionStorage.menuColor;
	                                angular.element(greatGrandChild.children('h1.commonMarker').css('display', 'block'));
	                            }
								$scope.DisplayScroll();
                        });
                    });
                }
            } else {
                $scope.pageTitleForlogin();
            }
        }

        $rootScope.$on("CallParentMethod", function() {
            $scope.pageTitleActivity();
			 //$scope.DisplayScroll();

        });

        $rootScope.$on("CallLoginTitle", function() {
            $scope.pageTitleForlogin();
        });

        /* menu change activity end */

        $scope.menuButtonClick = function() {
            //console.log('direct fn');
        }
        angular.element(".menu-button").on('click', function() {
            //console.log('test');
            var pageHeight = $(document).height();
            $(".menu-list, .menu-overlay").fadeIn();
            $(".menu-overlay").css('height', pageHeight);
			//added to bring focus on menu text
		   $(".menu-txt").focus();
        });
        $(".close-menu").on('click', function() {
            $(".menu-list, .menu-overlay").fadeOut();
        });

        $(".mobileClick").on('click', function() {

        });

         //to bring focus on skip to main button
		 $(window).on('hashchange', function() {
		      $("#toHoldFocus").focus();
         });

		 //Touch Scroll Chevrons right left visibility-Start
		$('.container').on('scroll', function(e){

			 var secMenuItems= $(".second-navigation").children().find('a:visible');
			 var widthOfItem=0
			 for (var i=0;i<secMenuItems.length;i++)
				{
					widthOfItem = widthOfItem + secMenuItems[i].offsetWidth;
				};
			 var screenWidth= $(window).width();
			 var myPos = e.target.scrollLeft;
			 var overflowValue=widthOfItem-screenWidth;

			 if(myPos>0){
				 if(secMenuItems.length ==2){
				  $('.left-scrollarrow').css("visibility","visible");
			      $('.right-scrollarrow').css("visibility","hidden") ;
				 }
				else if(myPos >(overflowValue)){
			      $('.left-scrollarrow').css("visibility","visible");
			      $('.right-scrollarrow').css("visibility","hidden") ;
			    }
				else{
				  $('.left-scrollarrow').css("visibility","visible");
				  $('.right-scrollarrow').css("visibility","visible") ;
				}

			   }
			   else if(myPos==0){
				$('.left-scrollarrow').css("visibility","hidden");
			    $('.right-scrollarrow').css("visibility","visible");
			   }
			   else if(myPos==0 && overflowValue<=0){
				$('.left-scrollarrow').css("visibility","hidden");
			    $('.right-scrollarrow').css("visibility","hidden");
			  }

		})
	    //Touch Scroll Chevrons right left visibility-End
		$scope.DisplayScroll = function() {

			    var contentId = "";
			   var page = $state.params.page;
			   if (page) {
				contentId = page;
				} else {
			  contentId = $state.params.contentId;
			   }
			   //Hiding the scroll buttons when there is no overflow
			   var secMenuItems= $(".second-navigation").children().find('a:visible');
			   var widthOfItem=0
			   for (var i=0;i<secMenuItems.length;i++)
				{
					widthOfItem = widthOfItem + secMenuItems[i].offsetWidth;
				};

			   var screenWidth= $(window).width();
			   //var overflowValue=widthOfItem-screenWidth;
			   if(screenWidth >=widthOfItem){
				 $('.right-scrollarrow').css("visibility","hidden") ;
				$('.left-scrollarrow').css("visibility","hidden") ;
			   }

			   else{
				 $('.right-scrollarrow').css("visibility","visible") ;
				 $('.left-scrollarrow').css("visibility","hidden") ;
			   }

			  //Checking where not to display the secondary Scroll buttons
			   if(ContentIdListService.topChromeContentIdArray().indexOf(contentId)!= undefined && ContentIdListService.topChromeContentIdArray().indexOf(contentId)!= -1)
			                {
								$('.right-scrollarrow').css("visibility","hidden") ;
								$('.left-scrollarrow').css("visibility","hidden") ;
							}
							else{

		        //Secondary menu Scroll buttons
			     var aet_childrenWidth =  ($(".second-navigation").children().children().outerWidth())*($(".second-navigation").children().find('a:visible').length);

		        var aet_totalWindowWidth = $(window).width();
				var NoOfChild=($(".second-navigation").children().find('a:visible').length);
				var CheckURL=window.location.href;
				var pattern = /provider/;
				var exists = pattern.test(CheckURL);

				  $(".menu-list, .menu-overlay").fadeOut();

		        if(aet_childrenWidth > aet_totalWindowWidth){
				    if(NoOfChild >2){
						if(((ContentIdListService.firstTabSecondaryNavContentIdArray().indexOf(contentId)!= undefined) &&(ContentIdListService.firstTabSecondaryNavContentIdArray().indexOf(contentId)!= -1))|| exists==true ||((ContentIdListService.HealthProgramsInternalPageContentIdArray().indexOf(contentId)!= undefined) &&(ContentIdListService.HealthProgramsInternalPageContentIdArray().indexOf(contentId)!= -1))||((ContentIdListService.FinancialOverviewInternalPageContentIdArray().indexOf(contentId)!= undefined) && (ContentIdListService.FinancialOverviewInternalPageContentIdArray().indexOf(contentId)!= -1)))
						{
							$('.right-scrollarrow').css("visibility","visible");
							$('.left-scrollarrow').css("visibility","hidden");
							$(".container").scrollLeft(0);
						}
						else if(ContentIdListService.secondTabSecondaryNavContentIdArray().indexOf(contentId)!= undefined && ContentIdListService.secondTabSecondaryNavContentIdArray().indexOf(contentId)!= -1){
							$(".container").scrollLeft(140);
							$('.left-scrollarrow').css("visibility","visible");
                            $('.right-scrollarrow').css("visibility","visible")
						}
						else
						{
							$(".container").scrollLeft(aet_childrenWidth-120);
	                        $('.left-scrollarrow').css("visibility","visible");
                            $('.right-scrollarrow').css("visibility","hidden")
						}
					}

	            }
				else if(NoOfChild==3 && contentId !="wellnessHome"){
		          $('.right-scrollarrow').css("visibility","visible");
			     }
							}

		}

	 	angular.element('.right-scrollarrow').on('click', function(event) {
      		$(".container").animate({scrollLeft: '+=160'});
		});
		angular.element('.left-scrollarrow').on('click', function(event) {
			$(".container").animate({scrollLeft: '-=160'});
		});

	    }
})();

},{}],8:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.controller('PDFController', PDFController);

	PDFController.$inject = ['$scope', '$http', 'configuration' ,'PdfService','$state','NavSpinnerService','$log'];

	function PDFController($scope, $http, configuration, PdfService,$state,NavSpinnerService, $log) {
		//var ACOCode=localStorage.getItem('ACOCode');

		document.title =  "More Information";

		$scope.error = false;
		$scope.success=false;
		if($state.params.code!=null && $state.params.code!=undefined)
			code = $state.params.code;

		openPDF(code);

		function openPDF( category ) 
		{
			NavSpinnerService.spin();
			PdfService.openACOpdf( category )
			.then(
					function success(response) {
						if (response && response.data && response.data.ChannelACOMapping
								&& response.data.ChannelACOMapping.link
								&& response.data.ChannelACOMapping.link != '' ) {
							//window.location.href = response.data.ChannelACOMapping.link;
							$scope.error =false;

							$scope.pdfUrl =  response.data.ChannelACOMapping.link;

							/*var file = new Blob([(response)], {type: 'application/pdf'});
						     var fileURL = URL.createObjectURL(file);
						     $scope.content = $sce.trustAsResourceUrl(fileURL);*/
							NavSpinnerService.stop();
							$scope.success = true;

							//alert("Debug 3: " + response + response.data.ChannelACOMapping.link );
							var status = window.open(response.data.ChannelACOMapping.link,'_self');




							//setTimeout(scroll, 800);
							if( status != null )
								{
									//setTimeout(scroll, 5000);
									//alert( status.closed + "   " + window.location);
									if( window.location != response.data.ChannelACOMapping.link && status.closed)
									{
										//alert ("here");
										//window.close();
										//_acoPdf.close();
									}
								}


							/*var windowName='popup';
							var winOpts = 'width=900,height=600,scrollbars=yes,resizable=yes,toolbar=yes,overflow=scroll,location=yes,left=180,top=120';
							window.name='INDEX';
							window.open(URL,windowName,winOpts);*/

						} else {
							/*$log.error('There is no pdf info found in response');*/
							$scope.error =false;
						}
						NavSpinnerService.stop();
					},
					function error (errorMsg) {
						$log.error(errorMsg.statusText);
						NavSpinnerService.stop();
						$scope.error =false;
					}
			);
		};
	}

	angular
    .module('nav-ui')
        .directive('onLoadClicker', function ($timeout) {
            return {
                restrict: 'A',
                scope: {
                    index: '=index'
                },
                link: function($scope, iElm) {

                	angular.element(iElm).find('a')[0].click();
                    /*if ($scope.index == 0) {
                        $timeout(function() {

                            iElm.triggerHandler('click');

                        }, 0);
                    }*/
                }
            };
        });
})();

},{}],9:[function(require,module,exports){
(function() {
	angular
	.module('nav-ui')
	.controller('CompareController', CompareController);

	CompareController.$inject = ['$scope', '$http', 'configuration' ,'ProviderResultsService',
	'ProviderSearchCriteriaService','$q','$log','$filter','$state','$sessionStorage','usSpinnerService','$timeout',
	'$window','phoneFormatFilter','$rootScope',
	'NavSpinnerService','$translate', 'RatingsService', 'PdfService','AnalyticsService','mapsService',
	'CompareProviderService','$compile','LanguageDataService'];
	function CompareController($scope, $http, configuration, ProviderResultsService,
	 ProviderSearchCriteriaService,$q,$log,$filter,$state,$sessionStorage,usSpinnerService,$timeout,
	 $window,phoneFormatFilter,$rootScope,
	 NavSpinnerService,$translate, RatingsService,PdfService,AnalyticsService,mapsService,
	 CompareProviderService,$compile,LanguageDataService) {
				// $rootScope.$on("destroyScope", function(){
				//    $scope.$destroy();
				// });
		 		// Detecting IE Browser.
		 		function detectIE() {
		 		    var ua = window.navigator.userAgent;

		 		    var msie = ua.indexOf('MSIE ');
		 		    if (msie > 0) {
		 		        // IE 10 or older => return version number
		 		        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		 		    }

		 		    var trident = ua.indexOf('Trident/');
		 		    if (trident > 0) {
		 		        // IE 11 => return version number
		 		        var rv = ua.indexOf('rv:');
		 		        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		 		    }

		 		    var edge = ua.indexOf('Edge/');
		 		    if (edge > 0) {
		 		       // Edge (IE 12+) => return version number
		 		       return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
		 		    }

		 		    // other browser
		 		    return false;
		 		}
		 		 var isIE = detectIE();
		//console.log("In results controller : " + $scope.$id);

		/*var $tempLayoutID = angular.element(document.getElementById('comparePopUpInLayout'));
		$.get("components/publicProvider/compareDialogs.html", function(data){
				$tempLayoutID.append(data);
		}).done(function() {
				if($scope.ComparePopupCreated !== true){
					  var $comparePopupID = angular.element(document.getElementById('#comparePopUp'));
						$compile($tempLayoutID)($scope);
						return;
				}
		});*/




		// var $tempLayoutID = angular.element(document.getElementById('#comparePopUpInLayout'));
		// var $comparePopupID = angular.element(document.getElementById('#comparePopUp'));
		// $tempLayoutID.append($comparePopupID);
		// $compile($tempLayoutID)($scope);

		// var tempLayoutID=$element.parent().children('#skipPlan');
		// angular.element('.menu-list').append($element);
		// $compile(tempLayoutID)($scope);


		ProviderResultsService.scrollTo = '';
		ProviderSearchCriteriaService.setPlanPleatShow(false);
		$scope.showDebbugger=false;
		$scope.isPageReady=false;
		if (window.location.href.indexOf("providerResults") != -1){
			$( "#provider-srch" ).addClass( "dateFix" );
		}
		if (window.location.href.indexOf("providerResults") != -1){
			$( "#provider-Results-id" ).addClass( "dateFix2" );
		}
		$scope.providerRes = "";
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();

		$timeout(function() {
				$scope.languageData = LanguageDataService.getLanguageData();

				if($scope.languageData.SWITCH_DISPLAY_RIP == 'NONE'){
					$scope.reportIncorrectInfoLink=false;
				}else {
					$scope.reportIncorrectInfoLink=true;
				}
		},3000);


		/* This variable : $scope.criteria.searchFocus is used to dim the screen for small
		 * devices when typeahead is opened. Resetting the value here since if the user goes to
		 * LandingPage using Aetna logo from Results page without using start A new search button
		 * the value is true and plan list page is Dimmed. */
		$scope.criteria.searchFocus = false;

		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		// if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
		//  			return $state.go('contentPage',{page:'providerSearchLanding',parameters:'',site_id:siteId,language:language});
		// }
		// console.log("reset:"+$scope.criteria.isResetFilter);
		//$scope.criteria.direction = '';
		$scope.resultsService = ProviderResultsService;
		$scope.resultsService.resultSearch = 0;
		$scope.searchStatus = 'notSearching';
		$scope.sortOrder=($scope.criteria.isResetFilter && $scope.criteria.filterOrder) ? $scope.criteria.filterOrder : null;
		$scope.compareListArray=[];
		$scope.selectedFilters =($scope.criteria.isResetFilter && $scope.criteria.selectedFilters) ? $scope.criteria.selectedFilters : "";
		$scope.reportIncorrectInfo = configuration.reportIncorrectInfo;
		ProviderSearchCriteriaService.setOrder($scope.sortOrder);
		$scope.listSelections=($scope.criteria.isResetFilter && $scope.criteria.listSelections) ? $scope.criteria.listSelections : null;
		$scope.showPrintDirectory=false;
		ProviderSearchCriteriaService.setListSelection($scope.listSelections);
		$scope.errorCode = "";
		$scope.backendError=false;
		$scope.pinSearch=false;
		$scope.fromDetails=false;
		$scope.isShowSortFilterWindow=false;
		$scope.showFilterContent=($scope.criteria.isResetFilter && $scope.criteria.showFilterContent) ? $scope.criteria.showFilterContent:[];
		$scope.showSecLevelContent=($scope.criteria.isResetFilter && $scope.criteria.showSecLevelContent) ? $scope.criteria.showSecLevelContent:[];
		$scope.checkedItem=($scope.criteria.isResetFilter && $scope.criteria.checkedItem) ? $scope.criteria.checkedItem : [];
		$scope.checkedItemChildren=($scope.criteria.isResetFilter && $scope.criteria.checkedItemChildren) ? $scope.criteria.checkedItemChildren : [];
		$scope.checkedContentItem=[];
		$scope.showFirstLevel=true;
		$scope.checkedSecondLevelContentItem=[];
		$scope.isFirstNavigate = true;
		$scope.isArray = angular.isArray;
		$scope.printDirectoryURL = configuration.printDirectoryURL;
		$scope.filterResultsFocus=false;

		if($state.current.name.indexOf('provSearch')==-1)
			$scope.displayOR = false;
		else
			$scope.displayOR = true;


		$scope.resultsService = ProviderResultsService;
		$scope.compareListArray=[];
		var compareData = $scope.resultsService.compareData;
		compareData.showCompare = false;
		CompareProviderService.reset();

		function toArray(input)
		{
			if(input!= undefined){
				if (angular.isArray(input)) {
					return input;
				} else {
					return [input];
				}
			}

		};

		// toggle language between English and Spanish or use specified language
		$scope.changeLanguage = function(lang) {
			if (lang == null || lang == undefined) {
				var lang = $translate.use();
				lang = lang == 'en' ? 'es' : 'en';
			}
			// start over on the search page when switching languages
			// $state.go('contentPage',{page:'providerSearch',language:lang});
		};

		if($scope.criteria.findDocPrevId === null){
			ProviderResultsService.setFindDoctors("");
		}

	 if($state.params.hosId!=null && $state.params.hosId!=undefined && $state.params.hosId!=''){
	 					ProviderResultsService.setHospitalId($state.params.hosId);
						$scope.criteria.hospitalName = $state.params.hosName;
						$scope.criteria.hospitalId = $state.params.hosId;
						$scope.criteria.isProviderForHospital = true;
						$scope.criteria.isProviderForIPA = false;
						$scope.criteria.isProviderForGroup = false;
						$scope.criteria.isFindDoctor = false;
						$scope.criteria.findDocPrevId = null;
	 }
	 else
	 {
		 $scope.criteria.isProviderForHospital = false;
	 }

 	 if(($state.params.proOrgDispName!=null && $state.params.proOrgDispName!=undefined && $state.params.proOrgDispName!='') ||
			($state.params.proOrgName!=null && $state.params.proOrgName!=undefined && $state.params.proOrgName!='') ){
			 	if($state.params.poin != 'NA'){
				 		ProviderResultsService.setIpaDetails($state.params.poin);
				 		$scope.criteria.ipaName = $state.params.proOrgName;
				 		$scope.criteria.isProviderForIPA = true;
				 		$scope.criteria.isProviderForGroup = false;
				 		$scope.criteria.isProviderForHospital = false;
				 		$scope.criteria.isFindDoctor = false;
						$scope.criteria.findDocPrevId = null;
			 	}
			 	else{
			 		ProviderResultsService.setGroupdetails( $state.params.groupProId, $state.params.proOrgDispName, false );
			 		$rootScope.grpName = $state.params.proOrgDispName;
			 		$scope.criteria.isProviderForGroup = true;
			 		$scope.criteria.isProviderForIPA = false;
			 		$scope.criteria.isProviderForHospital = false;
			 		$scope.criteria.isFindDoctor = false;
					$scope.criteria.findDocPrevId = null;
			 	}
	 }else{
		 $scope.criteria.isProviderForGroup = false;
	 	 $scope.criteria.isProviderForIPA = false;

	 	ProviderResultsService.setIpaDetails("");
 		$scope.criteria.ipaName = "";
 		$rootScope.grpName = "";

	 }

		// set the classes to produce the stars for 10 levels of accuracy
		var starClassNames = ["neg","neg","posneg","posneg","posneg","posneg","posneg","posneg","pos","pos"];
		RatingsService.setStarClassNames(starClassNames);

		// expose ratings functionality
		$scope.ratingStatus = RatingsService.ratingStatus;
		$scope.getRating = RatingsService.getRating;
		$scope.getStarClass = RatingsService.getStarClass;
		$scope.getNumberOfRatings = RatingsService.getNumberOfRatings;

		$rootScope.changeShowDebbugger=function(){
			$scope.showDebbugger=!$scope.showDebbugger;
		}

		/* started report incorrect information functionality */
		$scope.publicMember = {};
		$scope.publicMember.firstName = '';
		$scope.publicMember.lastName = '';
		$scope.publicMember.email = '';

		$scope.statusBeg = $scope.criteria.isResetFilter ? $scope.criteria.statusBeg : true;
		console.log(" 1 : true : $scope.statusBeg" + $scope.statusBeg );
		$scope.statusLast = $scope.criteria.isResetFilter ? $scope.criteria.statusLast : false;
		$scope.criteria.isAlphaSort = $scope.criteria.isResetFilter ? $scope.criteria.isAlphaSort : false;
		$scope.defaultAlphabets = ['Num','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
		$scope.tempArray = $scope.criteria.isResetFilter ? ($scope.criteria.selectedListArray != undefined ? $scope.criteria.selectedListArray : []): [];
				//Report incorrect information object...
				$scope.reportInfo = {
						incAddress: false,
						incGender: false,
						incPhone: false,
						incSpeciality: false,
						incGroup: false,
						incDeceased: false,
						duplicateList: false,
						praLocation: false,
						noAccept: false,
						incindicates: false,
						incHospitalAff: false,
						incLanguage: false
					}
				$scope.reportIncorrectInfoData = function(data){
					$scope.currentProviderData = data;
					angular.element("#incorrectInfo" ).show();
					setTimeout(function(){ $rootScope.focusForModal('incorrectInfo'); }, 100);
					angular.element("#incorrectInfo" ).css("display","block");
					angular.element("#incorrectInfo" ).addClass("fadeIn");
					angular.element("#incorrectInfo" ).removeClass("fade");
					angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
					if(data){
							if(data.providerInformation){
									$scope.reportProviderId = data.providerInformation.providerID;
									 $scope.reportProviderName = data.providerInformation.providerDisplayName.full;
			 						 $scope.reportProviderPin = data.providerInformation.providerIdentifier.idValue;
			 						 $scope.reportProviderLocId = data.providerLocations.locationID;
			 						 $scope.reportProviderType = data.providerInformation.type;
									 if(data.providerLocations.address.streetLine1 != undefined){
				 	 						 $scope.reportProviderAddressLine1 = data.providerLocations.address.streetLine1;
									 }
									 if(data.providerLocations.address.streetLine2 != undefined){
				 	 						 $scope.reportProviderAddressLine2 = data.providerLocations.address.streetLine2;
									 }
									 if(data.providerLocations.address.streetLine3 != undefined){
				 	 						 $scope.reportProviderAddressLine3 = data.providerLocations.address.streetLine3;
									 }
			 						 $scope.reportProviderAddressCity = data.providerLocations.address.city;
			 						 $scope.reportProviderAddressState = data.providerLocations.address.state;
			 						 $scope.reportProviderAddressZip = data.providerLocations.address.postalCode;
			 						 $scope.reportProviderAddressPhone = data.contacts.primaryPhone.number;
									//  if($scope.reportProviderAddressState == 'CA'){
									// 			$scope.CAMsg = true;
									//  }else if($scope.reportProviderAddressState == 'GA'){
									 //
									//  }else if($scope.reportProviderAddressState == 'TX'){
									 //
									//  }
							}
					}

					if(($scope.RIPStateMessage && $scope.RIPMessageContent && data && data.providerData && data.providerData.providerAtLocation && data.providerData.providerAtLocation.officeContacts && data.providerData.providerAtLocation.officeContacts.postalAddresses && data.providerData.providerAtLocation.officeContacts.postalAddresses.state)){
						if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'CA'){
							if($scope.criteria.lang === 'en'){
								$scope.RIPTextMessage = $scope.RIPMessageContent.EN.CA;
							} else {
								 $scope.RIPTextMessage = $scope.RIPMessageContent.ES.CA;
							}
						} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'GA'){
							if($scope.criteria.lang === 'en'){
									$scope.RIPTextMessage = $scope.RIPMessageContent.EN.GA;
								} else {
									$scope.RIPTextMessage = $scope.RIPMessageContent.ES.GA;
							}
						} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'TX'){
							if($scope.criteria.lang === 'en'){
								$scope.RIPTextMessage = $scope.RIPMessageContent.EN.TX;
							} else {
									$scope.RIPTextMessage = $scope.RIPMessageContent.ES.TX;
							}
						}

					}
				};

				$scope.isSelectedCorrectedData = function(){
							if($scope.reportInfo.incAddress || $scope.reportInfo.incGender || $scope.reportInfo.incPhone || $scope.reportInfo.incSpeciality || $scope.reportInfo.incGroup || $scope.reportInfo.incDeceased || $scope.reportInfo.duplicateList || $scope.reportInfo.praLocation || $scope.reportInfo.noAccept || $scope.reportInfo.incindicates || $scope.reportInfo.incHospitalAff || $scope.reportInfo.incLanguage){
								return false;
							} else {
								return true;
							}
				};

				//Submit Incorrect Info
				this.submitInfo = function(){
					var url = ProviderResultsService.submitData(
							$scope.reportIncorrectInfo,$scope.currentProviderData, $scope.providerType,
							$scope.chkedOptions, false, $scope.publicMember);
					this.closeIncorrectInfo();
					$window.open(url, "_blank");


					/*.then(
							function success(response) {
								$scope.incorrectInfoSubmitted = true;
								$scope.incorrectInfoSuccess = response;
							},function error(response){
								$scope.incorrectInfoSubmitted = true;
														$scope.incorrectInfoSuccess = response;
								});*/
				}

				//Close report incorrect information popupAnchor
				this.closeIncorrectInfo = function() {
					$scope.publicMember = {};
					$scope.publicMember.firstName = '';
					$scope.publicMember.lastName = '';
					$scope.publicMember.email = '';
					$scope.reportInfo ={
						incAddress: false,
						incGender: false,
						incPhone: false,
						incSpeciality: false,
						incGroup: false,
						incDeceased: false,
						duplicateList: false,
						praLocation: false,
						noAccept: false,
						incindicates: false,
						incHospitalAff: false,
						incLanguage: false
					}
					document.getElementById('provider-1').checked = false;
					document.getElementById('provider-2').checked = false;
					document.getElementById('provider-3').checked = false;
					document.getElementById('provider-4').checked = false;
					$scope.selectedProvider = "";
					$scope.providerType = "";
					$scope.chkedOptions = [];
					$scope.incorrectInfoSuccess = false;
					$scope.incorrectInfoSubmitted = false;
					angular.element("#incorrectInfo" ).hide();
					angular.element("#incorrectInfo" ).addClass("fade");
					angular.element("#incorrectInfo" ).removeClass("fadeIn");
					angular.element(".modal-backdrop" ).css("display","none");
				};

				$scope.chkedOptions = [];
				$scope.changeImage = function(data){
					// Make sure there is / or & added to chkedOptions.


					if(data === 'address'){
						$scope.reportInfo.incAddress = !$scope.reportInfo.incAddress;
						if($scope.reportInfo.incAddress){
							$scope.chkedOptions.push("Incorrect Address");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect Address');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'phone'){
						$scope.reportInfo.incPhone = !$scope.reportInfo.incPhone;
						if($scope.reportInfo.incPhone){
							$scope.chkedOptions.push("Incorrect Phone no");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect Phone no');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'gender'){
						$scope.reportInfo.incGender = !$scope.reportInfo.incGender;
						if($scope.reportInfo.incGender){
							$scope.chkedOptions.push("Incorrect gender");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect gender');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'speciality'){
						$scope.reportInfo.incSpeciality = !$scope.reportInfo.incSpeciality;
						if($scope.reportInfo.incSpeciality){
							$scope.chkedOptions.push("Incorrect speciality");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect speciality');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'group'){
						$scope.reportInfo.incGroup = !$scope.reportInfo.incGroup;
						if($scope.reportInfo.incGroup){
							$scope.chkedOptions.push("Incorrect Provider or group");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect Provider or group');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'deceased'){
						$scope.reportInfo.incDeceased = !$scope.reportInfo.incDeceased;
						if($scope.reportInfo.incDeceased){
							$scope.chkedOptions.push("Incorrect deceased");
						} else {
							var index = $scope.chkedOptions.indexOf('Incorrect deceased');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'duplicateList'){
						$scope.reportInfo.duplicateList = !$scope.reportInfo.duplicateList;
						if($scope.reportInfo.duplicateList){
							$scope.chkedOptions.push("Duplicate Listing");
						} else {
							var index = $scope.chkedOptions.indexOf('Duplicate Listing');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'praLocation'){
						$scope.reportInfo.praLocation = !$scope.reportInfo.praLocation;
						if($scope.reportInfo.praLocation){
							$scope.chkedOptions.push("Practitioner does not schedule appointments at service location listed");
						} else {
							var index = $scope.chkedOptions.indexOf('Practitioner does not schedule appointments at service location listed');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'noAccept'){
						$scope.reportInfo.noAccept = !$scope.reportInfo.noAccept;
						if($scope.reportInfo.noAccept){
							$scope.chkedOptions.push("No longer accepts new patients");
						} else {
							var index = $scope.chkedOptions.indexOf('No longer accepts new patients');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'incindicates'){
						$scope.reportInfo.incindicates = !$scope.reportInfo.incindicates;
						if($scope.reportInfo.incindicates){
							$scope.chkedOptions.push("Doctor indicates he or she no longer accepts Aetna Insurance");
						} else {
							var index = $scope.chkedOptions.indexOf('Doctor indicates he or she no longer accepts Aetna Insurance');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'hospitalAffliation'){
						$scope.reportInfo.incHospitalAff = !$scope.reportInfo.incHospitalAff;
						if($scope.reportInfo.incHospitalAff){
							$scope.chkedOptions.push("Hospital Affiliation incorrect");
						} else {
							var index = $scope.chkedOptions.indexOf('Hospital Affiliation incorrect');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'language'){
						$scope.reportInfo.incLanguage = !$scope.reportInfo.incLanguage;
						if($scope.reportInfo.incLanguage){
							$scope.chkedOptions.push("Language spoken incorrect or missing");
						} else {
							var index = $scope.chkedOptions.indexOf('Language spoken incorrect or missing');
							if(index!=-1){
								$scope.chkedOptions.splice(index, 1);
							}
						}
					}
				};

				//Set Selected Provider type

				$scope.setSelectedProvider = function(providerType){
					$scope.providerType = providerType;
				};

				/* Ended report incorrect information functionality*/

				$scope.getStarImage = function(providerId, j){
							var starName='unrated_star.png';
							var currStar = $scope.getStarClass(providerId,j);
							if(currStar == 'pos'){
									starName='rated_star.png';
							}else if(currStar == 'neg'){
									starName='unrated_star.png';
							}else{
									starName='star_half_rated.png';
							}
							return starName;
				};

				$scope.getAvgRating = function(providerId){
					var avgRat=0;
					var currStar='temp';
					for(var j=1;j<6;j++){
							currStar = $scope.getStarClass(providerId,j);
							if(currStar == 'pos'){
								avgRat = avgRat + 1;
							}else if(currStar == 'neg'){
								// avgRat = avgRat + 1;
							}else{
								avgRat = avgRat + 0.5;
							}
					}
					return avgRat;
				};

		// Filter code starts here -------------------------------------------------- //
		$scope.cancelFilter=ProviderResultsService.getCancelFilter();
		$scope.OkFilter=ProviderResultsService.getOkFilter();

		if($scope.criteria.isResetFilter){
					if($scope.checkedItem.length !== 0){
								for(var i=0;i<$scope.checkedItem.length;i++){
										if($scope.checkedItem[i]){
											$scope.isReset = true;
										}
								}
					}
		}

		//Shows the content on clicking of navigation tabs on the left side.
		$scope.clearContentFilter=function()
		{
			var a=$scope.providerRes.listAttributes.length;
			for(var i=0;i<a;i++){
				$scope.showFilterContent[i]=false;
			}
			$scope.criteria.showFilterContent = $scope.showFilterContent;
		};

		//Shows the content on clicking of navigation tabs on the left side.
		$scope.showContent=function($event,index){
						$event.stopPropagation();
						var a=$scope.providerRes.listAttributes.length;
						for(var i=0;i<a;i++){
								if(index==i){
										$scope.showFilterContent[i]=true;
										$scope.showFirstLevel=true;
								}else{
										$scope.showFilterContent[i]=false;
								}
						}
						$scope.criteria.showFilterContent = $scope.showFilterContent;
		};

		$scope.handleAccessibility=function(index){
			var liitems=$('.accessControl');
			for (var i = 0; i < liitems.length; i++) {
				if(index===i){
					var specificItem=liitems[i];
					$(specificItem).attr('aria-expanded',true);
				}
				else{
					var specificItem=liitems[i];
					$(specificItem).attr('aria-expanded',false);
				}
			}
		}

		$scope.bindArrorWithFilterTabs=function(){
				$('.accessControl').on('keydown', function (e) {
	        if ([38,40].indexOf(e.keyCode) == -1) {
	            return;
	        }
	        var link = $(this);
	        switch(e.keyCode) {
	            case 38:
	                    e.preventDefault();
											if(link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').first().length == 0) {
			                    // Focus on the last item in the top level
			                    link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').last().find('a').first().focus();
			                } else {
			                    // Focus on the previous item in the top level
			                    link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').first().find('a').first().focus();
			                }
	                break;
	            case 40:
									e.preventDefault();
									if(link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').first().length == 0){
										link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').last().find('a').first().focus();
									}
									else{
										link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').first().find('a').first().focus();
									}
	                break;
	        }
	    });
		}

		$scope.focusForFilterTabs=function(){
			var inputs = $('#'+idModal).find('select, input, textarea, button, a, iframe').filter(':visible');
		                var firstInput = inputs.first();
		                var lastInput = inputs.last();
		                firstInput.focus();
		                lastInput.on('keydown', function (e) {
		                    if ((e.which === 9 && !e.shiftKey) ) {
		                        e.preventDefault();
		                        firstInput.focus();
		                    }

		                });
		                firstInput.on('keydown', function (e) {
		                    if ((e.which === 9 && e.shiftKey) ) {
		                        e.preventDefault();
		                        lastInput.focus();
		                    }

		                });
		            $(".iframeFocus").on('keydown', function (e) {
		                    if ((e.which === 9 && !e.shiftKey) ) {
		                        e.preventDefault();
		                        firstInput.focus();
		                    }
		                });
		}

		//Reset the filters array and or set the selected filters for display
		function createArrayForListFilters(){
						// if($scope.comingFromToggleCheckbox){
						// 		$scope.comingFromToggleCheckbox =false;
						// 		return;
						// }
						var a=$scope.providerRes.listAttributes.length;
						$scope.isLeveltwo =[];
						$scope.showFilterContent=[];
						$scope.criteria.showFilterContent =[];
						$scope.showSecLevelContent=[];
						$scope.criteria.showSecLevelContent =[];

						for(var i=0;i<a;i++){
										$scope.checkedItem[i]=false;
										$scope.checkedItemChildren[i]=[];
										if($scope.providerRes.listAttributes[i].listFilters.length>1){
												$scope.isLeveltwo[i] = true;
												var childrenArray = $scope.providerRes.listAttributes[i].listFilters.length;
												for(var y=0; y<childrenArray; y++){
														var itemSubChildren = $scope.providerRes.listAttributes[i].listFilters[y].listFilter.length;
														$scope.checkedItemChildren[i][y]=[];
														for(var z=0; z<itemSubChildren; z++){
																$scope.checkedItemChildren[i][y][z]=false;
																// ---------------- Put in the stored filters ------------------
																var code = $scope.providerRes.listAttributes[i].listFilters[y].listFilter[z].code + $scope.providerRes.listAttributes[i].listFilters[y].description;//+y;
																if ($scope.selectedFilters.indexOf(code)!= -1)
																{
																	$scope.checkedItem[i]=true;
																	$scope.checkedItemChildren[i][y][z]=true;
																	angular.element("#Filter"+i).removeClass("unchkLabelPrvSrch");
																	angular.element("#Filter"+i).addClass("filterAdded");
																	$scope.isReset=true;
																}
																// -------------------------------------------------------------
														}
												}
										}else{
															$scope.isLeveltwo[i] = false;
															/*var listFilterstoArray = $filter('toArray')($scope.providerRes.listAttributes[i].listFilters);*/
															var itemChildren = $scope.providerRes.listAttributes[i].listFilters[0].listFilter.length;
															for(var k=0; k<itemChildren; k++){
																	$scope.checkedItemChildren[i][k]=false;
																	// ---------------- Put in the stored filters ------------------
																	var code = $scope.providerRes.listAttributes[i].listFilters[0].listFilter[k].code;
																	if ($scope.selectedFilters.indexOf(code)!= -1)
																	{
																		$scope.checkedItem[i]=true;
																		$scope.checkedItemChildren[i][k]=true;
																		angular.element("#Filter"+i).removeClass("unchkLabelPrvSrch");
																		angular.element("#Filter"+i).addClass("filterAdded");
																		$scope.isReset=true;
																	}
																	// -------------------------------------------------------------
															}
										}
						}
						$scope.criteria.checkedItem = $scope.checkedItem;
						$scope.criteria.checkedItemChildren = $scope.checkedItemChildren;
		};

		//For checking and unchecking of checkboxes.
		$scope.toggleCheckbox=function(index, parentIndex, childIndex){



						$scope.isToggleCheckBox = true;
						$scope.isFirstNavigate = true;
						$scope.comingFromToggleCheckbox=true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								$scope.checkedItemChildren[parentIndex][index]=!$scope.checkedItemChildren[parentIndex][index];
								if($scope.checkedItemChildren[parentIndex][index]){
										$scope.checkedItem[parentIndex]=true;
										angular.element("#Filter"+parentIndex).addClass("filterAdded");
										$scope.isReset=true;
								}else{
										var temp = $scope.checkedItemChildren[parentIndex].length;
										for(var c=0; c<temp; c++){
												if($scope.checkedItemChildren[parentIndex][c]){
													$scope.checkedItem[parentIndex]=true;
													$scope.isReset=true;
													angular.element("#Filter"+parentIndex).addClass("filterAdded");
													break;
												}
												else {
													$scope.isReset=false;
													$scope.checkedItem[parentIndex]=false;
												}
										}
								}
						}else{
								$scope.checkedItemChildren[parentIndex][index][childIndex]=!$scope.checkedItemChildren[parentIndex][index][childIndex];
								if($scope.checkedItemChildren[parentIndex][index][childIndex]){
										$scope.checkedItem[parentIndex]=true;
										angular.element("#Filter"+parentIndex).addClass("filterAdded");
										$scope.isReset=true;
								}else{
											var tempSecOne = $scope.checkedItemChildren[parentIndex].length;
											var tempSecTwo = $scope.checkedItemChildren[parentIndex][index].length;
											listFilterOuterLoop:
												for(var j=0; j<tempSecOne; j++){
															listFilterInnerLoop:
																for(var i=0;i<tempSecTwo;i++)
																{
																			if($scope.checkedItemChildren[parentIndex][j][i]){
																						$scope.checkedItem[parentIndex]=true;
																						$scope.isReset=true;
																						angular.element("#Filter"+parentIndex).addClass("filterAdded");
																						break listFilterOuterLoop;
																			}
																			else {
																						$scope.isReset=false;
																						$scope.checkedItem[parentIndex]=false;
																			}
																}
												}
								}
						}
		};

		//For show and hide of filter window on clicking of filter icon on the results page.
		$scope.toggleFilterWindow=function($event){
			if (!$scope.criteria.isAlphaSort) {
					if(!$scope.criteria.isResetFilter || $scope.isToggleCheckBox || !$scope.criteria.isAlphaSort){
						createArrayForListFilters();
					}
					$scope.isShowCompareWindow=false;
					$event.stopPropagation();
					$scope.isShowSortFilterWindow=!$scope.isShowSortFilterWindow;
					if($scope.isShowSortFilterWindow){
						$scope.clearContentFilter();
						$('.filterOptions').show();
						$('.filterOptions').css('z-index',1);
						setTimeout(function(){ $rootScope.focusForModal('filterOptionsModal'); }, 100);
						$scope.bindArrorWithFilterTabs();
					}
					else{
						$('.filterOptions').hide();
					}
			}
		};

		//For showing second level content of doctor facility
		$scope.showSecondLevelContent=function($event,index,arr){
						//$scope.checkedSecondLevelContentItem[index]=[];

						$event.stopPropagation();
						$scope.showFirstLevel=false;
						var a=arr.length;
						for(var i=0;i<a;i++){
							if(index==i){
								$scope.showSecLevelContent[i]=true;
							}
							else{
								$scope.showSecLevelContent[i]=false;
							}
						}
						$scope.criteria.showSecLevelContent = $scope.showSecLevelContent;
		};

		//For showing back first level content of doctor facility
		$scope.backToFilterFirstLevel=function(index){ // Passed by Sumit
						$scope.showSecLevelContent[index]=false;
						$scope.showFirstLevel=true;
		};

		//On click of clearall button clears all the checkboxes.
		$scope.clearAll=function(index, parentIndex, childIndex){
						$scope.isToggleCheckBox = true;
						$scope.isFirstNavigate = true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][j]=false;
								}
								$scope.checkedItem[parentIndex]=false;
						}else{
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[index].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][index][j]=false;
								}
								var tempClrSecOne = $scope.checkedItemChildren[parentIndex].length;
								var tempClrSecTwo = $scope.checkedItemChildren[parentIndex][index].length;
								listClearAllFilterOuterLoop:
									for(var j=0; j<tempClrSecOne; j++){
										listClearAllFilterInnerLoop:
											for(var i=0; i<tempClrSecTwo; i++)
											{
												if($scope.checkedItemChildren[parentIndex][j][i]){
													$scope.checkedItem[parentIndex]=true;
													break listClearAllFilterOuterLoop;
												}
												else {
													$scope.checkedItem[parentIndex]=false;
												}
											}
									}
						}
						for(var i=0; i<a; i++){
								if($scope.checkedItem[i]){
									$scope.isReset=true;
									break;
								}else{
									$scope.isReset=false;
								}
						}
		};

		//On click of checkall button checks all the checkboxes.
		$scope.checkAll=function(index, parentIndex, childIndex){
						$scope.isToggleCheckBox = true;
						$scope.isFirstNavigate = true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][j]=true;
								}
						}else{
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[index].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][index][j]=true;
								}
						}
						$scope.checkedItem[parentIndex]=true;
						$scope.isReset=true;
		};

		//Compare popUp
		//For reseting the filters
		$scope.filterReset=function(){};



		//For closing the filter window on click of close icon.
		$scope.closeFilterSortWindow=function($event){
						$event.stopPropagation();
						$scope.isShowSortFilterWindow=false;
						$scope.clearContentFilter();
						$('.filterOptions').hide();
		};

		//Compare PopUp
		//For creating the selections made for the filter and sort.
		$scope.sortValueChange=function(){};

		function createListSelection(isAlphaSort,alphabet,isReset){
			if(isReset){

				return $scope.tempArray;
			}
			else {
			var listFilterCode=[];
			var arr=[];
			var code='';
			var name='';
			var listAttributes=$scope.providerRes.listAttributes;
			var listSelection='';
			//Reset selected Filters everytime results is called.
					if(!isAlphaSort){
			$scope.selectedFilters = "";
					}


			for(var i=0;i<listAttributes.length;i++){
						var filterObj=listAttributes.slice(i,i+1)[0];
						listSelection='';
						listFilterCode=[];
								listSelection=listSelection+'{';
								if(!isAlphaSort && $scope.checkedItem[i]){
								if(listAttributes[i].listFilters.length==1){
												var a=$filter('toArray')(filterObj.listFilters[0].listFilter);
												for(var j=0;j<a.length;j++){
															var listFilterObj=a.slice(j,j+1)[0];
															if($scope.checkedItemChildren[i][j]){
																		code=listFilterObj.code.split(":")[1];
																		name=listFilterObj.code.split(":")[0];
																		listFilterCode.push(code);
																		//TO store the selected filters.
																		$scope.selectedFilters = $scope.selectedFilters + listFilterObj.code;
															}
												}
												var selectedCode=listFilterCode.join('$');
												// listSelection=listSelection+'listAttributeName='+name+'%%listFilterCode='+selectedCode+')';
												listSelection=listSelection+'"listAttributeName":'+'\"'+name+'\"'+',"listFilterCode":'+'\"'+selectedCode+'\"'+'}';
												arr.push(listSelection);
								}else{
												for(var k=0;k<filterObj.listFilters.length;k++){
															var listFilterFirstLevelObj=filterObj.listFilters.slice(k,k+1)[0];
															for(var l=0;l<listFilterFirstLevelObj.listFilter.length;l++){
																		var listFilterSecondLevelObj=listFilterFirstLevelObj.listFilter.slice(l,l+1)[0];
																		if($scope.checkedItemChildren[i][k][l]){
																					code=listFilterSecondLevelObj.code.split(":")[1];
																					name=listFilterSecondLevelObj.code.split(":")[0];
																					listFilterCode.push(code);
																					//TO store the selected filters.
																					$scope.selectedFilters = $scope.selectedFilters + listFilterSecondLevelObj.code + listFilterFirstLevelObj.description;// + k;
																		}
															}
															var selectedCode=listFilterCode.join('$');
												}
												// listSelection=listSelection+'listAttributeName='+name+'%%listFilterCode='+selectedCode+')';
												listSelection=listSelection+'"listAttributeName":'+'\"'+name+'\"'+',"listFilterCode":'+'\"'+selectedCode+'\"'+'}';
												arr.push(listSelection);
								}
						}
								if((isAlphaSort && i === listAttributes.length-1) || ($scope.criteria.isAlphaSort && i === listAttributes.length-1)){
									/* if($scope.criteria.isAlphaSort){
										alphabet = $scope.criteria.alphaSet;
										console.log(alphabet);
									} */
									if(alphabet){
										arr = $scope.tempArray;
										code=alphabet.code.split(":")[1];
										name=alphabet.code.split(":")[0];
										//$scope.selectedFilters = $scope.selectedFilters + alphabet.code;
										listSelection=listSelection+'"listAttributeName":'+'\"'+name+'\"'+',"listFilterCode":'+'\"'+code+'\"'+'}';
										// listSelection=listSelection+'(listAttributeName='+name+'%%listFilterCode='+code+')';
										arr.push(listSelection);
			}
								}
				}

			/* Find Doctors fix*/
			if( $scope.criteria.hospitalNavigator && $scope.criteria.hospitalNavigator != '' )
			{
				arr.push( $scope.criteria.hospitalNavigator );
			}
			/**/

				$scope.tempArray = arr;
				$scope.criteria.selectedFilters = $scope.selectedFilters;
				$scope.criteria.selectedListArray = $scope.tempArray;
			return arr;
			}
		};
		// Filter code ends here -------------------------------------------------- //

		$scope.newSearchClicked=ProviderResultsService.getNewSearchClicked();

		if($scope.newSearchClicked==true || $scope.cancelFilter==true || $scope.okFilter==true){
			$scope.showCostButtonIndicator=false;
		}else{
			$scope.showCostButtonIndicator=true;
		}

		$scope.getHideDistanceFlag = function()
		{
			var hide = ProviderResultsService.getHideDistance();
			//reset the value
			ProviderResultsService.setHideDistance(false);
			return hide;
		};

		$scope.reset = function(){
			ProviderSearchCriteriaService.init();
			$scope.criteria.typeAheadSearch = '';
			$scope.criteria.isProviderForGroup = false;
			$scope.criteria.isProviderForIPA = false;
			$scope.criteria.isProviderForHospital = false;
			$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;
			ProviderResultsService.setNewSearchClicked(true);
			ProviderResultsService.setHospitalId('');
			$scope.hideDistanceVal=$scope.getHideDistanceFlag();

		}

		//console.log("SearchText from Parent scope : "+ $scope.$parent.searchText);
		//console.log("isGuidedSearch =" + $scope.$parent.isGuidedSearch);

		 if($state.params.searchTerm!=null && $state.params.searchTerm!=undefined)
		 {
			 $scope.criteria.searchText = $state.params.searchTerm;
		 }

		/**
		 * When the user came via guided search and did a start new search and selected a value from typeahead
		 * The parent scope isGuidedSearch and searchText reamin the one from earlier guided search.
		 * Issue fixed by explicitly deleting "$parent.$parent" attributes
		 */
		/**This is for guided search only **/
		if($state.params.parameters!==null && $state.params.parameters!==undefined)
		{
			if($state.params.parameters.indexOf('isGuidedSearch=true')!=-1){
				$scope.criteria.isGuidedSearch=true;
			}
			else{
				$scope.criteria.isGuidedSearch=false;
			}
		}

		var isGuidedSearch = $scope.criteria.isGuidedSearch || $state.params.isGuidedSearch;
		if($scope.$parent!=null && $scope.$parent!=undefined && $scope.$parent.isGuidedSearch!=undefined)
			isGuidedSearch = isGuidedSearch || $scope.$parent.isGuidedSearch;
		/** For guided search only**/
		if(isGuidedSearch || isGuidedSearch == "true"){
			$scope.criteria.isGuidedSearch = true;
			if($scope.$parent.searchText!=null && $scope.$parent.searchText!=undefined)
			{
				//This is to support search text that have an & in them. The idea is to use ^ but dispay & to the user.
				// Similarly, before calling results service, we need to send '&'
				$scope.criteria.searchText = $scope.$parent.searchText.replace("^","&");
				$scope.criteria.searchText = $scope.criteria.searchText.replace("*","'");
			}
			else
			{
				if($state.params.searchText!=null && $state.params.searchText!=undefined)
					$scope.criteria.searchText = $state.params.searchText;
			}
			//Once set, again initialize the parameters to null so that they get re-initiased on every page load.
			//When we get the paraeter, it gets it from all the nested parents. But when deleting it, we need to explicilty delete it.
			$scope.$parent.$parent.isGuidedSearch = null;
			$scope.$parent.$parent.searchText=null;
		}


		$scope.searchText = $scope.criteria.searchText;
		// $scope.Fname = ProviderSearchCriteriaService.getSelectedMemberFName();

		//Compare popUp
		//fetchProviderResults();

		//For show and hide of compare window on clicking of compare icon on the results page.
		$scope.toggleCompareWindow=function($event){
			$scope.isShowSortFilterWindow=false;
			$event.stopPropagation();
			$scope.isShowCompareWindow=!$scope.isShowCompareWindow;
			if($scope.isShowCompareWindow){
				$('.compareOptions').show();
			}
			else{
				$('.compareOptions').hide();
			}
			//$('.filterOptions ul li a').addClass('nav-tabs');
		};

		//Action performed on clicking change Location link
		$scope.changelocClicked=function(){
			// $state.go('contentPage',{page:'providerSearch'});
		};

		//On clicking cross icon in compare window
		$scope.compareDialogClose=function(){
			$scope.isShowCompareWindow=false;
			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");
		};

		$scope.addtoFavorites = function(idx)
		{
			/*if($scope.providerRes.Providers[idx].fav == true)
				$scope.providerRes.Providers[idx].fav = false;
			else
				$scope.providerRes.Providers[idx].fav = true;
			 */

		};

		$scope.startanewSearch= function()
		{
			$scope.reset();
			var lang = $translate.use();
			$scope.criteria.searchFocus = false;
			$scope.criteria.isResetFilter = false;
			$scope.criteria.filterOrder = '';
			// console.log("resetfilter startanewSearch results"+ $scope.criteria.isResetFilter);
			$scope.criteria.checkedItem = [];
			$scope.criteria.checkedItemChildren = [];
			$scope.criteria.showFilterContent=[];
			$scope.criteria.showSecLevelContent=[];
			$scope.criteria.listSelections = null;
			$scope.criteria.direction = '';
			$scope.criteria.order = '';
			$scope.criteria.isAlphaSort = false;
			$scope.criteria.selectedFilters = '';
			$scope.criteria.selectedListArray = [];
			$scope.criteria.isProviderForIPA = false;
	 		$scope.criteria.isProviderForGroup = false;
	 		$scope.criteria.isProviderForHospital = false;
	 		$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.criteria.typeAheadSearch = '';
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;

			ProviderResultsService.setIpaDetails('');
	 		$scope.criteria.ipaName = '';
	 		$rootScope.grpName = '';
	 		$state.params.poin='';

			//$state.params.parameters='';
			$state.go('contentPage',{page:'providerSearch',parameters:'',
				site_id:siteId,language:language,poin:'',proOrgName:'',hosId:'',hosName:'',proOrgDispName:''});
		};


		/**
		 * The watch function to call the fetchProviderResults gets calls multiple times as the unbinding of it has not occured.
		 * To unbind this, we need to store the scope id of the results controller and only let that controller's watchbe triggered.
		 * The scope ID of the results controller will be stored in the results service everytime it loads.
		 * So this way only the latest watch be invoked. This will avoid duplicate calls to the API.
		 * If there is a better way to do , please let me know.
		 */

		$scope.resultsService.results_scopeID = $scope.$id;

		//Compare popUp
		/*var unbindWatch = $scope.$watch();*/
		//COmpare Controller
		function fetchProviderResults() {};

		$scope.previousFocusCompare = function(e) {
	    if($(e.target).prevAll('.purpleCheckbox').attr('disabled')){
				$(e.target).on('keydown', function (e) {
            if ((e.which === 9 && e.shiftKey) ) {
                e.preventDefault();
								$(e.target).prevAll('.purpleCheckbox').parent().siblings().find('a').last().focus();
            }
        });
			}
		}

		$scope.focusOnFirstElement=function(){

		}
		/** This method will be responsible to fetching the costs associated with the providers (if eligible).
		 *
		 */
		$scope.leftProvidersCount=0;
		$scope.indexForCost=0;
		$scope.fetchCosts = function ()
		{
			configuration.maxCostEstimatesPerPage=parseInt(configuration.maxCostEstimatesPerPage);
			if($scope.newSearchClicked==true || $scope.cancelFilter==true || $scope.okFilter==true){
				configuration.maxCostEstimatesPerPage=configuration.maxCostEstimatesPerPage*2;
				ProviderResultsService.setNewSearchClicked(false);
				ProviderResultsService.setCancelFilter(false);
				ProviderResultsService.setOkFilter(false);
			}

			var spinner ="costSpinner";
			$log.debug("Inside fetchCosts: " +$scope.providerRes);
			var auth = 'Bearer ' + DataCacheService.getToken();
			var noOfEligibleProviders = 0;
			if($scope.providerRes.providerInfoResponses!=null && $scope.providerRes.providerInfoResponses!=undefined){
				//	$log.debug("Inside for loop");
				var length = $scope.providerRes.providerInfoResponses.length !=undefined ? $scope.providerRes.providerInfoResponses.length : $scope.providerRes.interfacePaging.paging.perPage;
				for($scope.indexForCost; $scope.indexForCost < length ; $scope.indexForCost=$scope.indexForCost+1){
					var provider = null;
					if(length == 1)
						provider = $scope.providerRes.providerInfoResponses;
					else
						provider = $scope.providerRes.providerInfoResponses[$scope.indexForCost];

					provider.spinnerKey = spinner + $scope.indexForCost;
					provider.isEligibleForCost = false;
					provider.costEstimated = false;
					if(isProviderEligible(provider))//matches the selection criteria
					{
						provider.isEligibleForCost = true;
						noOfEligibleProviders = noOfEligibleProviders + 1;
						//There is a limit on the number of providers we can get a estimate on per page.
						if(noOfEligibleProviders <= (configuration.maxCostEstimatesPerPage+$scope.leftProvidersCount)){
							//provider.spinnerKey = spinner+index;
							if($scope.guestUser==false && $scope.mpe==true){
								provider.costEstimated = true;
								usSpinnerService.spin(provider.spinnerKey);
								ProviderResultsService.getCost($scope.indexForCost,provider,$scope.costEstimateEndpoint)
								.then(
										function success(response){
											//console.log(response);
											//$timeout(function(){
												var indexResp = response.index;
												//	$scope.providerRes.providerInfoResponses[indexResp].cost = response.cost;
												usSpinnerService.stop(response.spinnerKey);
												//	provider.cost = response.cost;
										//	},5000);

										},
										function error(response){
											usSpinnerService.stop(response.spinnerKey);
											$scope.providerRes.providerInfoResponses[response.index].outOfPocket ="N/A";
										}
								);
							}
							else{
								provider.outOfPocket = "N/A";
								usSpinnerService.stop(provider.spinnerKey);
							}
							if(noOfEligibleProviders==configuration.maxCostEstimatesPerPage){
								$scope.count=($scope.indexForCost+1);
								$scope.maxCostEstimatesPerPage=($scope.indexForCost+1);
							}
							if($scope.indexForCost==length-1 && noOfEligibleProviders<configuration.maxCostEstimatesPerPage && $scope.criteria.page==1){
								$scope.remainingCostEligibleProviders(noOfEligibleProviders);
							}
						}
						else{
								//Limit the max cost estimate eligible providers
								provider.outOfPocket = "N/A";
								usSpinnerService.stop(provider.spinnerKey);
						}

					}
					else{
							//Not Eligible
							provider.outOfPocket = "N/A";
							provider.isEligibleForCost = false;
							usSpinnerService.stop(provider.spinnerKey);
							if($scope.indexForCost==length-1 && noOfEligibleProviders<configuration.maxCostEstimatesPerPage && $scope.criteria.page==1){
								$scope.remainingCostEligibleProviders(noOfEligibleProviders);
							}
					}
				}
				$scope.indexForCost=$scope.count;
			}
			//return false;
		};

		/**Calculating how many providers are left for Cost estimates on the second Page**/

		$scope.remainingCostEligibleProviders=function(noOfEligibleProviders){
				$scope.leftProvidersCount=configuration.maxCostEstimatesPerPage-noOfEligibleProviders;
		}

		/**
		 * fetch any ratings for the items being searched.
		 */
		$scope.fetchRatings = function () {
			//console.log('fetchRatings()');
			if ($scope.providerRes.providerInfoResponses) {
				if (Array.isArray($scope.providerRes.providerInfoResponses)) {
					var length = $scope.providerRes.providerInfoResponses.length;
					//console.log('# of providers to add: ' + length);
					for (var index=0; index < length; index++) {
						// provider object will be in array if more than one provider
						var provider = $scope.providerRes.providerInfoResponses[index];
						RatingsService.checkRating(provider.providerInformation.providerID);
					}
				} else {
					//console.log('adding single provider');
					RatingsService.checkRating($scope.providerRes.providerInfoResponses.providerInformation.providerID);
				}

				// call the ratings web service
				var service = RatingsService.getAllRatings();
				service.then(function success(response) {
					//console.log('service finished');
				},function error(response) {
					//console.log('service error: ' + JSON.stringify(response));
				})

			}
		};

		/**
		 * Identify if the provider is eligible to do a cost estimate.
		 * If the provider is eligible then select the bundle associated with him. (TODO)
		 */
		// function isProviderEligible (provider){
		// 	if(provider.providerData.isIndividualProvider=='Y' && provider.costEstimateEligibilityDetails!=null
		// 	   && provider.costEstimateEligibilityDetails.optOutFlag=='Y'
		// 		 && provider.costEstimateEligibilityDetails.serviceBundleId!=undefined && provider.providerPlanFitIndicator == 'true'
		// 		 && provider.costEstimateEligibilityDetails.responseCode=="000" )
		// 	{
		// 			return true;
		// 	}
		// 	else
		// 		//Provider does not participate in MPE or is a non individual provider
		// 		return false ;
		// };

		// function to show button for fetching more costs
		$scope.showCostButton = function (){
			$scope.showCostButtonIndicator=false;
			//if($scope.guestUser!=true)
				$scope.fetchCosts();
		}
		$scope.statusBeg=true;
		console.log(" 5 : true : $scope.statusBeg" + $scope.statusBeg );
		$scope.statusLast=false;
		$scope.pagination = function(button){

			$scope.criteria.direction=button;
			$sessionStorage.criteria.direction=button;
			if(button=="first"){
				if($scope.statusBeg){
					return;
				}
			}
			else if(button=="previous"){
				if($scope.statusBeg){
					return;
				}
			}
			else if(button=="next"){
				if($scope.statusLast){
					return;
				}
			}
			else if(button=="last"){
				if($scope.statusLast){
					return;
				}
			}
			window.scrollTo(0,0);
			$scope.showCostButtonIndicator=false;
			var curPage=parseInt($scope.providerRes.interfacePaging.paging.page);
			var totalProviders=parseInt($scope.providerRes.interfacePaging.paging.total);
			var perPageProviders=parseInt($scope.providerRes.interfacePaging.paging.perPage);
			var lPage=Math.ceil(totalProviders/perPageProviders);
			var firstRecordOnPage=$scope.providerRes.interfacePaging.firstRecordOnPage;
			var lastRecordOnPage=$scope.providerRes.interfacePaging.lastRecordOnPage;
			if(button=="first"){
				curPage=1;
				$scope.statusBeg=true;
				console.log(" 6 : true : $scope.statusBeg" + $scope.statusBeg );
				$scope.statusLast=false;
			}
			if(button=="previous"){
				curPage--;
				if(curPage==1){
					$scope.statusBeg=true;
					console.log(" 7 : true : $scope.statusBeg" + $scope.statusBeg );
					}
				else{}
				$scope.statusLast=false;
			}
			if(button=="next"){
				curPage++;
				if(curPage==lPage){
					$scope.statusLast=true;
					}
				else{}
				$scope.statusBeg=false;

				console.log(" 8 : false : $scope.statusBeg" + $scope.statusBeg );
			}
			if(button=="last"){
				curPage=lPage;
				$scope.statusLast=true;
				$scope.statusBeg=false;

				console.log(" 9 : false : $scope.statusBeg" + $scope.statusBeg );
			}
			ProviderSearchCriteriaService.setPage(curPage);
			ProviderSearchCriteriaService.setDirection(button);
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			ProviderSearchCriteriaService.setTotal(totalProviders);

			$scope.criteria.page=curPage;
			$scope.criteria.firstRecordOnPage=firstRecordOnPage;
			$scope.criteria.lastRecordOnPage=lastRecordOnPage;
			$scope.criteria.total=totalProviders;

			$sessionStorage.criteria.page=curPage;
			$sessionStorage.criteria.firstRecordOnPage=firstRecordOnPage;
			$sessionStorage.criteria.lastRecordOnPage=lastRecordOnPage;
			$sessionStorage.criteria.total=totalProviders;

			$scope.indexForCost=0;
			NavSpinnerService.spin();
			if(isIE){
				//timeout added in order to handle $digest already running, as in IE is slow so it needs some time to reflect the UI changes.(For Pagination)
				$timeout(function() {
					fetchProviderResults();
	 			},2000)
			}
			else{
				fetchProviderResults();
			}
			console.log("reached");
			if($scope.criteria.page!=2){
				$scope.leftProvidersCount=0;
			}
		};

		//Compare PopUp
		$scope.getGroup = function(group)
		{};

		//Compare PopUp
		$scope.getIPA = function (group)
		{};

		$scope.openURL = function(URL)
		{
			ProviderResultsService.openURL(URL);
		};


		//- Compare popup
		$scope.openPdfURL = function( category )
		{};

		//- Compare popup
		$scope.buildProviderDetailURL = function(provider){};

		//- Compare popup
		$scope.navigate=function(data, pleat){};

		// user clicks on read more link from results page.
		// Need to tell details page to open up experience pleat
		$scope.readMoreDetails = function(data){
			//AnalyticsService.trackLink('Provider Search|read more', AnalyticsService.LINK_TYPE_PAGE);
			ProviderResultsService.scrollTo = 'experiencePanel';
			$scope.navigate(data);
		};

		// user clicks on ratings link from results page.
		// Need to tell details page to open up ratings pleat
		$scope.ratingsDetails = function(data){
			//AnalyticsService.trackLink('Provider Search|ratings details', AnalyticsService.LINK_TYPE_PAGE);
			ProviderResultsService.scrollTo = 'ratingsPanel';
			$scope.navigate(data);
		};

				//Google Maps Starts
		//This information will be used to create markerInfo object so that the html content can be rendered.
		$scope.createMapInformation = function()
		{
			    //Reset Provider creation flag.
				displayProviderMap = false;

				var providerList =[];
				// In this method markerInfo object will get created and each instance will have a lat,long, markerContent,indicator if the provider, is selected, indicator if the providers have the same service location id . The total number of markers should be equal to total number of unique lat/ longs in the list.
				var markerInfo=[];
				var flagmatch = false; // Flag will be set to true once the provider is added to a list of  markerInfo


				//Convert providerInfoResponses to array.
				if ($scope.providerRes && $scope.providerRes.providerInfoResponses != undefined && !angular.isArray($scope.providerRes.providerInfoResponses)) {
					providerList.push($scope.providerRes.providerInfoResponses);
				}else{
					providerList = $scope.providerRes.providerInfoResponses;
				}

				// ACNLA5_1103_MS SR - Changes start
				if (providerList != undefined) {
				// ACNLA5_1103_MS SR - Changes end
					for(var i=0;i<providerList.length;i++){
						//Provider Should be par.
						if(providerList[i].providerPlanFitIndicator == 'true'){

							//There is no markerInfo set yet. This is the first provider.
							if(markerInfo.length == 0)
							{
								markerInfo[0]= {};
								var providerStack=[];
								providerStack.push(providerList[i]);
								markerInfo[0].lat = providerList[i].providerLocations.address.latitude;
								markerInfo[0].long = providerList[i].providerLocations.address.longitude;
								markerInfo[0].providers = providerStack;


								markerInfo[0].serviceLocationIdsame = false;

							}else{

								//Reset FlagMatch.
								flagmatch = false;
								for(var j=0;j<markerInfo.length;j++)
								{
									//lat long the same
									if(markerInfo[j].lat == providerList[i].providerLocations.address.latitude
											&& markerInfo[j].long == providerList[i].providerLocations.address.longitude)
									{

										for(var k=0;k<markerInfo[j].providers.length;k++)
										{
											// Is the service location id the same
											if(markerInfo[j].providers[k].providerLocations.locationIdentifier.idValue == providerList[i].providerLocations.locationIdentifier.idValue)
											{

												markerInfo[j].serviceLocationIdsame = true;
												break;
											}

										}
										//THis should happen after the for loop otherwise serviceLocationIdsame will always be true.
										markerInfo[j].providers.push(providerList[i]);

										flagmatch = true;
										break;
									}
								}
								if(flagmatch == false)
								{
									var providerStack=[];
									providerStack.push(providerList[i]);

									markerInfo.push({

										lat:providerList[i].providerLocations.address.latitude,
										long:providerList[i].providerLocations.address.longitude,
										providers:providerStack,
										serviceLocationIdsame:false
									});

								}

							}
						}
					}
				}
				//Assign so that information windows get Created.
				$scope.markerInfo = markerInfo;
				closeMapCont();
		}

		//Finally create markers.
		var createMarkerInfo = function(){
			var markerInfo = $scope.markerInfo;

			if(markerInfo == undefined || markerInfo.length ==0)
				return;

			for(var i=0;i<markerInfo.length;i++){
				markerContent = "";
				if($("#Marker_"+i)!= undefined)
					markerContent = $("#Marker_"+i).html();

				//add the marker and open the information window.
				if(markerInfo[i].providerSelectedForMap)
				{
					if(markerInfo[i].lat==0.00 && markerInfo[i].long==0.00){
						mapsService.addMarkerFromAddress($scope.createAddressforInformationWindow(markerInfo[i].providers[0]),markerContent,true);
					}else{
						mapsService.addMarker(markerInfo[i].lat,markerInfo[i].long,markerContent,true);
					}
				}
				else{
					if(markerInfo[i].lat==0.00 && markerInfo[i].long==0.00){
						mapsService.addMarkerFromAddress($scope.createAddressforInformationWindow(markerInfo[i].providers[0]),markerContent,false);
					}else{
						mapsService.addMarker(markerInfo[i].lat,markerInfo[i].long,markerContent,false);
					}
				}
			}

			// var tempMarkers=mapsService.getAllMarkers();
			// var bounds = new google.maps.LatLngBounds();
			// for (var i = 0; i < tempMarkers.length; i++) {
			//  bounds.extend(tempMarkers[i].getPosition());
			// }
			// map.fitBounds(bounds);

		}
		function openInfoWindow(markerInfo){
			for(var i=0;i<markerInfo.length;i++){
				if(markerInfo[i].providerSelectedForMap){
					mapsService.openInfoWindow(i);
				}
			}
		}
		function closeMapCont() {
			element = document.getElementById('map');
			var mapCancelButton=document.getElementById('map_cancel');
			if(element == undefined)
				return;
			element.style.display = "none";
			mapCancelButton.style.display = "none";
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}
		function closeMap(){
			// Added for Close Map
			var element = document.getElementById('map');
			var mapCancelButton=document.getElementById('map_cancel');
			element.style.display = "none";
			mapCancelButton.style.display = "none";
			displayProviderMap=true;
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}
		$scope.closeProviderMap = function(provider) {
			mapsService.toggleMap();
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}

		//Method will return the full name for the given provider
		$scope.createNameforInformationWindow = function (provider)
		{
				    if(provider.providerInformation.type == "Individual"){
						return provider.providerInformation.providerDisplayName.full;

					}else{
						//still to handle currently working on indivisual
						return provider.providerInformation.providerDisplayName.full;
					}
		}

		$scope.createAddressforInformationWindow = function(provider)
		{

			var destination = ""
			var address = provider.providerLocations.address;
			//Streetline3 is buildingName
			if(address.buildingName){
				destination = address.buildingName + ", ";
			}
			if(address.streetLine3)
				destination = address.streetLine3 + ", ";
			destination  = destination + address.streetLine1 + ", "
			if(address.streetLine2)
				destination = destination + address.streetLine2 + ", ";

			destination = destination + address.city+ ", "+ address.state +" "+ address.postalCode.substring(0,5);
			return destination;
		}

		// Method that will format the phone number in the formation (XXX)XXX-XXXX
		$scope.createPhoneforInformationWindow = function (provider)
		{

			 var phoneNumber = "";
			 var contacts = $filter('toArray')(provider.contacts);

			if( contacts[0].primaryPhone!=null){
				    phoneNumber = contacts[0].primaryPhone;
					phoneNumber = '('+phoneNumber.number.substring(0,3)+') '+phoneNumber.number.substring(3,6)+'-'+phoneNumber.number.substring(6,phoneNumber.number.length);
			}
			return phoneNumber;
		}

		$scope.openMapView=function(typeOfObject){

					var markerInfo = $scope.markerInfo;

					if(markerInfo == undefined || markerInfo.length ==0)
						return;

					if(typeOfObject!=null && typeOfObject=='map'){
						$( ".listViewButton" ).addClass("active");
						$( ".mapViewButton" ).removeClass("active");
						$(".listViewButton").removeAttr('disabled');
						$(".listViewButton").focus();
						$(".mapViewButton").attr('disabled','true');
						$(".listViewButton").addClass('map_active');
					}else{
						$( ".mapViewButton" ).addClass("active");
						$( ".listViewButton" ).removeClass("active");
						$(".mapViewButton").removeAttr('disabled');
						$(".mapViewButton").focus();
						$(".listViewButton").attr('disabled','true');
						$(".mapViewButton").addClass('map_active');
					}

					if(displayProviderMap==false){
						if(markerInfo[0].lat==0.00 && markerInfo[0].long==0.00){
							mapsService.createMapWithAddress($scope.createAddressforInformationWindow(markerInfo[0].providers[0]),14,"map");
						}else{
							mapsService.createMap(markerInfo[0].lat,markerInfo[0].long,14,"map");
						}
						//Add markers and Information Windows
						createMarkerInfo(markerInfo);
						displayProviderMap = true;
					}
					//Map is already created.
					else{
							mapsService.toggleMap();
							displayProviderMap=true;
					}

				}

		/* Get Directions.*/
		$scope.getDirections = function(provider) {
			if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
				return mapsService.createGoogleMapsDirectionURL($scope.createAddressforInformationWindow(provider));
			}else{
				return mapsService.createGoogleMapsDirectionURL(provider.providerLocations.address.latitude+','+provider.providerLocations.address.longitude);
			}
		}
		// display a map for a provider
		$scope.openProviderMap = function(provider) {
			var markerInfo = $scope.markerInfo;
			var selectedProvPin = provider.providerInformation.providerID;
			var selectedProvSvcID = provider.providerLocations.locationIdentifier.idValue;

			for(var j=0;j<markerInfo.length;j++)
			{
				// when the user clicks on second provider
				if(markerInfo[j].providerSelectedForMap){
					delete markerInfo[j].providerSelectedForMap;
				}
					for(var k=0;k<markerInfo[j].providers.length;k++)
					{
						// Is the service location id the same
						if(selectedProvPin  == markerInfo[j].providers[k].providerInformation.providerID && markerInfo[j].providers[k].providerLocations.locationIdentifier.idValue == selectedProvSvcID)
						{

							markerInfo[j].providerSelectedForMap=true;
							break;
						}
					}
			}
			if(displayProviderMap==false){
				if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
					mapsService.createMapWithAddress($scope.createAddressforInformationWindow(provider),14,"map");
				}else{
					mapsService.createMap(provider.providerLocations.address.latitude,provider.providerLocations.address.longitude,14,"map");
				}
				//Add markers and Information Windows
				createMarkerInfo(markerInfo);
				displayProviderMap = true;
			}
			//Map is already created.
			else{
				if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
					mapsService.updateCenterFromAddress($scope.createAddressforInformationWindow(provider));
				}else{
					mapsService.updateCenter(provider.providerLocations.address.latitude,provider.providerLocations.address.longitude);
				}
				//createMarkerInfo(markerInfo);
				openInfoWindow(markerInfo);
				var element = document.getElementById('map');
				var mapCancelButton=document.getElementById('map_cancel');
				if(element == undefined)
					return;
				if(element.style.display == "none"){
					element.style.display = "block";
					mapCancelButton.style.display = "block";
					$("#hideGoogleMap").focus();
				}
				displayProviderMap=true;
			}
			$( ".listViewButton" ).addClass("active");
			$( ".mapViewButton" ).removeClass("active");
			$(".listViewButton").removeAttr('disabled');
			$(".mapViewButton").attr('disabled','true');
			$(".listViewButton").addClass('map_active');
			$('body,html').animate({
			    scrollTop: $("#map_cancel").offset().top
		  }, 2000);
			$("#hideGoogleMap").focus();
    	$('body,html').clearQueue();
			// function scroll() {
			// 	var id = $scope.getMapId($scope.map.provider);
			// 	var scrollHere = document.getElementById(id);
			// 	scrollHere.focus();
			// 	scrollHere.scrollIntoView();
			// }
      //
			// if (provider.isMap) {
			// 	return;  // map is already open
			// }
      //
			// /* If requesting map for the second time for same provider.
	 		//  Don't call mapQuest again just unhide the map earlier loaded. */
			// /*if( provider.mapAvailable )
			// {
			// 	provider.isMap = true;
			// 	return;
			// }*/
      //
			// var id = $scope.getMapId(provider);
			// $scope.map.provider = provider;
			// provider.isMap = true;  // this provider has a map
      //
			// // fill in map object with info needed for the map
			// try {
			// 	$scope.map.label = provider.providerInformation.providerDisplayName.full;
			// 	/*provider.providerData.isIndividualProvider == "Y" ?
			// 			provider.providerData.individualProvider.nameFull :
			// 				provider.providerData.organizationProvider.nameFull;*/
			// } catch (e) {}
			// try {
			// 	$scope.map.phone = provider.contacts[0].primaryPhone.number;
			// 		/*provider.providerData.providerAtLocation.officeContacts.primaryPhone.number*/;
			// 	$scope.map.phone = phoneFormatFilter($scope.map.phone);
			// } catch (e) {}
			// $scope.map.toAddress =
			// 	provider.providerLocations.address.streetLine1 + ' ' +
			// 	provider.providerLocations.address.city + ' ' +
			// 	provider.providerLocations.address.state + ' ' +
			// 	provider.providerLocations.address.postalCode ;
			// 	/*provider.providerData.providerAtLocation.officeContacts.postalAddresses.streetLine1 + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.city + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.state + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.postalCode
			// 	;*/
			// $scope.map.directions = false;  // not displaying driving directions yet
			// $scope.map.routeListing = null;
      //
			// // create the actual map
			// L.Icon.Default.imagePath = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images';
			// var mapId = $scope.getMapId(provider);  // where to put the map
			// $scope.map.mqMap = L.map(mapId, {
			// 	layers: MQ.mapLayer(),
			// 	zoom: 16
			// });
      //
			// // put the provider address on the map
			// MQ.geocode({
			// 	map: $scope.map.mqMap,
			// 	icon: L.icon({
			// 		iconUrl: '../images/distance.png',
			// 		iconSize: [ 22, 28 ],
			// 		iconAnchor: [ 11, 28 ],
			// 		popupAnchor: [ 0, -22 ]
			// 	})
			// }).search($scope.map.toAddress).on('success', function(e) {
			// 	var best = e.result.best, latlng = best.latlng;
			// 	L.marker([ latlng.lat, latlng.lng ])
			// 	.addTo($scope.map.mqMap)
			// 	.bindPopup(createPOIHtml( provider ))
			// 	.openPopup();
			// });
      //
			// // scroll to map but wait for things to settle
			// setTimeout(scroll, 200);
		}
		//Google Maps Ends
		// Display directions below the map
		// window.openDirections = function() {
		// 	function scroll() {
		// 		var id = $scope.getMapId($scope.map.provider);
		// 		var scrollHere = document.getElementById(id);
		// 		scrollHere.scrollIntoView();
		// 	}
    //
		// 	$scope.map.directions = true;  // display driving directions
    //
		// 	// scroll to map but wait for things to settle
		// 	setTimeout(scroll, 200);
    //
		// 	// angularJS did not call this function, so we need to tell it that it was called
		// 	// so it can update any view changes.
		// 	angular.element(document.getElementById('providerResults')).scope().$apply();
		// }

		// close the map for a provider
		// $scope.closeProviderMap = function(provider) {
		// 	//var id = $scope.getMapId(provider);
		// 	provider.mapAvailable = true;
		// 	provider.isMap = false;  // this provider does not have a map
		// 	try {
		// 		$scope.map.mqMap.remove();
		// 	} catch(e) {};
		// 	$scope.map.mqMap = null;
		// 	$scope.map.directions = false;  // not displaying driving directions yet
		// 	$scope.map.routeListing = null;
		// 	$scope.map.fromAddress = "";
		// }

		// create the HTML that displays the provider on the map
		// function createPOIHtml( provider ) {
    //
		// 	var details = "";
		// 	if( provider.providerLocations.address.streetLine2 )
		// 	{
		// 		details = provider.providerLocations.address.streetLine1 + '<br> ' +
		// 		provider.providerLocations.address.streetLine2 + '<br> ' +
		// 		provider.providerLocations.address.city + ' ' +
		// 		provider.providerLocations.address.state + ' ' +
		// 		provider.providerLocations.address.postalCode;
		// 	}
		// 	else
		// 	{
		// 		details = provider.providerLocations.address.streetLine1 + '<br> ' +
		// 		provider.providerLocations.address.city + ' ' +
		// 		provider.providerLocations.address.state + ' ' +
		// 		provider.providerLocations.address.postalCode;
		// 	}
    //
		// 	var poiHtml =
		// 		'<strong>' + $scope.map.label +
		// 		'</strong><br>' +
		// 		details +
		// 		'<br/>' +
		// 		$scope.map.phone +
		// 		"<br><a href='javascript:openDirections()'>Directions</a>";
		// 	return poiHtml;
		// }

		// create the HTML that displays the provider on the map
		/*function createPOIHtml() {
			var poiHtml =
				'<strong>' + $scope.map.label +
				'</strong><br>' +
				$scope.map.phone +
				"<br><a href='javascript:openDirections()'>Directions</a>";
			return poiHtml;
		}*/
    //
		// $scope.getDirections = function() {
		// 	var dir = MQ.routing.directions()
		// 	.on('success', function(data) {
		// 		var legs = data.route.legs,
		// 		html = '',
		// 		maneuvers,
		// 		i;
    //
		// 		if (legs && legs.length) {
		// 			maneuvers = legs[0].maneuvers;
    //
		// 			// create an array of route steps to display
		// 			$scope.map.routeListing = [];
		// 			for (i=0; i<maneuvers.length; i++) {
		// 				$scope.map.routeListing[i] = maneuvers[i].narrative;
		// 			}
    //
		// 			// angularJS did not call this functions, so we need to tell it that it was called
		// 			// so it can update any view changes.
		// 			angular.element(document.getElementById('providerResults')).scope().$apply();
    //
		// 		}
		// 	});
    //
		// 	dir.route({
		// 		locations: [
		// 		            $scope.map.fromAddress,  // starting point
		// 		            $scope.map.toAddress  // ending point
		// 		            ]
		// 	});
    //
		// 	$scope.map.routeLayer = MQ.routing.routeLayer({
		// 		directions: dir,
		// 		fitBounds: true
		// 	});
    //
		// 	$scope.map.mqMap.addLayer($scope.map.routeLayer);
    //
		// };
		/* Map End*/



		// create a map centered on the provider stored in the scope
		// $scope.createSearchResultsMap = function() {
		// 	// only do this if the popover is open
		// 	if (!$scope.map.open) return;
		// 	if ($scope.map.created) return;
    //
		// 	if (!$scope.map.mqMap) {
		// 		//console.log("create map once");
		// 		L.Icon.Default.imagePath = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images';
		// 		$scope.map.mqMap = L.map('searchResultsMap', {
		// 			layers: MQ.mapLayer(),
		// 			zoom: 16
		// 		});
		// 	}
		// 	//console.log("geocode map");
		// 	MQ.geocode({
		// 		map: $scope.map.mqMap,
		// 		icon: L.icon({
		// 			iconUrl: '/images/distance.png',
		// 			iconSize: [ 22, 28 ],
		// 			iconAnchor: [ 11, 28 ],
		// 			popupAnchor: [ 0, -22 ]
		// 		})
		// 	}).search($scope.map.toAddress).on('success', function(e) {
		// 		var best = e.result.best, latlng = best.latlng;
		// 		//console.log("found location: " + latlng.lat + ', ' + latlng.lng);
		// 		L.marker([ latlng.lat, latlng.lng ])
		// 		.addTo($scope.map.mqMap)
		// 		.bindPopup(createPOIHtml( provider ))
		// 		.openPopup();
		// 		$scope.map.created = true;
    //
		// 	});
    //
		// };
    //
		// $scope.closeDirections = function() {
		// 	$scope.map.directions = false;  // not displaying driving directions
		// 	$scope.map.routeListing = null;
		// 	$scope.map.mqMap.removeLayer($scope.map.routeLayer);
		// };

		$scope.dateConversion = function(date){
			 return new Date(date);
		};

		$scope.closeModal=function(id){
			angular.element("#"+id).hide();
			angular.element("#"+id).addClass("fade");
			angular.element("#"+id).removeClass("fadeIn");
			angular.element("#"+id).css("display", "none");
			angular.element(".modal-backdrop" ).css("display","none");
		}


		$scope.paginationDisable=false;
		//whenever plan is changed from the results Page itself
		$rootScope.planChangeClick=function(value, proc){
			if(value){
				$scope.paginationDisable=true;
			}
			var firstRecordOnPage = 1;
			var lastRecordOnPage = 0
			if($scope.providerRes.interfacePaging){
				if($scope.providerRes.interfacePaging.paging && $scope.providerRes.interfacePaging.paging.total && $scope.providerRes.interfacePaging.paging.perPage){
					var totalProviders=parseInt($scope.providerRes.interfacePaging.paging.total);
					var perPageProviders=parseInt($scope.providerRes.interfacePaging.paging.perPage);
					var lPage=Math.ceil(totalProviders/perPageProviders);
				}
				if($scope.providerRes.interfacePaging.firstRecordOnPage){
					firstRecordOnPage=$scope.providerRes.interfacePaging.firstRecordOnPage;
				}
				if($scope.providerRes.interfacePaging.lastRecordOnPage){
					lastRecordOnPage=$scope.providerRes.interfacePaging.lastRecordOnPage;
				}
			}
			ProviderSearchCriteriaService.setPage(1);
			ProviderSearchCriteriaService.setDirection("");
			if(proc=="skip"){
				$scope.criteria.planProductCode="";
			}
			else{
				$scope.criteria.planProductCode=proc;
			}
			fetchProviderResults();
		};

		$scope.printPage = function() {
			$window.print();
		}
		// control the colorful display of tier messages

		// return the ID for a tier message in a provider.  The ID is passed to other functions to determine
		// the CSS classes needed to generate the HTML.  This is needed because the service does not return
		// anything about the type of tier message except text.
		// Note: Right now, the classes are determined by the actual text of the message - yuck
		// We need a code returned by the service so we can test on something better.
		function tierMessageId (provider) {
			// return null if no designations for provider
			var d = provider.providerDesignations;
			if (!d) return null;
			if (!Array.isArray(d)) {
				d = [d];
			}

			for (var i=0; i<d.length; i++) {
				var designation = d[i];
				if (designation.type === 'tier' && designation.description) {
					// the code is in the message text
					var msg = designation.description.split('_');
					return msg;
				}
			}
			return null;  // if we get here, no tier designation
		}

		// fill in the tier message ID for all providers since we aren't given this info in the service.
		function fillInTierMessageIds() {
			if ($scope.providerRes.providerInfoResponses) {
				if (Array.isArray($scope.providerRes.providerInfoResponses)) {
					var length = $scope.providerRes.providerInfoResponses.length;
					for (var index=0; index < length; index++) {
						// provider object will be in array if more than one provider
						var provider = $scope.providerRes.providerInfoResponses[index];
						var msg = tierMessageId(provider);  // get code and text
						if (!msg) continue;  // skip if no tier info
						provider.tierMessageId = msg.length > 1 ? msg[0] : null;
						provider.tierMessage = msg.length > 1 ? msg[1] : msg[0];
					}
				} else {  // just one provider
					var provider = $scope.providerRes.providerInfoResponses;
					var msg = tierMessageId(provider);  // get code and text
					if (!msg) return;
					provider.tierMessageId = msg.length > 1 ? msg[0] : null;
					provider.tierMessage = msg.length > 1 ? msg[1] : msg[0];
				}

			}

		}

		// get a unique key for a provider
		function getProviderKey(provider) {
					// handle bad provider parameter
					if (!provider || !provider.providerInformation || !provider.providerLocations
						|| !provider.providerLocations.locationID
						|| !provider.providerInformation.providerID) {
						return null;  // bad data - no key
					}

					var key = provider.providerInformation.providerID
						+ '.'
						+ provider.providerLocations.locationID;
					return key;
		}

		$scope.openFauxRowURL = function(URL, label) {

			 ProviderResultsService.showDisclaimer(URL,'standard',null);
			/*
			if (label != null && label != undefined && label.indexOf("vision") > -1) {
				ProviderResultsService.showDisclaimer(URL,'vision',null);
			 }
			 else if (URL != null && URL != undefined && URL.indexOf("aetna") == -1) {
				 if(label != null && label != undefined && label.indexOf("LGBT") > -1){
					 ProviderResultsService.showDisclaimer(URL,'vision',null);
				 }else
					 ProviderResultsService.showDisclaimer(URL,'standard',null);
			}
			 else{
				 ProviderResultsService.openURL(URL);
			 }
		*/};


		/* Support for compare providers functionality start */

		$scope.resultsService.compareInit();  // always do it once

		// indicate if we are doing a compare - if user has checked any providers to compare
		$scope.doingCompare = function() {
			return compareData.items.length > 0;
		};

		// return array of providers being compared
		$scope.providersBeingCompared = function() {
			return compareData.items;
		};
		// return array of providers being compared
		$scope.providersBeingComparedOrder = function() {
			return compareData;
		};

		// indicate if we are currently comparing a given provider
		$scope.comparingProvider = function(provider) {
			if (!$scope.doingCompare()) {
				return false;  // not comparing anything
			}

			var key = $scope.resultsService.getProviderKey(provider);
			if (!key) {
				return false;  // invalid provider object
			}

			return compareData.lookup[key];  // indicate if comparing provider
		};

		// indicate if user can add any more providers to compare
		function canCompareMore() {
			return compareData.items.length < compareData.MAX_SIZE;
		}

		// indicate if user can compare the checked providers
		$scope.canDoCompare = function() {
			return compareData.items.length > 1;
		};

		// add provider to list of providers to be compared if possible.  Handle too many items and duplicate
		$scope.addToCompare = function(provider) {
			if (!canCompareMore()) {
				return;  // cannot compare any more items
			}

			var key = $scope.resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (compareData.lookup[key]) {
				return;  // item is already being compared
			}

			compareData.items.push(provider);  // add to list
			compareData.lookup[key] = provider;  // add to lookup
		}

		// remove provider from list of providers being compared.  Handle errors
		$scope.removeFromCompare = function(provider) {
			var key = $scope.resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (!compareData.lookup[key]) {
				return;  // item is not being compared
			}

			for (var i=0; i<compareData.items.length; i++) {
				var key2 = $scope.resultsService.getProviderKey(compareData.items[i]);
				if (key === key2) {
					compareData.items.splice(i, 1);
					break;  // found it
				} // if found
			} // look through providers being compared
			compareData.lookup[key] = null;  // remove from lookup
		}

		// remove all providers from list of providers being compared.
		$scope.cancelCompare = function() {
			$scope.resultsService.compareInit();
		}


		// handle user clicking on a checkbox for a particular provider.  This may do or undo the compare.
		$scope.providerCompare = function(provider) {
			if (!$scope.providerCheckable(provider)) {
				return;  // not allowed to check this provider so ignore
			}
			var key = $scope.resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}
			if (compareData.lookup[key]) {  // we are already comparing this item, so stop comparing it
				$scope.removeFromCompare(provider);

				AnalyticsService.trackAddRemoveCompare({
					providerID : provider.providerInformation.providerID,
					locationID : provider.providerLocations.locationID,
					key : key}, 'remove');
			} else {
				$scope.addToCompare(provider);

				AnalyticsService.trackAddRemoveCompare({
					providerID : provider.providerInformation.providerID,
					locationID : provider.providerLocations.locationID,
					key : key} , 'add');
			}
		}

		// determine if checkbox is read/write (checkable)
		$scope.providerCheckable = function(provider) {
			if (canCompareMore()) {
				return true;  // all checkboxes are checkable
			}

			// at this point, a checkbox is read/write only if it is already involved in a compare.
			var key = $scope.resultsService.getProviderKey(provider);
			if (!key) {
				return false;  // invalid provider object
			} else if (compareData.lookup[key]) {  // we are already comparing this provider, so it is checkable
				return true;
			} else {
				return false;
			}
		}

		$scope.changeCheckboxImage=function(provider){
			if($scope.comparingProvider(provider)){
				return 'images/purple-checked.png';
			}
			else if(!$scope.comparingProvider(provider)){
				if($scope.providerCheckable(provider)){
					return 'images/purple-unchecked.png';
				}
				else{
					return 'images/unchecked_box.png';
				}
			}
		}

		$scope.getCompareList = function(){
			return $scope.compareListArray;
		};

		$scope.getCompareListFromService = function(){
			 $scope.compareListArray = CompareProviderService.getProvidersToCompare();

			return $scope.compareListArray;
		};

		$scope.showHospitalsFromService = function()
		{
			//$scope.showHospitals = CompareProviderService.getShowHospitals();
			return CompareProviderService.getShowHospitals();
		};

		$scope.getHosCountFromService = function()
		{
			return CompareProviderService.getHosCount();;
		};



		// compare the checked providers
		$scope.doCompare = function() {
			//$scope.isShowCompareWindow=!$scope.isShowCompareWindow;

			if(!compareData.showCompare){
				compareData.showCompare = true;
				window.scrollTo(0,0);
				$scope.compareListArray = $scope.providersBeingCompared();

				CompareProviderService.setProvidersToCompare($scope.compareListArray);
				CompareProviderService.setShowComparePopUp(compareData.showCompare);

				$scope.hosOrder = $scope.providersBeingComparedOrder();
				$scope.isShowSortFilterWindow=false;
				$scope.hosCount=0;

				CompareProviderService.setHosCount($scope.hosCount);

				// code for hospital Affliations <starts>
				$scope.hospitalAffiliations = [];
				for(var i=0; i<$scope.compareListArray.length; i++){
						if($scope.compareListArray[i].providerInformation.type === 'Individual'){
								$scope.showHospitals = true;

								CompareProviderService.setShowHospitals($scope.showHospitals);

								ProviderResultsService.setProvider($scope.compareListArray[i]);
									ProviderResultsService.getProviderDetails()
									.then(
												function success(result) {
													$scope.hosCount++;

													CompareProviderService.setHosCount($scope.hosCount);

													if( result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID != undefined){
																	var hosLocId = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID;
													}
													if( result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].providerID != undefined){
																	var hosProId = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].providerID;
													}
													var orderKey = hosProId
														+ '.'
														+ hosLocId;
														for(var k=0;k<$scope.compareListArray.length; k++){
																	var tempkey = $scope.compareListArray[k].providerInformation.providerID
																		+ '.'
																		+ $scope.compareListArray[k].providerLocations.locationID;
																		// alert("k ::  " + k + " tempkey :" + tempkey + " and orderKey : " + orderKey);
																		if(tempkey === orderKey){
																				$scope.compareListArray[k].itsHosps = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals;  // add to list
																				// alert("After Hospitals " + k +" : "+ $scope.compareListArray[k].itsHosps[0].providerDisplayName.full);
																				CompareProviderService.setProvidersToCompare($scope.compareListArray);
																		}
														}
													  // result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals.orderName = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.practitioner.nameLast;
														// $scope.hospitalAffiliations.push(result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals);
												}
									);
						}else{
								$scope.hosCount++;
								CompareProviderService.setHosCount($scope.hosCount);
						}
				}

				AnalyticsService.trackCompare();
				// code for hospital Affliations <ends>
				$('.compareOptions').show();
				/*angular.element("#comparePopUp" ).show();
				angular.element("#comparePopUp" ).show();*/

				//MOna
				CompareProviderService.setProvidersToCompare($scope.compareListArray);
				$scope.showPopUpFormService =

				setTimeout(function(){ $rootScope.focusForModal('comparePopUp'); }, 100);
				angular.element("#comparePopUp" ).css("display","block");
				angular.element("#comparePopUp" ).addClass("fadeIn");
				angular.element("#comparePopUp" ).removeClass("fade");

				$("#comparePopUpInLayout").siblings().attr('aria-hidden',true);;
				$("#comparePopUpInLayout").attr('aria-hidden',false);

				$(".SI_eh2H1xGrz3D73a5_SliderContainer").attr('aria-hidden',true);

				setTimeout(function(){ $rootScope.focusForModal('compareOptionsModal'); }, 100);
				setTimeout(function(){$('#compareOptionsModal').focus(); }, 200);
				angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");

				/*angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");*/

			}
			else{
				$scope.compareListArray = $scope.providersBeingCompared();
				$scope.isShowSortFilterWindow=false;
				CompareProviderService.setProvidersToCompare($scope.compareListArray);
			}
		}


		// allow other controllers to do a compare
		/*var unregisterCompareFn = $scope.$on('doCompare', function (event, arg) {
			$scope.doCompare();
		});*/


		// functions to handle compare island
		// indicate if we are doing a compare - if user has checked any providers to compare
		//and the compare popup is not being displayed currently
		$scope.doingCompare1 = function() {
			return $state.params.page == "providerResults" && ProviderResultsService.compareData.items &&
			       ProviderResultsService.compareData.items.length > 0 && ProviderResultsService.compareData.showCompare == false;
		}

		// indicate if user can compare the checked providers
		$scope.canDoCompare1 = function() {
			return ProviderResultsService.compareData.items &&
			      ProviderResultsService.compareData.items.length > 1;
		}

		// return array of providers being compared
		$scope.providersBeingCompared1 = function() {
			return ProviderResultsService.compareData.items;
		}

		// remove provider from list of providers being compared.  Handle errors
		$scope.removeFromCompare1 = function(provider) {
			var key = ProviderResultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (!ProviderResultsService.compareData.lookup[key]) {
				return;  // item is not being compared
			}

			for (var i=0; i<ProviderResultsService.compareData.items.length; i++) {
				var key2 = ProviderResultsService.getProviderKey(ProviderResultsService.compareData.items[i]);
				if (key === key2) {
					ProviderResultsService.compareData.items.splice(i, 1);
					break;  // found it
				} // if found
			} // look through providers being compared
			ProviderResultsService.compareData.lookup[key] = null;  // remove from lookup
		};

		// remove all providers from list of providers being compared.
		$scope.cancelCompare1 = function() {
			ProviderResultsService.compareInit();
			CompareProviderService.reset();
		};

		//On clicking cross icon in compare window
		$scope.compareDialogClose=function(){

			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");

			var returnToLinkId;
			if ( $scope.compareListArray && $scope.compareListArray.length >= 1)
			{
				var lastElement = $scope.compareListArray.length - 1 ;
				returnToLinkId = $scope.compareListArray[lastElement].providerInformation.providerID;
			}
			$scope.compareListArray=[];
			$scope.cancelCompare();
			compareData.showCompare = false;

			if ( returnToLinkId )
			{
					returnFocusToRprtIncLink( returnToLinkId );
			}

		};

		$scope.compareDialogCloseFromService =function(){

			$("#comparePopUpInLayout").siblings().attr('aria-hidden',false);;
			$("#comparePopUpInLayout").attr('aria-hidden',true);
			$(".SI_eh2H1xGrz3D73a5_SliderContainer").attr('aria-hidden',false);

			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");

			var returnToLinkId;
			$scope.compareListArray = CompareProviderService.getProvidersToCompare();

			if ( $scope.compareListArray && $scope.compareListArray.length >= 1)
			{
				var lastElement = $scope.compareListArray.length - 1 ;
				returnToLinkId = $scope.compareListArray[lastElement].providerInformation.providerID;
			}
			$scope.compareListArray=[];
			$scope.cancelCompare();
			compareData.showCompare = false;

			if ( returnToLinkId )
			{
				$scope.returnFocusToRprtIncLink( returnToLinkId );
			}

			CompareProviderService.reset();

		};


		/*The Focus will return to the report incorrect information link of the
		 * last provider in the compare array */
		$scope.returnFocusToRprtIncLink=function(id){
			$('#'+id).focus();
		};
		$scope.remFrmCompare=function(index){
			$scope.hosCount--;
			CompareProviderService.setHosCount($scope.hosCount);
			$scope.compareListArray.splice(index,1);
			if($scope.compareListArray.length==1)
				$scope.compareDialogClose();
		};

		$scope.remFrmCompareFromService=function(index){

			$scope.hosCount = CompareProviderService.getHosCount();
			$scope.hosCount--;
			CompareProviderService.setHosCount($scope.hosCount);
			$scope.compareListArray.splice(index,1);

			CompareProviderService.setProvidersToCompare($scope.compareListArray);

			if($scope.compareListArray.length==1)
				$scope.compareDialogCloseFromService();
		};
		// compare the checked providers
		/*$scope.doCompare1 = function() {
			// just send an event to the controller doing the compare
			$rootScope.$broadcast('doCompare', 'message');
		}*/

		/* Support for compare providers functionality end */
		/*$scope.$on('$destroy', unregisterCompareFn);*/


		//Compare PopUp
		/*Alpha sort functionality*/
		$scope.getResultsBasedonAlphaSort = function(alphabet){};

		//Compare PopUp
		//Reset button functionality
		$scope.resetAlphaSort = function(){};

		//- Compare pop up
		$scope.disableAlphasort = function(isSort){};
		/**
				* Adding Alphabets and Codes based response
				*/
		//- Compare pop up
		$scope.setAlphabets = function(alphasetData){};

		//- Compare pop Up
		$scope.getAlphabets = function(alphabets, alphaAttributes){};
		//setTimeout(function(){var src = $('#checkURL1').attr('src');
		//alert("source of image with alternate text = example - " + src);},10000);

		//var tempcheck= $("checkURL1").attr("src");
	}




})();

},{}],10:[function(require,module,exports){
angular.module('nav-ui').filter('planFilter', [function(){

		/** This is to convert any object to Array so that ng-repeat directive works fine.  **/
			return  function planFilter(planList, searchText) {

				var searchTxt = searchText.replace(/[()\/,&#\\]/g, '');
				searchTxt = searchTxt.replace(/(&TRADE;|&REG;|&#174;|&#8480;)/gi, '');
				searchTxt = searchTxt.replace(/\b(Aetna|Plan)\b/gi, '');
				searchTxt = searchTxt.replace(/  /g,' ');
				searchTxt = searchTxt.replace(/^\s+|\s+$/gm,'');
				// console.log("replace:"+searchTxt);

				var updatedPlanListArr = [];
				var errorConditionArr = {"errorCondition":"true"};
				if(searchTxt != ""){
					// using javascript .filter() as it is much faster than for loop
					function filterByName(item) {
						var planHeaderName=item.headerName.toUpperCase().replace(/(&TRADE;|&REG;|&#174;|&#8480;)/gi,'');
						planHeaderName=planHeaderName.toUpperCase().replace(/\b(Aetna|Plan)\b/gi, '');
						planHeaderName=planHeaderName.replace(/[()\/,&#\\]/g, '');
						planHeaderName = planHeaderName.replace(/  /g,' ');
						planHeaderName = planHeaderName.replace(/^\s+|\s+$/gm,'');

						var planDisplayName=item.displayName.toUpperCase().replace(/(&TRADE;|&REG;|&#174;|&#8480;)/gi,'');
						planDisplayName=planDisplayName.toUpperCase().replace(/\b(Aetna|Plan)\b/gi, '');
						planDisplayName=planDisplayName.replace(/[()\/,&#\\]/g, '');
						planDisplayName = planDisplayName.replace(/  /g,' ');
						planDisplayName = planDisplayName.replace(/^\s+|\s+$/gm,'');

							if(planDisplayName.contains(searchTxt.toUpperCase()) || planHeaderName.contains(searchTxt.toUpperCase())){
								// console.log("planHeaderName:"+planHeaderName);
								return true;
							}
							else{
								return false;
							}
						}
						updatedPlanListArr = planList.filter(filterByName);
						// for(var i = 0; i < planList.length; i++){
						// 		//var planDisplayName=planList[i].displayName.toUpperCase().replace(/[™®℠]/g,'');
						// 		var planDisplayName=planList[i].displayName.toUpperCase().replace(/(&TRADE;|&REG;|&#8480;|Aetna|Plan)/gi,'');
						// 		planDisplayName=planDisplayName.replace(/[()\/,&#\\]/g, '');
						// 		planDisplayName = planDisplayName.replace(/  /g,' ');
						//
						// 		if(planDisplayName.contains(searchTxt.toUpperCase())){
						// 				updatedPlanListArr.push(planList[i]);
						// 		}
						// }
					}else{
							updatedPlanListArr = planList;
					}

					if(updatedPlanListArr.length == 0){
						updatedPlanListArr = errorConditionArr;
					}
					return updatedPlanListArr;
			};
}]);

},{}],11:[function(require,module,exports){
(function() {
	angular
	.module('nav-ui')
	.controller('DirectoryLastUpdatedController', DirectoryLastUpdatedController);

	DirectoryLastUpdatedController.$inject = ['ProviderResultsService', '$rootScope'];

	function DirectoryLastUpdatedController(ProviderResultsService,$rootScope) {
		$rootScope.lastUpdatedDate=ProviderResultsService.getUpdatedDate();
		
		
	}
})();

},{}],12:[function(require,module,exports){
(function() {
	angular.module('nav-ui').controller('PlanSelectionController', PlanSelectionController);

	PlanSelectionController.$inject = ['$scope','$state','$http','$rootScope','PlanListService','$sessionStorage',
	'NavSpinnerService','ProviderSearchCriteriaService','configuration', '$filter','$window','AnalyticsService','$filter','LanguageDataService','ProviderResultsService','$element'];

	function PlanSelectionController($scope,$state,$http,$rootScope,PlanListService,$sessionStorage,
			NavSpinnerService, ProviderSearchCriteriaService,configuration, $filter, $window, AnalyticsService,$filter,LanguageDataService,ProviderResultsService,$element) {
				$rootScope.$on("destroyScope", function(){
				   $scope.$destroy();
				});
		$scope.showPlanModal=false;
		$scope.showPlanDebbugger=false;
		var showAllPlansLink = false;
		var hidePlansInGeoLink = false;
		var isPlanModalOpen = false;
		var selPlan = "";
		var idLink = "";
		var enrollmentLink = "";
		var fixedPlanName = "";
		var redirectUrl = "";
		var externalUrl = "";
		var checkedPlanBeforeClose = "";
		var intermediatePlans='';
		
       
		
		$scope.planListCollapsed = true;
		$scope.collapseFunction = function(searchPlanTerm){
			if(searchPlanTerm !== ''){
				$scope.planListCollapsed = false;
			}
			else {
				$scope.planListCollapsed = true;
				// $state.reload();
			}
		};
		$scope.collapseFunctionPlanModal = function(searchPlanTerm){
			if(searchPlanTerm !== ''){
				$scope.planListCollapsed = false;
			}
			else {
				$scope.planListCollapsed = true;
				// angular.element(".modal-backdrop" ).css("display","none");
				// $scope.changePlanClick();
			}
		};
		$scope.showAllPlans = function(){
      $("#scrollStyle").scrollTop(0);
    	window.scrollTo(0, 0);
			$scope.getPlansAsPerGeo = false;
			showAllPlansLink = false;
			hidePlansInGeoLink = true;
			angular.element("#outOfGeoPlanDisclaimer" ).css("display","block");
			$scope.listOfPlans = updateListOfPlansAsPerGeo($scope.planCriteria.planArray, $scope.getPlansAsPerGeo);
			for (var i in $scope.listOfPlans) {
				$scope.listOfPlans[i].collapseHeader=false;
			}
			intermediatePlans=angular.copy($scope.listOfPlans);
		};

		$scope.showPlansInGeo = function(){
      $("#scrollStyle").scrollTop(0);
    	window.scrollTo(0, 0);
			$scope.getPlansAsPerGeo = true;
			showAllPlansLink = true;
			hidePlansInGeoLink = false;
			angular.element("#outOfGeoPlanDisclaimer" ).css("display","none");
			$scope.listOfPlans = updateListOfPlansAsPerGeo($scope.planCriteria.planArray, $scope.getPlansAsPerGeo);
			for (var i in $scope.listOfPlans) {
				$scope.listOfPlans[i].collapseHeader=false;
			}
			intermediatePlans=angular.copy($scope.listOfPlans);
		};
		function updateListOfPlansAsPerGeo(plans,getPlansAsPerGeo){
			if(getPlansAsPerGeo){
				var updatedPlans = $filter('filter')(plans, 'PRESENT' , true);
				return updatedPlans;
			}else{
				return plans;
			}
		};

		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.planCriteria = ProviderSearchCriteriaService.getPlanCriteria();
		$scope.languageData = LanguageDataService.getLanguageData();

		// if($scope.languageData.SWITCH_PLAN_DEBUG_INFO == "ON"){
		// 	$scope.showPlanDebbuggerSwitch=false;
		// 	if((window.location.href.indexOf("debug=true") > -1) && (configuration.debugPlanInfo == "true")){
		// 		$scope.showPlanDebbuggerSwitch=true;
		// 	}
		// }else {
		// 	if(window.location.href.indexOf("debug=false") > -1){
		// 		$scope.showPlanDebbuggerSwitch=false;
		// 	}else {
		// 		$scope.showPlanDebbuggerSwitch	=true;
		// 		if(configuration.debugPlanInfo == "true"){
		// 			$scope.showPlanDebbuggerSwitch=true;
		// 		}else{
		// 			$scope.showPlanDebbuggerSwitch=false;
		// 		}
		// 	}
		// }

		// psDesignatedWalkins is a subhellper defined in the business xml.
		function designatedSupressionLogic(productCode){
			if($scope.languageData.psDesignatedWalkins == 'ON')		        
			{
				var suppressionCodes  = $scope.languageData.psDesignatedWalkins_SupressionPlans; 
				if(suppressionCodes !=undefined && suppressionCodes !="" && productCode != "")
				{
					planName= "," + productCode + ",";

					//If the selected plan is in the supressin list then do not display the tile. 
					if(suppressionCodes.indexOf(planName)!= -1)
					{
						$(".psDesignatedWalkins").css("display","none");
						$(".psWalkins").css("display","block");
					}
					else{

						$(".psDesignatedWalkins").css("display","block");
						$(".psWalkins").css("display","none");
					}
				}
				else{

					$(".psDesignatedWalkins").css("display","block");
					$(".psWalkins").css("display","none");
				}


			}
			else
			{
				$(".psDesignatedWalkins").css("display","none");
				$(".psWalkins").css("display","block");
			}
		}
		
		
		designatedSupressionLogic($scope.criteria.planProductCode);
		
		function suppressOtherTilesWhenEAPPlanSelection(productCode){
			if( $scope.languageData.PS_SuppressOtherTilesWhenEAPPlanSelection == 'ON' )		        
			{
				var EAPPlanFound = false;
				var EAPProductCodes  = $scope.languageData.PS_SuppressOtherTilesWhenEAPPlanSelection_EAPProductCodes; 
				if( EAPProductCodes != undefined && EAPProductCodes !="" && productCode != "" )
				{
					planName = "," + productCode + ",";

					/*If the selected productCode is EAP Then only display 
					 * EAP tile and suppress other tiles.*/ 
					if(EAPProductCodes.indexOf(planName)!= -1)
					{
						EAPPlanFound = true;
						$(".psMedicalDocsSpecs").css("display","none");
						$(".psHospFacilites").css("display","none");
						$(".psMedicalDocs").css("display","none");
						$(".psDesignatedWalkins").css("display","none");
						$(".psWalkins").css("display","none");
						$(".psPharmacy").css("display","none");
						$(".psDentalCare").css("display","none");
						$(".psVision").css("display","none");
						$(".psLabsTesting").css("display","none");
						$(".psAltMedicine").css("display","none");
						$(".psMedEquipments").css("display","none");
						$(".psProcsConds").css("display","none");
						$(".psIOEandIOQ").css("display","none");
						
						$(".psBehavHealth").css("display","block");
					}
				}
				if( !EAPPlanFound )
				{
					$(".psMedicalDocsSpecs").css("display","block");
					$(".psHospFacilites").css("display","block");
					$(".psMedicalDocs").css("display","block");
					$(".psPharmacy").css("display","block");
					$(".psDentalCare").css("display","block");
					$(".psVision").css("display","block");
					$(".psLabsTesting").css("display","block");
					$(".psAltMedicine").css("display","block");
					$(".psMedEquipments").css("display","block");
					$(".psProcsConds").css("display","block");
					$(".psIOEandIOQ").css("display","block");
					
					$(".psBehavHealth").css("display","block");

				}
			}
		}
		
		suppressOtherTilesWhenEAPPlanSelection($scope.criteria.planProductCode);
		
		if(window.location.href.indexOf("debug=true") > -1){
			$scope.showPlanDebbuggerSwitch=true; // Show debug Info
		}else if(window.location.href.indexOf("debug=false") > -1){
			$scope.showPlanDebbuggerSwitch=false; // DO NOT show debug Info
		}else {
			if(configuration.debugPlanInfo == "true"){ //config.json (prod : false and QA : true)
				$scope.showPlanDebbuggerSwitch=true; // Show debug Info
			}else{
				$scope.showPlanDebbuggerSwitch=false; // DO NOT show debug Info
			}
		}

		$scope.showPlansInGeo();
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		isPlanModalOpen = false;
		$scope.searchPlanInput = '';
		if($scope.criteria.planProductCode == ''){
			$scope.isPlanSelected = false;
			selPlan = "";
		}else{
			$scope.isPlanSelected = true;
			selPlan = $scope.criteria.dummyPlanCode;
		}
		idLink = configuration.idLinkPlanPage;
		enrollmentLink = configuration.enrollmentLinkPlanPage;
		fixedPlanName ='';
		redirectUrl = '';
		externalUrl = '';
		$scope.checkedPlanCode = $scope.criteria.dummyPlanCode;
		checkedPlanBeforeClose = '';

		function createdseWSURl()
		{
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;
			var dseWSUrl = configuration.dseWSUrlPlanList + "site_id="+siteId+"&language="+lang+"&";

			if(criteria.planValFromURL == null || criteria.planValFromURL == ''){

				/* Added for Medicare project */
				if($state.params.site_id == 'medicare')
				{
					//dseWSUrl = configuration.plansListURL;
					dseWSUrl = dseWSUrl + "year="+criteria.medicare.planYear;
					dseWSUrl = dseWSUrl + "&category="+criteria.medicare.category;
					dseWSUrl = dseWSUrl + "&county="+criteria.medicare.county;
					dseWSUrl = dseWSUrl + "&state="+criteria.medicare.state;
					//if(criteria.medicare.isDebug)
					{
						//dseWSUrl = dseWSUrl + "&debug=true";//+criteria.medicare.isDebug;
					}
				}
				/* End - Added for Medicare project */
				else if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
					dseWSUrl = dseWSUrl + "postalCode="+criteria.typeAheadLocationResults.zipcode;
				}else if(criteria.typeAheadLocationResults.stateabbr != '' && criteria.typeAheadLocationResults.stateabbr != undefined){
					dseWSUrl = dseWSUrl + "state="+criteria.typeAheadLocationResults.stateabbr;
				}
			}

			var returnValue = {
					key : "DSE.WS Service",
					type : "url",
					value : dseWSUrl
			};

			return returnValue;
		};

		function fetchPlans() {
			NavSpinnerService.spin();
			PlanListService.getPlanList()
			.then(
					function success(response){

						if($scope.criteria.planProductCode == ''){
							$scope.isPlanSelected = false;
							selPlan = "";
						}else{
							$scope.isPlanSelected = true;
							selPlan = $scope.criteria.dummyPlanCode;
						}

						var listInfoExchange = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;
						// if(response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values
						// 	&& response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value){
						// 	$scope.plansDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value;
						// }

						if(!angular.isArray(listInfoExchange))
							listInfoExchange = [listInfoExchange];

						for(var i=0;i<listInfoExchange.length;i++){
							if(listInfoExchange[0].name != undefined && listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i]=='ShowAllPlansLink'){ // for prod
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}else if(listInfoExchange[0].name != undefined && listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i].$=='ShowAllPlansLink'){ // for qa
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}
							else if( listInfoExchange[0].name != undefined && listInfoExchange[0].name != undefined && listInfoExchange[0].name == 'ShowAllPlansLink'){ /* for new correct structure*/
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}
							else{
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
							}
						}
						var planList = response.data.DocfindSearchPlanList.plans;
						$scope.planCriteria.planArray = PlanListService.setPlansArr(planList);
						var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

						if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
							processDebugInfo = processDebugInfo.values.value;

							if( response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value.length != undefined
									&& response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange.values.value.length == 1 )
							{
								var dseWSURL = createdseWSURl();
								processDebugInfo = [dseWSURL];
							}
						}else{
							var disagnosticInfoFound = false;
							for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
								if(processDebugInfo[tempI].name == "DiagnosticInfo"){
									processDebugInfo = processDebugInfo[tempI].values.value;

									disagnosticInfoFound = true;
									break;
								}
							}

							if( !disagnosticInfoFound )
							{
								var dseWSURL = createdseWSURl();
								processDebugInfo = [dseWSURL];
							}
						}
						$scope.planCriteria.planDebugInfo = processDebugInfo;

						$scope.showPlansInGeo();

						NavSpinnerService.stop();
					},
					function error(response){
						$scope.planCriteria.planArray = 'ERROR';
						$scope.planCriteria.planDebugInfo = [];
						NavSpinnerService.stop();
					}
			);
		};
		// var tempFetchedRes = {};
		var isFromGeo = false;
		if(window.location.href.indexOf("providerSearchPlanList") > -1){
				// tempFetchedRes = ProviderSearchCriteriaService.getPlanResponse();
				// if(tempFetchedRes.data == undefined){
				// 		fetchPlans();
				// 	}else{
				// 		processFetchedPlans(tempFetchedRes);
				// 	}

				isFromGeo = ProviderSearchCriteriaService.getFromGeo();
				if($scope.planCriteria.planArray == undefined || $scope.planCriteria.planArray == null || $scope.planCriteria.planArray == [] || isFromGeo == false){
						fetchPlans();
					}
				ProviderSearchCriteriaService.setFromGeo(false);
		}

		function processFetchedPlans(fetchedRes) {
			var planList = fetchedRes.data.DocfindSearchPlanList.plans;
			$scope.planCriteria.planArray = PlanListService.setPlansArr(planList);

			var processDebugInfo = fetchedRes.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

			if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
				processDebugInfo = processDebugInfo.values.value;
			}else{
				for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
					if(processDebugInfo[tempI].name == "DiagnosticInfo"){
						processDebugInfo = processDebugInfo[tempI].values.value;
						break;
					}
				}
			}
			$scope.planCriteria.planDebugInfo = processDebugInfo;


		}

		$rootScope.reloadFetchPlans = function(){
			fixedPlanName ='';
			redirectUrl = '';
			externalUrl = '';
			$scope.checkedPlanCode = $scope.criteria.dummyPlanCode;
			checkedPlanBeforeClose = '';

			if($scope.criteria.planProductCode == ''){
				$scope.isPlanSelected = false;
				selPlan = "";
			}else{
				$scope.isPlanSelected = true;
				selPlan = $scope.criteria.dummyPlanCode;
			}
			fetchPlans();
		}

		$scope.skipPlanSelect= function(){
			$('.filterOptions').hide();
			$scope.planListCollapsed = true;
			$scope.criteria.planValFromURL = '';
			$scope.criteria.dummyPlanCode = '';
			$scope.checkedPlanCode = '';
			selPlan = "";
			$scope.isPlanSelected = false;
			ProviderSearchCriteriaService.setPlanProductCode(selPlan);
			ProviderSearchCriteriaService.setPlanPipeName('');
			ProviderSearchCriteriaService.setPlanName("No plan chosen | ");

			/* Setting values in $sessionStorage to avoid sporadic IE issues */
			$scope.criteria.planProductCode = selPlan;
			$scope.criteria.planPipeName = '';
			$scope.criteria.planName =  "No plan chosen | ";

			$sessionStorage.criteria.planProductCode = selPlan;
			$sessionStorage.criteria.planPipeName = '';
			$sessionStorage.criteria.planName = "No plan chosen | ";
			
			
			designatedSupressionLogic();
      suppressOtherTilesWhenEAPPlanSelection();
			/* Setting values in $sessionStorage to avoid sporadic IE issues - End */

			/*console.log( "Session  :" + $sessionStorage.criteria.planProductCode + "  " +
					+ $sessionStorage.criteria.planPipeName + "   "  +
					+ $sessionStorage.criteria.planName + "   " );

			console.log( "service  :" + $scope.criteria.planProductCode + "  " +
					+ $scope.criteria.planPipeName + "   "  +
					+ $scope.criteria.planName + "   " );*/

			if(!isPlanModalOpen){
				$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
			}else{
				isPlanModalOpen = false;
				$scope.showPlanModal=false;
				angular.element("#changePlanModal" ).hide();
				angular.element("#changePlanModal" ).addClass("fade");
				angular.element("#changePlanModal" ).removeClass("fadeIn");
				angular.element(".modal-backdrop" ).css("display","none");

				if(window.location.href.indexOf("providerDetails") > -1 ||
						window.location.href.indexOf("providerHospDetails") > -1 ||
						window.location.href.indexOf("providerOrgDetails") > -1){
					$state.go('contentPage',{"page":'providerResults',site_id:siteId,language:language});
				}
			}
			if(window.location.href.indexOf("providerResults") > -1){
				$scope.criteria=ProviderSearchCriteriaService.getCriteria();
				$rootScope.planChangeClick(true,"skip");
			}
		}

		function showDisclaimer(url){
			var disclaimerUrl = $state.href('disclaimerPage', {page: 'standardDisclaimer', storeURL: url});
			window.open(disclaimerUrl, '_blank');
		}

		$scope.reportError = function( planSearchTerm , errorMsg , errorFor ) {

			AnalyticsService.trackError({
				errorFor: errorFor,
				errorMsg: errorMsg,
				planSearchTerm: planSearchTerm,
				state: 'error'
			});

			return true;
	      };

				$scope.closeNAP=function(){
					angular.element("#napMessage" ).hide();
					angular.element("#napMessage" ).addClass("fade");
					angular.element("#napMessage" ).removeClass("fadeIn");
					angular.element(".modal-backdrop" ).css("display","none");
					setTimeout(function(){ $rootScope.focusForModal('napMessage'); }, 100);
					if(fixedPlanName.displayName != '' && fixedPlanName.displayName != undefined){
						ProviderSearchCriteriaService.setPlanProductCode(fixedPlanName.productCode);
						ProviderSearchCriteriaService.setPlanPipeName(fixedPlanName.pipeName);
						ProviderSearchCriteriaService.setPlanName(fixedPlanName.displayName);

						// console.log("ProviderSearchCriteriaService.getPlanName()" + ProviderSearchCriteriaService.getPlanName() +
						// 		" fixedPlanName.displayName " + fixedPlanName.displayName);
					}
					$scope.criteria.dummyPlanCode = selPlan;
					$scope.checkedPlanCode = selPlan;
					if(!isPlanModalOpen){
						$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
						// $state.go('provSearch');
					}else{
						isPlanModalOpen = false;
						$scope.showPlanModal=false;
						angular.element("#changePlanModal" ).hide();
						angular.element("#changePlanModal" ).addClass("fade");
						angular.element("#changePlanModal" ).removeClass("fadeIn");
						angular.element(".modal-backdrop" ).css("display","none");
						if(window.location.href.indexOf("providerDetails") > -1 ||
								window.location.href.indexOf("providerHospDetails") > -1 ||
								window.location.href.indexOf("providerOrgDetails") > -1){
							$state.go('contentPage',{"page":'providerResults',site_id:siteId,language:language});
						}
					}
					if(window.location.href.indexOf("providerResults") > -1){
						$scope.criteria=ProviderSearchCriteriaService.getCriteria();
						$rootScope.planChangeClick(true,fixedPlanName.productCode);
					}
				};

				$scope.adjustStyle=function(){
					if($scope.searchPlanInput != "" || $scope.searchPlanInput != undefined){
						//var temp=$('#mainDivList .radio-txtdiv').css( "border-bottom", "1px solid #ccc" );
					}
				};

				$scope.filterPlans=function(){
					$scope.listOfPlans=planFilter(intermediatePlans, $scope.searchPlanInput);
				}

				function planFilter(planList, searchText) {
						var searchTxt = searchText.replace(/[()\/,&#\\]/g, '');
						searchTxt = searchTxt.replace(/\b(Aetna|Plan)\b/gi, '');
						searchTxt = searchTxt.replace(/  /g,' ');
						searchTxt = searchTxt.replace(/^\s+|\s+$/gm,'');
						// console.log("replace:"+searchTxt);

						var updatedPlanListArr = [];
						var errorConditionArr = {"errorCondition":"true"};
						if(searchTxt != ""){
							// using javascript .filter() as it is much faster than for loop
							function filterByName(item) {
								var planHeaderName=item.headerName.toUpperCase().replace(/(&TRADE;|&REG;|&#8480;)/gi,'');
								var planHeaderName=item.headerName.toUpperCase().replace(/\b(Aetna|Plan)\b/gi, '');
								planHeaderName=planHeaderName.replace(/[()\/,&#\\]/g, '');
								planHeaderName = planHeaderName.replace(/  /g,' ');
								planHeaderName = planHeaderName.replace(/^\s+|\s+$/gm,'');

								var planDisplayName=item.displayName.toUpperCase().replace(/(&TRADE;|&REG;|&#8480;)/gi,'');
								var planDisplayName=item.displayName.toUpperCase().replace(/\b(Aetna|Plan)\b/gi, '');
								planDisplayName=planDisplayName.replace(/[()\/,&#\\]/g, '');
								planDisplayName = planDisplayName.replace(/  /g,' ');
								planDisplayName = planDisplayName.replace(/^\s+|\s+$/gm,'');

								if(planDisplayName.contains(searchTxt.toUpperCase()) || planHeaderName.contains(searchTxt.toUpperCase())){
									return true;
								}
								else{
									return false;
								}
							}
							updatedPlanListArr = planList.filter(filterByName);
						}else{
								updatedPlanListArr = planList;
						}

						if(updatedPlanListArr.length == 0){
							updatedPlanListArr = errorConditionArr;
						}
						return updatedPlanListArr;
				};

				function detectIE() {
		 		    var ua = window.navigator.userAgent;

		 		    var msie = ua.indexOf('MSIE ');
		 		    if (msie > 0) {
		 		        // IE 10 or older => return version number
		 		        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		 		    }

		 		    var trident = ua.indexOf('Trident/');
		 		    if (trident > 0) {
		 		        // IE 11 => return version number
		 		        var rv = ua.indexOf('rv:');
		 		        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		 		    }

		 		    var edge = ua.indexOf('Edge/');
		 		    if (edge > 0) {
		 		       // Edge (IE 12+) => return version number
		 		       return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
		 		    }

		 		    // other browser
		 		    return false;
		 		}



		$scope.continueWithPlan= function(){

			var isInformationalPage = false;
			var newRedirectURL = '';
			$('.filterOptions').hide();
			$scope.planListCollapsed = true;
			AnalyticsService.trackForm({
				name: 'plan selection',
				plan:fixedPlanName.displayName,
				productCode:fixedPlanName.productCode,
				pipeName: fixedPlanName.pipeName,
				site_id: siteId,
				searchBoxTerm: $scope.searchPlanInput,
				state: 'completed'
			});
			if(fixedPlanName.redirectUrl != null && fixedPlanName.redirectUrl != ''){

				if(fixedPlanName.redirectUrl.contains("<INFO>_")){
					isInformationalPage = true;
					newRedirectURL = fixedPlanName.redirectUrl;
					newRedirectURL = newRedirectURL.replace(/(<INFO>_)/gi, '');
					fixedPlanName.redirectUrl = newRedirectURL;
				}
				else {
					isInformationalPage = false;
				}

				if(fixedPlanName.externalUrl != null && fixedPlanName.externalUrl === 'YES'){
					showDisclaimer(fixedPlanName.redirectUrl);
					//showDisclaimer($scope.redirectUrl,'standard',null)
				}
				else{
					if(fixedPlanName.productCode == "NAPDS"){
						angular.element("#napMessage").show();
						setTimeout(function(){ $rootScope.focusForModal('napMessage'); }, 100);
						angular.element("#napMessage").css("display", "block");
						angular.element("#napMessage").addClass("fadeIn");
						angular.element("#napMessage").removeClass("fade");
						if(!isPlanModalOpen){
							angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
						}
						designatedSupressionLogic(fixedPlanName.productCode);
            suppressOtherTilesWhenEAPPlanSelection(fixedPlanName.productCode);
						return;
					}else{
						$window.open(fixedPlanName.redirectUrl, "_blank");
					}
				//$window.open($scope.fixedPlanName.redirectUrl, "_blank");
				//ProviderResultsService.openURL($scope.redirectUrl);
				}
			}

			/*var isIE = detectIE();

			if( isIE )
			{
				$scope.$apply();
			}*/

			if(fixedPlanName.redirectUrl != null && fixedPlanName.redirectUrl != '' && !isInformationalPage){
				//do nothing
				designatedSupressionLogic(fixedPlanName.productCode);
        
        suppressOtherTilesWhenEAPPlanSelection(fixedPlanName.productCode);

			}
			else {

				if(fixedPlanName.displayName != '' && fixedPlanName.displayName != undefined){
					ProviderSearchCriteriaService.setPlanProductCode(fixedPlanName.productCode);
					ProviderSearchCriteriaService.setPlanPipeName(fixedPlanName.pipeName);
					ProviderSearchCriteriaService.setPlanName(fixedPlanName.displayName);

					/* Plan selected but still does not show up on UI fix :
					 * Although the ProviderSearchCriteriaService criteria object is set above, the UI need $scope.criteria and
					 * $sessionStorage.criteria for various flows and purpose due to the way these variables have been used.
					 * Also ProviderSearchCriteriaService.setCriteria(); was added to update the $sessionStorage.criteria
					 * BUt the ProviderSearchCriteriaService.criteria does not get updated in IE causing issues.
					 * Spo explicitly setting both  $scope.criteria and $sessionStorage.criteria below. */
					$scope.criteria.planProductCode = fixedPlanName.productCode;
					$scope.criteria.planName = fixedPlanName.displayName;
					$scope.criteria.planPipeName = fixedPlanName.pipeName;
					$scope.criteria.pinDisplay=fixedPlanName.pinDisplay;
					
					$sessionStorage.criteria.planProductCode = fixedPlanName.productCode;
					$sessionStorage.criteria.planName = fixedPlanName.displayName;
					$sessionStorage.criteria.planPipeName = fixedPlanName.pipeName;
					designatedSupressionLogic(fixedPlanName.productCode);
					
					suppressOtherTilesWhenEAPPlanSelection(fixedPlanName.productCode);
					// console.log("2 . ProviderSearchCriteriaService.getPlanName()" + ProviderSearchCriteriaService.getPlanName() +
					// 		" fixedPlanName.displayName " + fixedPlanName.displayName);

	      			/*console.log($scope.fixedPlanName.productCode + " Continue with Plan " + JSON.stringify(ProviderSearchCriteriaService.getCriteria()));*/

	      			/* Commenting for now since the variable $sessionStorage.criteria gets update above. */
	      			//ProviderSearchCriteriaService.setCriteria();

	      			// console.log(" SessionStorage " + $sessionStorage.criteria.planProductCode
	      			// 		+ "   " + JSON.stringify($sessionStorage.criteria.planName)
	      			// 		);
	      			/* End : Plan selected but still does not show up on UI fix */
				}
				$scope.criteria.dummyPlanCode = selPlan;
				$scope.checkedPlanCode = selPlan;

				if(!isPlanModalOpen){
					$state.go('contentPage',{"page":'providerSearch',site_id:siteId,language:language});
					// $state.go('provSearch');
				}else{
					isPlanModalOpen = false;
					$scope.showPlanModal=false;
					angular.element("#changePlanModal" ).hide();
					angular.element("#changePlanModal" ).addClass("fade");
					angular.element("#changePlanModal" ).removeClass("fadeIn");
					angular.element(".modal-backdrop" ).css("display","none");

					if(window.location.href.indexOf("providerDetails") > -1 ||
							window.location.href.indexOf("providerHospDetails") > -1 ||
							window.location.href.indexOf("providerOrgDetails") > -1){
								if($state.params.page == "providerHospDetails" && ProviderResultsService.getHospitalId() != ''){
									//ACNLA5_0603 code changes start
									//$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:'', hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
									if($state.params.parameters === "disbaleChangeLocation"){
									     	$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:$state.params.parameters, hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
									}else{
									     	$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:'', hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
									}
									//ACNLA5_0603 code changes end
								}else{
									//ACNLA5_0603 code changes start
									//$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:''});
									if($state.params.parameters === "disbaleChangeLocation"){
										$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:$state.params.parameters});
									}else{
										$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:''});
									}
									//ACNLA5_0603 code changes end
								}
						// $state.go('contentPage',{"page":'providerResults',site_id:siteId,language:language});
					}
				}
				if(window.location.href.indexOf("providerResults") > -1){
					$scope.criteria=ProviderSearchCriteriaService.getCriteria();
					$rootScope.planChangeClick(true,fixedPlanName.productCode);
				}
			}
		};

		$scope.adjustStyle=function(){
			if($scope.searchPlanInput != "" || $scope.searchPlanInput != undefined){
				//var temp=$('#mainDivList .radio-txtdiv').css( "border-bottom", "1px solid #ccc" );
			}
		}

		// what to do if user clicks on Change Location
		$scope.changePlanClick = function() {
			if($scope.criteria.siteId=="medicare"){
				$scope.criteria.dummyPlanCode = "";
				$scope.criteria.medicare.medOrDen = -1;
				$scope.criteria.medicare.fixedPlanName = "";
				$scope.criteria.planProductCode = "";
				$state.go('contentPage',{"page":'providerSearchPlanList',site_id:siteId,language:language});


			}else{
					$scope.showPlanModal=true;
					$scope.isPlanSelected = false;
					$scope.criteria.planValFromURL = '';
					fetchPlans();
					isPlanModalOpen = true;
					//$scope.searchPlanInput = '';
					angular.element("#changePlanModal" ).show();
					setTimeout(function(){ $rootScope.focusForModal('changePlanModal'); }, 100);
					angular.element("#changePlanModal" ).css("display","block");
					angular.element("#changePlanModal" ).addClass("fadeIn");
					angular.element("#changePlanModal" ).removeClass("fade");
					angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
				}
			};

		$scope.closeChangePlanModal = function() {
			$scope.checkedPlanCode = $scope.criteria.dummyPlanCode;
			$scope.planListCollapsed = true;
			isPlanModalOpen = false;
			fixedPlanName = '';
			redirectUrl = '';
			externalUrl = '';
			if($scope.criteria.planProductCode == ''){
				$scope.isPlanSelected = false;
				selPlan = "";
			}else{
				$scope.isPlanSelected = true;
				selPlan = $scope.criteria.dummyPlanCode;
			}
			$scope.showPlanModal=false;
			angular.element("#changePlanModal" ).hide();
			angular.element("#changePlanModal" ).addClass("fade");
			angular.element("#changePlanModal" ).removeClass("fadeIn");
			angular.element(".modal-backdrop" ).css("display","none");
		};

		$scope.setPlan = function(selectedPlan, pId){
			$scope.checkedPlanCode = pId;
			$scope.isPlanSelected = true;
			fixedPlanName = selectedPlan;
			redirectUrl = selectedPlan.redirectUrl;
			redirectUrl = redirectUrl.replace(/(<INFO>_)/gi, '');
			externalUrl = selectedPlan.externalUrl;
			selPlan = pId;
		};

	}

	angular.module('nav-ui').directive('a', ['AnalyticsService', function( AnalyticsService ) {

		function link(scope, element, attrs) {
			element.on('click', function(e) {
				AnalyticsService.trackAnchorLinks({
					linkText: this.innerText,
					linkUrl: this.href,
					anchorTagID : this.id,
					event: 'click'
				});
			});
		}

		return {
			restrict: 'E',
			link: link

		};
	}]);

})();

},{}],13:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.controller('ProviderDetailsController', ProviderDetailsController);

	ProviderDetailsController.$inject = ['$scope', '$http', 'configuration','ProviderResultsService',
	'$sessionStorage','ProviderSearchCriteriaService','$q','$log','$filter','$state','usSpinnerService',
	'phoneFormatFilter','$location','$window','$anchorScroll','$translate','$rootScope',
	'NavSpinnerService','ReviewsService','PdfService', 'PlanListService', 'mapsService','LanguageDataService'];

	function ProviderDetailsController($scope, $http, configuration, ProviderResultsService,$sessionStorage,
		ProviderSearchCriteriaService,$q,$log,$filter,$state,usSpinnerService,phoneFormatFilter,$location,$window,
		$anchorScroll,$translate,$rootScope,NavSpinnerService, ReviewsService, PdfService, PlanListService, mapsService,LanguageDataService) {
			$rootScope.$on("destroyScope", function(){
				 $scope.$destroy();
			});
		
		/* Page Title*/
		if ( window.location.href.indexOf("providerDetails") != -1 ||
		  	window.location.href.indexOf("providerOrgDetails") != -1 || 
		   	window.location.href.indexOf("providerHospDetails") != -1 ){
			document.title =  "Provider Details";
		}
					
		$scope.differentLocations=1;
		var page=$state.params.page;
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();


		$scope.languageData = LanguageDataService.getLanguageData();
		$scope.diagnosticInfoPresent = false;


		
		$scope.reportIncorrectInfo = configuration.reportIncorrectInfo;
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		var vLocId = $state.params.locId;
		var vProId = $state.params.proId;
		if(vLocId == undefined || vLocId == '' || vLocId == null){
			vLocId = $scope.criteria.pleatLocId;
		}
		if(vProId == undefined || vProId == '' || vProId == null){
				vProId = $scope.criteria.pleatProId;
		}
			
		$scope.PNIPleatRole = false;
		$scope.PNIPleatProviderId = false;
		$scope.showHandicapAccess = false;
		$scope.isPlanAvailable = false;
		$scope.isPlanAPICall = false;
		$scope.isReadMore = false;
		$scope.referralInd = false;
		$scope.isShowDebugInfo = false;
		
		$scope.mixBHProvider = false;
		$scope.mixBHProviderDescription = "";

		var displayProviderMap=false;
		if($scope.criteria.planProductCode == ''){
				$scope.isPlanSkipped = true;
		}else{
				$scope.isPlanSkipped = false;
		}
		//below code to be uncommented when params for details page to be added in see accepted plan links
		// if(($state.params.proId == '' || $state.params.proId == undefined || $state.params.proId == null) &&
		// 		 ($state.params.hosId == '' || $state.params.hosId == undefined || $state.params.hosId == null) &&
		// 			 ($state.params.proOrgDispName == '' || $state.params.proOrgDispName == undefined || $state.params.proOrgDispName == null)
		// 				&& (criteria.typeAheadLocationResults.label=='' || criteria.typeAheadLocationResults.label ==null || criteria.typeAheadLocationResults.label == undefined)){
		// 	return $state.go('contentPage',{page:'providerSearchGeo',parameters:''});
		// }
		//below code to be removed when appropriate checks added
		// if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
		// 	//$location.path("/contentPage?page=providerSearchLanding&site_id=dse&language=en");
		// 	$location.path('/contentPage').search({page: 'providerSearchLanding',site_id:'dse',language:'en'});
		// 	return;
		// 	// 	return $state.go('contentPage',{page:'providerSearchLanding',parameters:'',site_id:siteId,language:language});
		// } //
		var currentProvider = {};
		if($state.params.proId == '' || $state.params.proId == undefined){
		}else{
				currentProvider.providerInformation = {};
				currentProvider.providerInformation.providerIdentifier = {};
				currentProvider.providerInformation.providerIdentifier.idValue = $state.params.proId;
				currentProvider.providerInformation.providerID = $state.params.proId;
				currentProvider.providerInformation.type = $state.params.pType;
				currentProvider.providerLocations = [];
				currentProvider.providerLocations[0] = {};
				currentProvider.providerLocations[0].locationID = $state.params.locId;
				currentProvider.providerLocations[0].address = {};
				currentProvider.providerLocations[0].address.distance = $state.params.distance;
				if(!ProviderSearchCriteriaService.getPlanPleatShow()){
					ProviderResultsService.setProvider(currentProvider);
				}
		}


		$scope.groupIPACount = 2;
		$scope.showDebbugger=false;
		$scope.setClass=false;
		$scope.setGrpIPAClass=false;
		$scope.displayIPACount = 0;
		$scope.showFlag=false;
		$scope.collapse=true;
		$scope.showPrintDirectory=true;
		$scope.reportIncorrectInfo = configuration.reportIncorrectInfo;
		$scope.printDirectoryURL = configuration.printDirectoryURL;
		if($scope.languageData.SWITCH_DISPLAY_RIP == 'NONE'){
			$scope.reportIncorrectInfoLink=false;
		}else {
			$scope.reportIncorrectInfoLink=true;
		}$scope.isCollapsedOne = true;$scope.isCollapsedTwo = true;$scope.isCollapsedThree = true;$scope.isCollapsedFour = true;$scope.isCollapsedFive = true;$scope.isCollapsedSix = true;$scope.isCollapsedSeven = true;
		$scope.domainUrl=configuration.domainUrl;
		$scope.officeHoursRows = "";

		$scope.providerDetailsPleatTracker={};
		$scope.providerDetailsPleatTracker.isCollapsedOne=true;
		$scope.providerDetailsPleatTracker.isCollapsedTwo = true;
		$scope.providerDetailsPleatTracker.isCollapsedThree = true;
		$scope.providerDetailsPleatTracker.isCollapsedFour = true;
		$scope.providerDetailsPleatTracker.isCollapsedFive = true;
		$scope.providerDetailsPleatTracker.isCollapsedSix = true;
		$scope.providerDetailsPleatTracker.isCollapsedSeven = true;
		$scope.providerDetailsPleatTracker.isCollapsedOtherOffice =true;
		$scope.providerDetailsPleatTracker.isBehaviouralCollapsed = true;
		$scope.providerDetailsPleatTracker.isCollapsedPlanDetails = true;
		$scope.providerDetailsPleatTracker.isCollapsedReleventPlans = false;
		
		if($scope.languageData.SWITCH_DEFAULT_EXPAND_NONRELEVENT_PNI_SECTION == 'ON'){
			$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = false;
		}else {
			$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = true;
		}
		
		//below line added as marging was not applying to the bottom content
		//$('#otherUsefulResourceCont').css('margin-bottom', '70px');
		
		$scope.serviceCallingFailed = false;


		if (window.location.href.indexOf("providerDetails") != -1){
			$( "#provider-srch" ).addClass( "dateFix" );
			$scope.pageType = "I";
		}
		if (window.location.href.indexOf("providerHospDetails") != -1){
			$( "#provider-srch" ).addClass( "dateFix" );
			$scope.pageType = "H";
		}
		if (window.location.href.indexOf("providerOrgDetails") != -1){
			$( "#provider-srch" ).addClass( "dateFix" );
			$scope.pageType = "O";
		}

		$scope.$on("$stateChangeSuccess", function (event, toState, toParams, fromState, fromParams){
			if(toParams && toParams.page == 'providerResults'){
				$scope.criteria.isResetFilter = true;
				// console.log("resetfilter on if"+ $scope.criteria.isResetFilter);
			} else {
				$scope.criteria.isResetFilter = false;
				// console.log("resetfilter on else"+ $scope.criteria.isResetFilter);
			}
			if((fromParams.page=="providerDetails" && toParams.page=="providerResults") || (fromParams.page=="providerHospDetails" && toParams.page=="providerResults") || (fromParams.page=="providerOrgDetails" && toParams.page=="providerResults")){
				$sessionStorage.pinFromDetails=true;
			}
    });
		$scope.readMore=function(){
			$scope.isReadMore = true;
		};

		$scope.readLess=function(){
			$scope.isReadMore = false;
		};
		$scope.toggle = function(value){
				if(value=='Collapse'){
						$scope.collapse=true;
					$scope.providerDetailsPleatTracker.isCollapsedOne = true;
					$scope.providerDetailsPleatTracker.isCollapsedTwo = true;
					$scope.providerDetailsPleatTracker.isCollapsedThree = true;
					$scope.providerDetailsPleatTracker.isCollapsedFour = true;
					$scope.providerDetailsPleatTracker.isCollapsedFive = true;
					$scope.providerDetailsPleatTracker.isCollapsedSix = true;
					$scope.providerDetailsPleatTracker.isCollapsedSeven = true;
					$scope.providerDetailsPleatTracker.isCollapsedOtherOffice =true;
					$scope.providerDetailsPleatTracker.isBehaviouralCollapsed = true;
					$scope.providerDetailsPleatTracker.isCollapsedPlanDetails = true;
					$scope.providerDetailsPleatTracker.isCollapsedReleventPlans = false;
					if($scope.languageData.SWITCH_DEFAULT_EXPAND_NONRELEVENT_PNI_SECTION == 'ON'){
						$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = false;
					}else {
						$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = true;
					}
				}
				else if(value=='Expand'){
					$scope.collapse=false;
					$scope.providerDetailsPleatTracker.isCollapsedOne = false;
					$scope.providerDetailsPleatTracker.isCollapsedTwo = false;
					$scope.providerDetailsPleatTracker.isCollapsedThree = false;
					$scope.providerDetailsPleatTracker.isCollapsedFour = false;
					$scope.providerDetailsPleatTracker.isCollapsedFive = false;
					$scope.providerDetailsPleatTracker.isCollapsedSix = false;
					$scope.providerDetailsPleatTracker.isCollapsedSeven = false;
					$scope.providerDetailsPleatTracker.isCollapsedOtherOffice =false;
					$scope.providerDetailsPleatTracker.isBehaviouralCollapsed = false;
					$scope.providerDetailsPleatTracker.isCollapsedPlanDetails = false;
					$scope.providerDetailsPleatTracker.isCollapsedReleventPlans = false;
					if($scope.languageData.SWITCH_DEFAULT_EXPAND_NONRELEVENT_PNI_SECTION == 'ON'){
						$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = false;
					}else {
						$scope.providerDetailsPleatTracker.isCollapsedNonReleventPlans = true;
					}

					var pType = $state.params.pType;
					if(pType != null && pType != undefined && pType == 'Individual'){
						$scope.otherOfficeLocation();
					}

					if($scope.selectedPlan == undefined && $scope.releventPlans == undefined && $scope.nonReleventPlans == undefined){
								fetchAndSetPlanPleatInfo(vProId, vLocId);
					}

					/*var providerType = ProviderResultsService.getProviderType();
					if(providerType == undefined || providerType == null || providerType == ''){
						providerType = $scope.criteria.provType;
					}
					if(providerType != null && providerType != undefined && providerType == 'Individual')
						$scope.otherOfficeLocation();*/
				}
		};
		$scope.handleBtnKeyPressExpand=function(event) {
			  // Check to see if space or enter were pressed
			  if (event.key === " " || event.key === "Enter") {
			    // Prevent the default action to stop scrolling when space is pressed
			    event.preventDefault();
			    $scope.toggle('Expand');
			    var pressed = (event.target.getAttribute("aria-pressed") === "true");
			    element.setAttribute("aria-pressed", !pressed);

			  }
			};
			$scope.handleBtnKeyPressCollapse=function(event) {
				  // Check to see if space or enter were pressed
				  if (event.key === " " || event.key === "Enter") {
				    // Prevent the default action to stop scrolling when space is pressed
				    event.preventDefault();
				    $scope.toggle('Collapse');
				    var pressed = (event.target.getAttribute("aria-pressed") === "false");
				    element.setAttribute("aria-pressed", !pressed);

				  }
				};

		// toggle language between English and Spanish or use specified language
		$scope.changeLanguage = function(lang) {
			if (lang == null || lang == undefined) {
				var lang = $translate.use();
				lang = lang == 'en' ? 'es' : 'en';
			}

			// start over on the search page when switching languages
			// $state.go('contentPage',{page:'providerSearch',language:lang});
		};

		$scope.changeShowDebbugger=function(){
			$scope.showDebbugger=!$scope.showDebbugger;
		};
		$scope.navigatePCP=function(provider){
			if(provider.displayPCPEligibility.displayPrimaryCareDentistLink=='true'){
				// $state.go('contentPage',{page:'changePCD'});
			}
			else{
				// $state.go('contentPage',{page:'changePCP'});
			}
		};
		//$scope.providerDet = {};
		$scope.provider={};
		//$scope.provider = ProviderResultsService.getProvider();

		// set the classes to produce the stars for 10 levels of accuracy
		var starClassNames = ["neg","neg","posneg","posneg","posneg","posneg","posneg","posneg","pos","pos"];

		ReviewsService.setStarClassNames(starClassNames);

		// expose ratings and reviews functionality from the reviews service
		$scope.reviewStatus = ReviewsService.reviewStatus;
		$scope.getRating = ReviewsService.getRating;
		$scope.getAverageStarClass = ReviewsService.getAverageStarClass;
		$scope.getSpecificStarClass = ReviewsService.getSpecificStarClass;
		$scope.getNumberOfRatings = ReviewsService.getNumberOfRatings;
		$scope.getNumberOfReviews = ReviewsService.getNumberOfReviews;
		$scope.getNumberOfAvailableReviews = ReviewsService.getNumberOfAvailableReviews;
		$scope.getReviewDate = ReviewsService.getReviewDate;
		$scope.getReviewRating = ReviewsService.getReviewRating;
		$scope.getReviewText = ReviewsService.getReviewText;
		$scope.getReviewSiteName = ReviewsService.getReviewSiteName;
		$scope.getReviewSiteURL = ReviewsService.getReviewSiteURL;
		$scope.getReviewData = ReviewsService.getReviewData;

		fetchProviderDetails();
		var hospLength = 0;
		var groupLength = 0;

		function fetchAndSetPlanPleatInfo(currProId, currLocId) {
			PlanListService.getPlanPleatList(currProId, currLocId)
			.then(
					function success(response){

						$scope.isPlanAPICall = true;
						$scope.isPlanAvailable = false;
						
						if(response=="Status code not 200"){
							$scope.serviceCallingFailed = true;
							return;
						}

						var isRelP = false;
						var isNonRelP = false;
							$scope.AllPlansInfo = response.data.providerPlanandNetworkDetailsResponse.ReadPlanandNetworkDetailsResponse.planandNetworkInformationList.planInformation;
							$scope.plansListInfoExchange = response.data.providerPlanandNetworkDetailsResponse.ReadPlanandNetworkDetailsResponse;

							if($scope.plansListInfoExchange.listInfoExchanges.listInfoExchange.length != 0){
								for(var iterDiagno=0; iterDiagno<$scope.plansListInfoExchange.listInfoExchanges.listInfoExchange.length; iterDiagno++){
									if($scope.plansListInfoExchange.listInfoExchanges.listInfoExchange[iterDiagno].name == "DiagnosticInfo"){
										$scope.diagnosticInfoPresent = true;
										break;
									}
								}
							}
							
							//Show plan pleat debug option
							$scope.whetherToShowDebug = false;
							$scope.whetherToShowDebug = checkIfToShowPlanPleatDebug(); // Check if to show planPleat debug Info
							
							$scope.oldStructure = true;
							
							for(var x = 0; x<$scope.AllPlansInfo.length; x++){
								if($scope.AllPlansInfo[x].groupName != undefined){
									$scope.oldStructure = false;
									break;
								}
							}

							$scope.releventPlans = [];
							$scope.nonReleventPlans = [];

							for(var x = 0; x<$scope.AllPlansInfo.length; x++){
									if($scope.AllPlansInfo[x].planCategory == "Selected Plan"){
											$scope.selectedPlan = $scope.AllPlansInfo[x].planandNetworkInformationDetails[0];
											$scope.isPlanAvailable = true;

											// Below code is to resturcture and add the groupname for selected plan
											if($scope.AllPlansInfo[x].groupName != undefined){
												$scope.selectedPlan.groupName = $scope.AllPlansInfo[x].groupName;
											}
											// Below code is to resturcture and add the subGroupName for selected plan
											if($scope.AllPlansInfo[x].subGroupName != undefined){
												$scope.selectedPlan.subGroupName = $scope.AllPlansInfo[x].subGroupName;
											}

									}
									if($scope.AllPlansInfo[x].planCategory == "Relevant Plans"){
											if($scope.oldStructure == false){
												$scope.releventPlans.push($scope.AllPlansInfo[x]);
											}else{
												$scope.releventPlans = $scope.AllPlansInfo[x].planandNetworkInformationDetails;
											}
											$scope.isPlanAvailable = true;
											isRelP = true;
									}
									if($scope.AllPlansInfo[x].planCategory == "Non relevant Plans"){
											if($scope.oldStructure == false){
												$scope.nonReleventPlans.push($scope.AllPlansInfo[x]);
											}else{
												$scope.nonReleventPlans = $scope.AllPlansInfo[x].planandNetworkInformationDetails;
											}
											$scope.isPlanAvailable = true;
											isNonRelP = true;
									}
							}
											
							
							if(isRelP == true)
							{
									if($scope.oldStructure == false){

											// Below loop is to restructure the new structure of Planpleat response for Mobile view  - Relevent Plans
											$scope.releventPlansMob = [];
											for(var relI = 0; relI < $scope.releventPlans.length; relI++){
												for (var relIJ = 0; relIJ < $scope.releventPlans[relI].planandNetworkInformationDetails.length; relIJ++) {
														var tempRel = {};
														tempRel.groupName = $scope.releventPlans[relI].groupName;
														if($scope.releventPlans[relI].subGroupName != undefined){
															tempRel.subGroupName = $scope.releventPlans[relI].subGroupName;
														}														
														tempRel.planDetail = $scope.releventPlans[relI].planandNetworkInformationDetails[relIJ].planDetail;
														tempRel.planandNetworkInformationDetail = $scope.releventPlans[relI].planandNetworkInformationDetails[relIJ].planandNetworkInformationDetail;
														$scope.releventPlansMob.push(tempRel);
												}
											}

											for(var y = 0; y<$scope.releventPlansMob.length; y++){
												if( $scope.releventPlansMob[y].planandNetworkInformationDetail != undefined &&
												   $scope.releventPlansMob[y].planandNetworkInformationDetail.participatingNetworks != undefined &&
												   $scope.releventPlansMob[y].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole != undefined &&
														$scope.releventPlansMob[y].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != "NONE"
																		&& $scope.releventPlansMob[y].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != undefined)
												{
															$scope.PNIPleatRole = true;
												}
												if($scope.releventPlansMob[y].planandNetworkInformationDetail != undefined && 
														$scope.releventPlansMob[y].planandNetworkInformationDetail.providerID != undefined)
												{
															$scope.PNIPleatProviderId = true;
												}
											}

									}else{
											for(var y = 0; y<$scope.releventPlans.length; y++){
												if($scope.releventPlans[y].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != "NONE"
																		&& $scope.releventPlans[y].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != undefined)
												{
															$scope.PNIPleatRole = true;
												}
												if($scope.releventPlans[y].planandNetworkInformationDetail.providerID != undefined)
												{
															$scope.PNIPleatProviderId = true;
												}
											}
									}
							}else{
								$scope.releventPlans = undefined;
							}
							if(isNonRelP == true)
							{
								if($scope.oldStructure == false){	
									
										// Below loop is to restructure the new structure of Planpleat response for Mobile view  - Non Relevent Plans
										$scope.nonReleventPlansMob = [];
										for(var nonRelI = 0; nonRelI < $scope.nonReleventPlans.length; nonRelI++){
											for (var nonRelIJ = 0; nonRelIJ < $scope.nonReleventPlans[nonRelI].planandNetworkInformationDetails.length; nonRelIJ++) {
													var tempRel = {};
													tempRel.groupName = $scope.nonReleventPlans[nonRelI].groupName;
													if($scope.nonReleventPlans[nonRelI].subGroupName != undefined){
														tempRel.subGroupName = $scope.nonReleventPlans[nonRelI].subGroupName;
													}														
													tempRel.planDetail = $scope.nonReleventPlans[nonRelI].planandNetworkInformationDetails[nonRelIJ].planDetail;
													tempRel.planandNetworkInformationDetail = $scope.nonReleventPlans[nonRelI].planandNetworkInformationDetails[nonRelIJ].planandNetworkInformationDetail;
													$scope.nonReleventPlansMob.push(tempRel);
											}
										}

										for(var z = 0; z<$scope.nonReleventPlansMob.length; z++){
											if($scope.nonReleventPlansMob[z].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != "NONE"
																	&& $scope.nonReleventPlansMob[z].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != undefined)
											{
													$scope.PNIPleatRole = true;
											}
											if($scope.nonReleventPlansMob[z].planandNetworkInformationDetail.providerID != undefined)
											{
														$scope.PNIPleatProviderId = true;
											}
										}

								}else{													
										for(var z = 0; z<$scope.nonReleventPlans.length; z++){
											if($scope.nonReleventPlans[z].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != "NONE"
																	&& $scope.nonReleventPlans[z].planandNetworkInformationDetail.participatingNetworks.providerNetworkRole.description != undefined)
											{
													$scope.PNIPleatRole = true;
											}
											if($scope.nonReleventPlans[z].planandNetworkInformationDetail.providerID != undefined)
											{
														$scope.PNIPleatProviderId = true;
											}
										}
								}
							}else{
								$scope.nonReleventPlans = undefined;
							}
							
					},
					function error(response){
						$scope.isPlanAPICall = true;
						console.log(response);
						if(response=="Status code not 200"){
							$scope.serviceCallingFailed = true;
							return;
						}
					}
			);
		};


		function fetchProviderDetails(){
			ProviderResultsService.setCurrentPage(page);
			//Start the spinner when we are fetching results.

			//NavSpinnerService.spin();
			// ProviderResultsService.getProviderDetails($scope.providerDetailsURL)
			ProviderResultsService.getProviderDetails()
			.then(
				function success(result) {
					//Start the spinner when we are fetching results.

					NavSpinnerService.stop();
					$scope.provider = result.providerResponse.readProviderResponse;
					
					// ------------------------------- Debug  Safari Issues <start>------------------------------------	
					// alert("Called Service");
					// alert($scope.provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull);	
					// ------------------------------- Debug  Safari Issues <start>------------------------------------

					if($scope.provider.listInfoExchanges){
						fetchFauxRows();
					}
					if($scope.provider && $scope.provider.providerDetailsResponse
						&& $scope.provider.providerDetailsResponse.individualProviderDetails
						&& $scope.provider.providerDetailsResponse.individualProviderDetails.associatedHospitals) {
						hospLength = $scope.provider.providerDetailsResponse.individualProviderDetails.associatedHospitals;
						hospLength = Object.keys(hospLength).length;
					}

					var IPAsGroupsSplit = [];
					var IPAsGroupsSeparators = ['_CAP_OFFICE_SEPARATOR_','_SPECIALTIES_SEPARATOR_'];

					//
					if(window.location.href.indexOf("page=providerDetails") > -1){
						if($state.params.distance){
							$scope.distance = $state.params.distance;
						}else if($scope.provider.providerDetailsResponse.individualProviderDetails &&
								$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0] &&
								$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address){
							$scope.distance = $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.distance;
						}
											if($scope.provider && $scope.provider.providerDetailsResponse
												&& $scope.provider.providerDetailsResponse.individualProviderDetails
												&& $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups
												&& $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups) {
												if($scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups.length != 0 && $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups[0].providerDisplayName == undefined){
															$scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups = [];
												}else{
																				var tempAssociatedGroups = $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups;
																				if(tempAssociatedGroups != undefined && (tempAssociatedGroups != null || tempAssociatedGroups.length)){
																						 tempAssociatedGroups = $filter('toArray')(tempAssociatedGroups);
																					   if(tempAssociatedGroups.length != undefined){
																									for(var x=0;x<tempAssociatedGroups.length;x++){
												 															 IPAsGroupsSplit = tempAssociatedGroups[x].providerDisplayName.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																											 if(tempAssociatedGroups[x].providerDisplayName.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																												  tempAssociatedGroups[x].providerDisplayName.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
												 															 			tempAssociatedGroups[x].capId = IPAsGroupsSplit[1];
										 																	 		  tempAssociatedGroups[x].providerSpecialties = IPAsGroupsSplit[2];
									 																				 $scope.provider.providerDetailsResponse.individualProviderDetails.capOfficeID = '';
									 																				 $scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
									 																				 
									 																				$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = false;
									 																			 	
									 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
									 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
									 																			 	 {
									 																			 		$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = true;
									 																			 	 }
																											 }else if(tempAssociatedGroups[x].providerDisplayName.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																											 		 tempAssociatedGroups[x].providerSpecialties = IPAsGroupsSplit[1];
																											 }else if(tempAssociatedGroups[x].providerDisplayName.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																											 		 tempAssociatedGroups[x].capId = IPAsGroupsSplit[1];
																													 $scope.provider.providerDetailsResponse.individualProviderDetails.capOfficeID = '';
																													 $scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
																													 
																													 $scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = false;
										 																			 	
									 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
									 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
									 																			 	 {
									 																			 		$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = true;
									 																			 	 }
																											 }
												 															 tempAssociatedGroups[x].providerDisplayName.full = IPAsGroupsSplit[0];
																									}
																									$scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups = tempAssociatedGroups;
																						 }
																				}
												}
												groupLength = $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups;
												groupLength = Object.keys(groupLength).length;
											}
											if($scope.provider && $scope.provider.providerDetailsResponse
												&& $scope.provider.providerDetailsResponse.individualProviderDetails
												&& $scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations) {
												if($scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations.length != 0 &&
													 $scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations[0].providerOrganization){
									 						if($scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations[0].providerOrganization.name == undefined){
									 									$scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations = [];
									 						}else{
																		var tempAssociatedOrgs = $scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations;

																		if(tempAssociatedOrgs != undefined && (tempAssociatedOrgs != null || tempAssociatedOrgs.length)){
																				 tempAssociatedOrgs = $filter('toArray')(tempAssociatedOrgs);
																			   if(tempAssociatedOrgs.length != undefined){
																							for(var x=0;x<tempAssociatedOrgs.length;x++){
										 															 IPAsGroupsSplit = tempAssociatedOrgs[x].providerOrganization.name.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																									 if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																									 	  tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																									 		tempAssociatedOrgs[x].providerOrganization.capId = IPAsGroupsSplit[1];
																									 		tempAssociatedOrgs[x].providerOrganization.providerSpecialties = IPAsGroupsSplit[2];
						 																				 $scope.provider.providerDetailsResponse.individualProviderDetails.capOfficeID = '';
						 																				$scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
						 																				
						 																				$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = false;
						 																			 	
						 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
						 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
						 																			 	 {
						 																			 		$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = true;
						 																			 	 }
																									 }else if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																									 	 tempAssociatedOrgs[x].providerOrganization.providerSpecialties = IPAsGroupsSplit[1];
																									 }else if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																									 	 tempAssociatedOrgs[x].providerOrganization.capId = IPAsGroupsSplit[1];
																										 $scope.provider.providerDetailsResponse.individualProviderDetails.capOfficeID = '';
																										 $scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
																										 
																										 $scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = false;
							 																			 	
						 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
						 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
						 																			 	 {
						 																			 		$scope.provider.providerDetailsResponse.individualProviderDetails.showPINWithCAP = true;
						 																			 	 }
																									 }
																									 tempAssociatedOrgs[x].providerOrganization.name.full = IPAsGroupsSplit[0];
																							}
																							$scope.provider.providerDetailsResponse.individualProviderDetails.providerOrganizations = tempAssociatedOrgs;
																				 }
																		}

															}
												}
											}
					} else if(window.location.href.indexOf("page=providerOrgDetails") > -1){
						if($state.params.distance){
							$scope.distance = $state.params.distance;
						}else if($scope.provider.providerDetailsResponse.organizationalProviderDetails &&
								$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0] &&
								$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address &&
								$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.distance){
							$scope.distance = $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.distance;
						}
														if($scope.provider && $scope.provider.providerDetailsResponse
															&& $scope.provider.providerDetailsResponse.organizationalProviderDetails
															&& $scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups) {
															if($scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups.length != 0
																	&& $scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups[0].associatedGroup == undefined){
																		$scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups = [];
															}else{
																							// .organizationalProviderDetails.providerOrganizations["0"].providerOrganization.name.full
																							var tempAssociatedGrps = $scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups;
																							if(tempAssociatedGrps != undefined && (tempAssociatedGrps != null || tempAssociatedGrps.length)){
																									 tempAssociatedGrps = $filter('toArray')(tempAssociatedGrps);
																								   if(tempAssociatedGrps.length != undefined){
																												for(var x=0;x<tempAssociatedGrps.length;x++){
															 															 IPAsGroupsSplit = tempAssociatedGrps[x].associatedGroup.name.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																														 if(tempAssociatedGrps[x].associatedGroup.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																															  tempAssociatedGrps[x].associatedGroup.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
															 															 			tempAssociatedGrps[x].associatedGroup.capId = IPAsGroupsSplit[1];
													 																	 		  tempAssociatedGrps[x].associatedGroup.providerSpecialties = IPAsGroupsSplit[2];
												 																				 $scope.provider.providerDetailsResponse.organizationalProviderDetails.capOfficeID = '';
												 																				$scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
												 																				
												 																				$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = false;
												 																			 	
												 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
												 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
												 																			 	 {
												 																			 		$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = true;
												 																			 	 }
																														 }else if(tempAssociatedGrps[x].associatedGroup.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																														 		 tempAssociatedGrps[x].associatedGroup.providerSpecialties = IPAsGroupsSplit[1];
																														 }else if(tempAssociatedGrps[x].associatedGroup.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																														 		 tempAssociatedGrps[x].associatedGroup.capId = IPAsGroupsSplit[1];
																																 $scope.provider.providerDetailsResponse.organizationalProviderDetails.capOfficeID = '';
																																 $scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
																																 
																																 $scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = false;
													 																			 	
													 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
													 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
													 																			 	 {
													 																			 		$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = true;
													 																			 	 }
																														 }
															 															 tempAssociatedGrps[x].associatedGroup.name.full = IPAsGroupsSplit[0];
																												}
																												$scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups = tempAssociatedGrps;
																									 }
																							}
															}
															groupLength = $scope.provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups;
															groupLength = Object.keys(groupLength).length;
														}

														if($scope.provider && $scope.provider.providerDetailsResponse
															&& $scope.provider.providerDetailsResponse.organizationalProviderDetails
															&& $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations) {
															if($scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations.length != 0
																	&& $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations[0].providerOrganization.name == undefined){
																		$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations = [];
															}else{
																							// .organizationalProviderDetails.providerOrganizations["0"].providerOrganization.name.full
																							var tempAssociatedOrgs = $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations;
																							if(tempAssociatedOrgs != undefined && (tempAssociatedOrgs != null || tempAssociatedOrgs.length)){
																									 tempAssociatedOrgs = $filter('toArray')(tempAssociatedOrgs);
																								   if(tempAssociatedOrgs.length != undefined){
																												for(var x=0;x<tempAssociatedOrgs.length;x++){
															 															 IPAsGroupsSplit = tempAssociatedOrgs[x].providerOrganization.name.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																														 if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																															  tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
															 															 			tempAssociatedOrgs[x].providerOrganization.capId = IPAsGroupsSplit[1];
													 																	 		  tempAssociatedOrgs[x].providerOrganization.providerSpecialties = IPAsGroupsSplit[2];
												 																				 $scope.provider.providerDetailsResponse.organizationalProviderDetails.capOfficeID = '';
												 																				$scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
												 																				
												 																				$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = false;
												 																			 	
												 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
												 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
												 																			 	 {
												 																			 		$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = true;
												 																			 	 }
												 																				
																														 }else if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																														 		 tempAssociatedOrgs[x].providerOrganization.providerSpecialties = IPAsGroupsSplit[1];
																														 }else if(tempAssociatedOrgs[x].providerOrganization.name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																														 		 tempAssociatedOrgs[x].providerOrganization.capId = IPAsGroupsSplit[1];
																																 $scope.provider.providerDetailsResponse.organizationalProviderDetails.capOfficeID = '';
																																 $scope.provider.providerDetailsResponse.displayPCPEligibility.displayProviderIdentfierNumber=false;
																																 
																																 $scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = false;
													 																			 	
													 																			 	if( $scope.languageData.SHOW_PIN_WITH_CAP && $scope.languageData.SHOW_PIN_WITH_CAP ==  "ON" &&
													 																				   	(( $scope.criteria.pinDisplay=='Y' && $scope.criteria.pinDisplay!='' ) || $scope.criteria.planProductCode == "" ))
													 																			 	 {
													 																			 		$scope.provider.providerDetailsResponse.organizationalProviderDetails.showPINWithCAP = true;
													 																			 	 }
																														 }
															 															 tempAssociatedOrgs[x].providerOrganization.name.full = IPAsGroupsSplit[0];
																												}
																												$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations = tempAssociatedOrgs;
																									 }
																							}
															}
														}


					}else if(window.location.href.indexOf("page=providerHospDetails") > -1){
						if($state.params.distance){
							$scope.distance = $state.params.distance;
						}else if($scope.provider.providerDetailsResponse.hospitalProviderDetails &&
								$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
								$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0] &&
								$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address){
							$scope.distance = $scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.distance;
						}
					}


					//

					//console.log("locId:"+vLocId+" proId:"+vProId);
          //fetchAndSetPlanPleatInfo(vProId, vLocId);

					/* Get office hours */
					$scope.officeHoursRows = getOfficeHours($scope.provider);

					var prov = ProviderResultsService.getProvider();

					// run the review service to get any reviews for provider
					ReviewsService.initialize();

					var r = ReviewsService.getReviews(prov.providerInformation.providerIdentifier.idValue);

					// when the reviews are back, if the pleat was opened
					// from the previous screen, position to the pleat
					r.then(
							function success(response) {
								try{
									function scroll() {
										var id = 'ratingsPanel';
										var scrollHere = document.getElementById(id);
										scrollHere.focus();
										scrollHere.scrollIntoView();
									}

									if (!$scope.providerDetailsPleatTracker.isCollapsedFour) {
										setTimeout(scroll, 200);
									}
								}
								catch( e )
								{
								}
							},
						function error(response) {
						}
					);

					$scope.showDisclaimer = function(url){
						var disclaimerUrl = $state.href('disclaimerPage', {page: 'standardDisclaimer', storeURL: url, language:language});
						window.open(disclaimerUrl, '_blank');
					}

					//Need to carry some details from the List page.- distance,cost
					//$scope.provider.providerLocation = {};
					// $scope.provider.providerLocation.distance = /*$scope.provider.contacts.distance =*/prov.providerData.providerAtLocation.officeContacts.postalAddresses.distance;
					// $scope.provider.providerLocation.distance = prov.providerLocations[0].address.distance;

					//tactical fix
					var pType = $state.params.pType;
					if(pType != null && pType != undefined && pType == 'Individual' && prov.providerLocations[0]){
							$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.distance = prov.providerLocations[0].address.distance;
					}else if(pType != null && pType != undefined && pType == 'Hospital' && prov.providerLocations[0]){
							$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.distance = prov.providerLocations[0].address.distance;
					}else if(pType != null && pType != undefined && pType == 'Organization' && prov.providerLocations[0]){
							$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.distance = prov.providerLocations[0].address.distance;
					}

					setIPACount();



						// open pleats if we are to auto-scroll to them
						if(ProviderResultsService.scrollTo!='')
						{
							if(ProviderResultsService.scrollTo=='experiencePanel') {
								$scope.providerDetailsPleatTracker.isCollapsedThree = false;

								$scope.showFlag=true;
								$location.hash('experiencePanel');
							}
								if(ProviderResultsService.scrollTo=='ratingsPanel')
								{
									$scope.providerDetailsPleatTracker.isCollapsedFour = false;
								}
								else if(ProviderResultsService.scrollTo=='experiencePanel')
								{
									$scope.providerDetailsPleatTracker.isCollapsedThree = false;
								}
								else if(ProviderResultsService.scrollTo=='planDetailsPanel')
								{

											if($scope.selectedPlan == undefined && $scope.releventPlans == undefined && $scope.nonReleventPlans == undefined){
														fetchAndSetPlanPleatInfo(vProId, vLocId);
											}
											$scope.providerDetailsPleatTracker.isCollapsedPlanDetails = false;
											setTimeout(function(){
												$('html,body').animate({
													 scrollTop: $(".classForScroll").offset().top},
													 'slow');
													// $("#accPlanDetails").focus();
											 }, 1000);
								}else{

								}
							ProviderResultsService.scrollTo = '';
							$anchorScroll();
						}

						/*$scope.isCollapsedTwo = false;
						$scope.$apply();
						$location.hash(ProviderResultsService.scrollTo);

					      // call $anchorScroll()
					      $anchorScroll();
						//window.scrollTo(ProviderResultsService.scrollTo);
					     ProviderResultsService.scrollTo = '';*/
					if($scope.provider.providerDetailsResponse.individualProviderDetails){			
							if($scope.provider.providerDetailsResponse.individualProviderDetails.designations ){
									getMixBHDes($scope.provider.providerDetailsResponse.individualProviderDetails.designations);							
							}
							$scope.isClinicalDesignations($scope.provider.providerDetailsResponse.individualProviderDetails.designations);//To get the clinical efficiency details.
							$scope.boardCerts = $scope.getBoardCertications($scope.provider.providerDetailsResponse.individualProviderDetails.designations);// tp get board certifcations

							if( $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
								$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.handicapAccess )
							{
								$scope.handicapAccess = $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.handicapAccess;
								$scope.showHandicapAccess = true;
							}
					}
					if($scope.provider.providerDetailsResponse.organizationalProviderDetails){						
							if($scope.provider.providerDetailsResponse.organizationalProviderDetails.designations ){
									getMixBHDes($scope.provider.providerDetailsResponse.organizationalProviderDetails.designations);							
							}

							if( $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations &&
								$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.handicapAccess )
							{
								$scope.handicapAccess = $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.handicapAccess;
								$scope.showHandicapAccess = true;
							}
					}
					if($scope.provider.providerDetailsResponse.hospitalProviderDetails && 
					   $scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider && 
					   $scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.designations ){
							getMixBHDes($scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.designations);							
					}
					setTierMessageId($scope.provider);
				},
				function error(errorMsg){		

					$scope.provider = null;
					$log.error(errorMsg.statusText);
					NavSpinnerService.stop();
				}
			);
		}

		function getMixBHDes(dezs){
				var des=[];
				var finalDes=[];
				
				if (angular.isArray(dezs)) {
					des = dezs;
				} else {
					des = [dezs];
				}

				for(i=0;i<des.length;i++)
				{
						if(des[i].type == 'mixBHProvider')
						{
							$scope.mixBHProvider = true;
							$scope.mixBHProviderDescription = des[i].description;
							break;
						}
				}
		}

		function setIPACount(){
			if($scope.provider && $scope.provider.providerDetailsResponse && $scope.provider.providerDetailsResponse.individualProviderDetails
					&& $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups){
						var len = $scope.provider.providerDetailsResponse.individualProviderDetails.associatedGroups.length;
						if(len < 2){
							$scope.displayIPACount = 2 - len;
						}
			}else if($scope.provider && $scope.provider.providerDetailsResponse && $scope.provider.providerDetailsResponse.organizationalProviderDetails
					&& $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations){
				var len = $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations.length;
				if(len < 2){
					$scope.displayIPACount = 2 - len;
				}
			}
		}

		function fetchFauxRows(){
			$scope.fauxRowsArray=[];
			var obj;
			var listInfoExchange=$scope.provider.listInfoExchanges.listInfoExchange;
			if(!angular.isArray(listInfoExchange))
				listInfoExchange = [listInfoExchange];
			for(var i=0;i<listInfoExchange.length;i++){
				if(listInfoExchange[i].name=="directoryLastUpdatedDate"){
					$rootScope.lastUpdatedDate=listInfoExchange[i].values.value[0].value;
				}
				else if(listInfoExchange[i].name=="PCPInquryTimeOut"){
					$scope.PCPInquryTimeOutMessage=listInfoExchange[i].values.value.value;
				}
				else if(listInfoExchange[i].name=="referralIndicator"){
					$scope.referralInd=listInfoExchange[i].values.value[0].value;
				}
			}
		}
		/** code for navigation to results page when "other office location" link is clicked  **/
		$scope.otherOfficeLocation=function(){
			ProviderResultsService.setMultipleLocations(true);
			ProviderResultsService.getResults()
			.then(
				function success(result) {
					var location=[];
					$scope.providerRes = result.providersResponse.readProvidersResponse;
					if($scope.providerRes != null && $scope.providerRes != undefined && $scope.providerRes != ""){

						if (angular.isArray($scope.providerRes.providerInfoResponses))
							location = $scope.providerRes.providerInfoResponses;
						else
							location = [$scope.providerRes.providerInfoResponses];
							$scope.differentLocations=location.length;
					}

				},
				function error (errorMsg) {
					//End Spinner.
					//NavSpinnerService.stop();
					$scope.providerRes = null;
					$log.error(errorMsg.statusText);
				}
			);

		}

		$scope.findDoctors=function(data){
			$scope.criteria.hospitalName = data ? data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full : '';
			$scope.criteria.isFindDoctor = true;
			$scope.criteria.isProviderForGroup = false;
			$scope.criteria.isProviderForIPA = false;
			$scope.criteria.isProviderForHospital = false;
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			$scope.criteria.findDocPrevId = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerID;
			/* In case of 'Find Doctors' reset filters and searchText */
			$scope.clearAlphaSort();
			$scope.criteria.searchText = '';
			$scope.criteria.searchTextForBackEnd = '';

			ProviderResultsService.setFindDoctors(true);
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;
			//ACNLA5_0603 code changes start
			//$state.go('contentPage',{page:'providerResults',parameters:'',site_id:siteId,language:language});
			$scope.disableChangeLocation = 'disbaleChangeLocation';
		    	$state.go('contentPage',{page:'providerResults',parameters: $scope.disableChangeLocation,site_id:siteId,language:language});
			//ACNLA5_0603 code changes end
		}

		$scope.hospitalAffiliations=function(id, name){
			// $scope.criteria.isAlphaSort = false;
			// $scope.criteria.isResetFilter = false;
			// console.log("resetfilter hospitalAffiliations"+ $scope.criteria.isResetFilter);
			// $scope.criteria.checkedItem = [];
			// $scope.criteria.checkedContentItem = [];
			// $scope.criteria.checkedSecondLevelContentItem = [];
			// $scope.criteria.listSelections = null;
			// $scope.criteria.direction = '';
			// $scope.criteria.order = '';
			// $scope.criteria.selectedListArray = [];
			// $scope.criteria.selectedFilters = '';
			name = name.replace("&","%26");
			return '#/contentPage?page=providerResults&hosId='+id+'&hosName='+name+'&site_id='+siteId+'&language='+language;
			// ProviderResultsService.setHospitalId(id);
			// $scope.criteria.hospitalId = id;
			// $scope.criteria.isProviderForHospital = true;
			// $scope.criteria.isProviderForIPA = false;
			// $scope.criteria.isProviderForGroup = false;
			// $scope.criteria.isFindDoctor = false;
			// $scope.criteria.hospitalName = name;
			// $state.go('contentPage',{page:'providerResults',parameters:''});
		};

		$scope.clearAlphaSort=function(){
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			$scope.criteria.isResetFilter = false;
			console.log("resetfilter callingAssociation"+ $scope.criteria.isResetFilter);
			$scope.criteria.checkedItem = [];
			$scope.criteria.checkedContentItem = [];
			$scope.criteria.checkedSecondLevelContentItem = [];
			$scope.criteria.listSelections = null;
			$scope.criteria.direction = '';
			$scope.criteria.order = '';
			$scope.criteria.selectedListArray = [];
			$scope.criteria.selectedFilters = '';
		}

		$scope.callingAssociationForGroupsFindDoctor=function( fullName , providerId )
		{
			
			return '#/contentPage?page=providerResults&proOrgDispName='+fullName+
			'&groupProId='+providerId+'&assocProvSrchGrp=Y'+'&poin=NA&site_id='+siteId+'&language='+language;
		}
		
		$scope.callingAssociation=function(group){
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;

			if(group.providerOrganization && (group.providerOrganization.type=="IPA" || group.providerOrganization.poin != undefined)){
				// alert(group.providerOrganization.name.full+" "+group.providerOrganization.poin)
				// alert(JSON.stringify(group.providerOrganization))
				return '#/contentPage?page=providerResults&proOrgName='+group.providerOrganization.name.full+'&poin='+group.providerOrganization.poin+'&site_id='+siteId+'&language='+language;
				// ProviderResultsService.setIpaDetails(group.providerOrganization.poin);
				// $scope.criteria.ipaName = group.providerOrganization.name.full;
		    // $scope.criteria.isProviderForIPA = true;
				// $scope.criteria.isProviderForGroup = false;
				// $scope.criteria.isProviderForHospital = false;
				// $scope.criteria.isFindDoctor = false;
			}
			else if(group.providerDisplayName && group.providerDisplayName.full !== undefined){
				return '#/contentPage?page=providerResults&proOrgDispName='+group.providerDisplayName.full+'&groupProId='+group.providerID+'&poin=NA&site_id='+siteId+'&language='+language;
				// ProviderResultsService.setGroupdetails(group.providerID,group.providerDisplayName.full);
				// $rootScope.grpName = group.providerDisplayName.full;
				// $scope.criteria.isProviderForGroup = true;
				// $scope.criteria.isProviderForIPA = false;
				// $scope.criteria.isProviderForHospital = false;
				// $scope.criteria.isFindDoctor = false;
			}else{}
			// $state.go('contentPage',{page:'providerResults',parameters:''});
		};

		$scope.getTotal = function(provider){
			var groupNum = 0;
			var orgNum = 0;
			if(provider.providerDetailsResponse.individualProviderDetails.associatedGroups){
				groupNum = provider.providerDetailsResponse.individualProviderDetails.associatedGroups.length;
			}
			if(provider.providerDetailsResponse.individualProviderDetails.providerOrganizations){
				orgNum = provider.providerDetailsResponse.individualProviderDetails.providerOrganizations.length;
			}
			return groupNum + orgNum;
		};

		$scope.getOrgDetailsTotal = function(provider){
			var groupNum = 0;
			var orgNum = 0;
			if(provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups){
				groupNum = provider.providerDetailsResponse.organizationalProviderDetails.associatedGroups.length;
			}
			if(provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations){
				orgNum = provider.providerDetailsResponse.organizationalProviderDetails.providerOrganizations.length;
			}
			return groupNum + orgNum;
		};

		$scope.getTotalNoOfAssociations = function(provider){
			var groupNum = 0;
			var orgNum = 0;
			if(provider.providerDetailsResponse.individualProviderDetails.associatedGroups){
				groupNum = provider.providerDetailsResponse.individualProviderDetails.associatedGroups.length;
			}
			if(provider.providerDetailsResponse.individualProviderDetails.providerOrganizations){
				orgNum = provider.providerDetailsResponse.individualProviderDetails.providerOrganizations.length;
			}
			$scope.groupIPACount = 2 - groupNum;
			return groupNum + orgNum;
		};

		$scope.getFitlersDesignations = function(designations){

			var des=[];
			var finalDes=[];
			index=0;
			if(designations)
				{
					if (angular.isArray(designations)) {
						des = designations;
					} else {
						des = [designations];
					}

					for(i=0;i<des.length;i++)
						{
							if((des[i].type == 'ACO' || des[i].code =='AEXCEL' || des[i].type=='narrowNetwork' || des[i].type=='Joint Venture')
								&& ((des[i].descriptionURL!=null && des[i].descriptionURL!=undefined)
										|| (des[i].description!=null && des[i].description!=undefined)))
								{
									finalDes.push(des[i]);
								}
						}
				}
				return finalDes;

		};

		//  NEW MAP CHANGES START
		/* Map changes start
		// mapquest map functions
		$scope.map = {  // all map stuff goes here
			directions: false,  // true if directions being displayed for map
			type: "",  // map type desktop, mobile, iphone
			fromAddress: "",
			toAddress:  "",
			label: "",
			phone: "",
			routeListing: null  // array of route steps
		}

		// set the map type for displaying a map.
		// - browser size determines if it is desktop or mobile
		// - user agent determines if it's an iphone.  However, we only need this class if the
		//   iphone is in portrait mode (to handle a browser inconsistancy)
		function setMapType() {
			var oldType = $scope.map.type;
			var w = $window.innerWidth;
			var h = $window.innerHeight;
		    var ua = $window.navigator.userAgent;
		    var iPhone = ( navigator.userAgent.match(/(iPhone|iPod)/g) ? true : false );
		    var portrait = w < h;

		    // determine map type
		    if (iPhone && portrait) {
		    	$scope.map.type = "iphone";
		    } else if (w > 992) {
		    	$scope.map.type = "desktop";
		    } else {
		    	$scope.map.type = "mobile";
		    }

		    // if the map type changes, this can be because of a windows event outside of angular control.
		    // Have angular redo its stuff
		    if (oldType != $scope.map.type) {
		    	try {
		    		angular.element(document.getElementById('providerResults')).scope().$apply();
		    	} catch (e) {}
		    }
		}

		// set map type now and whenever the browser size changes
		setMapType();
		$(window).resize(function() {
		    setMapType();
		});

		// return true if there is a map open for a provider
		$scope.isMapOpen = function(provider) {
			return provider.isMap == true;
		};


		// get the ID for the map, given a provider
		$scope.getMapId = function(provider) {
			var id = "map_" + getProviderKey(provider);
			return id;
		};

		// get a unique key for a provider
		function getProviderKey(provider) {
			// handle bad provider parameter
			if (!provider || !provider.providerLocations
				|| !provider.providerLocations[0]
				|| !provider.providerLocations[0].locationID
				|| !provider.providerInformation
				|| !provider.providerInformation.providerID) {
				return null;  // bad data - no key
			}

			var key = provider.providerInformation.providerID
				+ '.'
				+ provider.providerLocations[0].locationID;
			return key;
		}


		// return the class name for a map for a provider
		// map_desktop, map_mobile_full, map_mobile, map_none
		$scope.getMapClass = function(provider) {

			var c = "map_none";  // default to no map
			if (provider.isMap) {
				// there is a map, so see if we are doing a desktop or mobile map
				var mapType = $scope.map.type;
				if (mapType === 'mobile') {
					console.log("mobile");
					// there are 2 types of mobile maps - full screen and non-full screen (for directions)
					if ($scope.map.directions) {
						console.log("mobile_directions");
						c = "map_mobile";  // leave room for directions
					} else {
						console.log("mobile_nodirections");
						c = "map_mobile_full";  // map can take entire screen
					} // a mobile map
				} else if (mapType === 'iphone') {
					console.log("iphone");
					// there are 2 types of iphone maps - full screen and non-full screen (for directions)
					if ($scope.map.directions) {
						console.log("iphone_directions");
						c = "map_iphone";  // leave room for directions
					} else {
						console.log("iphone_nodirections");
						c = "map_iphone_full";  // map can take entire screen
					} // a mobile map
				} else { // a desktop map
					// there is 1 type of desktop map - with or without directions
					console.log("desktop");
					c = "map_desktop";
				} // what type of map
			} else { // no map open for this provider, so return map_none
				console.log("none");
				c = "map_none";
			} // is there a map

			return c;
		}

		// return true if there is a map with directions open for a provider
		$scope.isDirectionsOpen = function(provider) {
			if (provider.isMap) {
				// there is a map, so see if there are directions
				return $scope.map.directions;
			} else { // no map open for this provider, so return false
				return false;
			}
		}

		// return the class name for the driving directions for a provider
		// directions_desktop, directions_mobile, directions_none
		$scope.getDirectionsClass = function(provider) {
			var c = "directions_none";  // default
			if (provider.isMap && $scope.map.directions) { // provider has map and we are doing directions
				var c = "directions_" + $scope.map.type;
			}
			return c;
		}

		// display a map for a provider
		$scope.openProviderMap = function(provider) {
			function scroll() {
				if( ( provider.providerDetailsResponse.individualProviderDetails &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull ) ||
						( provider.providerDetailsResponse.hospitalProviderDetails &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full) ||
						( provider.providerDetailsResponse.organizationalProviderDetails &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full) )
					var id = 'map_details';
				else
					var id = $scope.getMapId(provider);

				var scrollHere = document.getElementById(id);
				scrollHere.focus();
				scrollHere.scrollIntoView();
			}
			if (provider.isMap) {
				return;  // map is already open
			}



			if( provider &&  provider.providerDetailsResponse &&
					(( provider.providerDetailsResponse.individualProviderDetails &&
					provider.providerDetailsResponse.individualProviderDetails.practitioner &&
					provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull ) ||
					( provider.providerDetailsResponse.hospitalProviderDetails &&
							provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
							provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full) ||
					( provider.providerDetailsResponse.organizationalProviderDetails &&
							provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName &&
							provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full) ))
				var mapId = 'map_details';
			else
				var mapId = $scope.getMapId(provider);

			$scope.map.provider = provider;
			provider.isMap = true;  // this provider has a map

			// fill in map object with info needed for the map
			try {
				if( provider &&  provider.providerDetailsResponse &&
						provider.providerDetailsResponse.individualProviderDetails &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull)
				{
					$scope.map.label = provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull;

					if(provider.providerDetailsResponse.individualProviderDetails.contacts)
						$scope.map.phone = provider.providerDetailsResponse.individualProviderDetails.contacts[0].primaryPhone.number;
				}
				else if( provider &&  provider.providerDetailsResponse &&
						provider.providerDetailsResponse.hospitalProviderDetails &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full )
				{
					$scope.map.label = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full;

					if( provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.contacts )
						$scope.map.phone = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.contacts[0].primaryPhone.number;
				}
				else if( provider &&  provider.providerDetailsResponse &&
						provider.providerDetailsResponse.organizationalProviderDetails &&
						provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName &&
						provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full )
				{
					$scope.map.label = provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full;

					if ( provider.providerDetailsResponse.organizationalProviderDetails.contacts )
						$scope.map.phone = provider.providerDetailsResponse.organizationalProviderDetails.contacts[0].primaryPhone.number;
				}
				else if ( provider && provider.providerInformation &&
						provider.providerInformation.providerDisplayName &&
						provider.providerInformation.providerDisplayName.full)
				{

					$scope.map.label = provider.providerInformation.providerDisplayName.full;

					if ( provider.contacts )
						$scope.map.phone = provider.contacts [0].primaryPhone.number;
				}

				if ( $scope.map.phone )
					$scope.map.phone = phoneFormatFilter($scope.map.phone);

			} catch (e) {}

			$scope.map.toAddress = "";
			$scope.map.displayAddress = "";
			if(   provider &&  provider.providerDetailsResponse &&
					provider.providerDetailsResponse.individualProviderDetails &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0]  )
			{
				$scope.map.toAddress =
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine1 + ' ' +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.postalCode;

				$scope.map.displayAddress = provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine1 + '<br/>';

				if( provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine2 )
					$scope.map.displayAddress = $scope.map.displayAddress +
						provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine2 + '<br/>';

				$scope.map.displayAddress = $scope.map.displayAddress +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.postalCode;
			}
			else if( provider &&  provider.providerDetailsResponse &&
					provider.providerDetailsResponse.hospitalProviderDetails &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider )
			{
				$scope.map.toAddress =
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine1 + ' ' +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.postalCode;

				$scope.map.displayAddress = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine1 + '<br/>';

				if( provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine2 )
					$scope.map.displayAddress = $scope.map.displayAddress +
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine2 + '<br/>';

				$scope.map.displayAddress = $scope.map.displayAddress +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.postalCode;
			}
			else if( provider &&  provider.providerDetailsResponse &&
					provider.providerDetailsResponse.organizationalProviderDetails &&
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations )
			{
				$scope.map.toAddress =
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine1 + ' ' +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.postalCode;

				$scope.map.displayAddress = provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine1 + '<br/>';

				if( provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine2 )
					$scope.map.displayAddress = $scope.map.displayAddress +
						provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine2 + '<br/>';

				$scope.map.displayAddress = $scope.map.displayAddress +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.city + ' ' +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.state + ' ' +
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.postalCode;
			}
			else if( provider &&  provider.providerLocations && provider.providerLocations[0] &&
					provider.providerLocations[0].address )
			{
				$scope.map.toAddress =
					provider.providerLocations[0].address.streetLine1 + ' ' +
					provider.providerLocations[0].address.city + ' ' +
					provider.providerLocations[0].address.state + ' ' +
					provider.providerLocations[0].address.postalCode;

				$scope.map.displayAddress = provider.providerLocations[0].address.streetLine1 + '<br/>';

				if( provider.providerLocations[0].address.streetLine2 )
					$scope.map.displayAddress = $scope.map.displayAddress +
					provider.providerLocations[0].address.streetLine2 + '<br/>';

				$scope.map.displayAddress = $scope.map.displayAddress +
					provider.providerLocations[0].address.city + ' ' +
					provider.providerLocations[0].address.state + ' ' +
					provider.providerLocations[0].address.postalCode;
			}

			$scope.map.directions = false;  // not displaying driving directions yet
			$scope.map.routeListing = null;

			// create the actual map
			L.Icon.Default.imagePath = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images';
			//var mapId = 'map_details';  // where to put the map
			$scope.map.mqMap = L.map(mapId, {
				layers: MQ.mapLayer(),
				zoom: 16
			});

			// put the provider address on the map
			MQ.geocode({
				map: $scope.map.mqMap,
				icon: L.icon({
					iconUrl: '../../images/distance.png',
					iconSize: [ 22, 28 ],
					iconAnchor: [ 11, 28 ],
					popupAnchor: [ 0, -22 ]
				})
			}).search($scope.map.toAddress).on('success', function(e) {
				var best = e.result.best, latlng = best.latlng;
				L.marker([ latlng.lat, latlng.lng ])
				.addTo($scope.map.mqMap)
				.bindPopup(createPOIHtml())
				.openPopup();
			});

			// scroll to map but wait for things to settle
			setTimeout(scroll, 200);
		}

		// Display directions below the map
		window.openDirections = function() {
			function scroll() {

				if( provider && provider.providerDetailsResponse &&
						(( provider.providerDetailsResponse.individualProviderDetails &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner &&
						provider.providerDetailsResponse.individualProviderDetails.practitioner.nameFull ) ||
						( provider.providerDetailsResponse.hospitalProviderDetails &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full) ||
						( provider.providerDetailsResponse.organizationalProviderDetails &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full)) )
					var id = 'map_details';
				else
					var id = $scope.getMapId(provider);

				var scrollHere = document.getElementById(id);
				scrollHere.scrollIntoView();
			}

			$scope.map.directions = true;  // display driving directions

			// scroll to map but wait for things to settle
			setTimeout(scroll, 200);

			// angularJS did not call this function, so we need to tell it that it was called
			// so it can update any view changes.
			angular.element(document.getElementById('providerDetails')).scope().$apply();
		};

		// close the map for a provider
		$scope.closeProviderMap = function(provider) {

			provider.mapAvailable = true;

			provider.isMap = false;  // this provider does not have a map
			try {
				$scope.map.mqMap.remove();
			} catch(e) {};
			$scope.map.mqMap = null;
			$scope.map.directions = false;  // not displaying driving directions yet
			$scope.map.routeListing = null;

			$scope.map.fromAddress = "";
		};

		// create the HTML that displays the provider on the map
		function createPOIHtml() {
			var poiHtml =
				'<strong>' + $scope.map.label +
				'</strong><br>' +
				$scope.map.displayAddress + '<br/>' +
				$scope.map.phone +
				"<br><a href='javascript:openDirections()'>Directions</a>";
			return poiHtml;
		}

		$scope.getDirections = function() {
			var dir = MQ.routing.directions()
			.on('success', function(data) {
			    var legs = data.route.legs,
			        html = '',
			        maneuvers,
			        i;

			    if (legs && legs.length) {
			        maneuvers = legs[0].maneuvers;

			        // create an array of route steps to display
			        $scope.map.routeListing = [];
			        for (i=0; i<maneuvers.length; i++) {
			            $scope.map.routeListing[i] = maneuvers[i].narrative;
			        }

					// angularJS did not call this functions, so we need to tell it that it was called
					// so it can update any view changes.
					angular.element(document.getElementById('providerDetails')).scope().$apply();

			    }
			});

			dir.route({
			    locations: [
			        $scope.map.fromAddress,  // starting point
			        $scope.map.toAddress  // ending point
			    ]
			});

			$scope.map.routeLayer = MQ.routing.routeLayer({
			    directions: dir,
			    fitBounds: true
			});

			$scope.map.mqMap.addLayer($scope.map.routeLayer);

		}

		$scope.closeDirections = function() {
			$scope.map.directions = false;  // not displaying driving directions
			$scope.map.routeListing = null;
			$scope.map.mqMap.removeLayer($scope.map.routeLayer);
		}   */

		// mapquest map functions
				$scope.map = {  // all map stuff goes here
					directions: false,  // true if directions being displayed for map
					type: "",  // map type desktop, mobile, iphone
					fromAddress: "",
					toAddress:  "",
					label: "",
					phone: "",
					routeListing: null  // array of route steps
				}

				// set the map type for displaying a map.
				// - browser size determines if it is desktop or mobile
				// - user agent determines if it's an iphone.  However, we only need this class if the
				//   iphone is in portrait mode (to handle a browser inconsistancy)
				function setMapType() {
					var oldType = $scope.map.type;
					var w = $window.innerWidth;
					var h = $window.innerHeight;
				    var ua = $window.navigator.userAgent;
				    var iPhone = ( navigator.userAgent.match(/(iPhone|iPod)/g) ? true : false );
				    var portrait = w < h;

				    // determine map type
				    if (iPhone && portrait) {
				    	$scope.map.type = "iphone";
				    } else if (w > 992) {
				    	$scope.map.type = "desktop";
				    } else {
				    	$scope.map.type = "mobile";
				    }

				    // if the map type changes, this can be because of a windows event outside of angular control.
				    // Have angular redo its stuff
				    if (oldType != $scope.map.type) {
				    	try {
				    		angular.element(document.getElementById('providerResults')).scope().$apply();
				    	} catch (e) {}
				    }
				}

				// set map type now and whenever the browser size changes
				setMapType();
				$(window).resize(function() {
				    setMapType();
				});

				// return true if there is a map open for a provider
				$scope.isMapOpen = function(provider) {
					return provider.isMap == true;
				}


				// get the ID for the map, given a provider
				$scope.getMapId = function(provider) {
					var id = "map_" + getProviderKey(provider);
					return id;
				}

				// get a unique key for a provider
				function getProviderKey(provider) {
					// handle bad provider parameter
					if (!provider || !provider.providerAtLocation
						|| !provider.providerAtLocation.providerAtLocationIdentifier
						|| !provider.providerAtLocation.providerAtLocationIdentifier.idValue
						|| !provider.providerID) {
						return null;  // bad data - no key
					}

					var key = provider.providerID
						+ '.'
						+ provider.providerAtLocation.providerAtLocationIdentifier.idValue;
					return key;
				}


				// return the class name for a map for a provider
				// map_desktop, map_mobile_full, map_mobile, map_none
				$scope.getMapClass = function(provider) {
					//console.log("Hi");
					//console.log(provider);
					var c = "map_none";  // default to no map
					if (provider.isMap) {
						// there is a map, so see if we are doing a desktop or mobile map
						var mapType = $scope.map.type;
						if (mapType === 'mobile') {
							//console.log("mobile");
							// there are 2 types of mobile maps - full screen and non-full screen (for directions)
							if ($scope.map.directions) {
								//console.log("mobile_directions");
								c = "map_mobile";  // leave room for directions
							} else {
								//console.log("mobile_nodirections");
								c = "map_mobile_full";  // map can take entire screen
							} // a mobile map
						} else if (mapType === 'iphone') {
							//console.log("iphone");
							// there are 2 types of iphone maps - full screen and non-full screen (for directions)
							if ($scope.map.directions) {
								//console.log("iphone_directions");
								c = "map_iphone";  // leave room for directions
							} else {
								//console.log("iphone_nodirections");
								c = "map_iphone_full";  // map can take entire screen
							} // a mobile map
						} else { // a desktop map
							// there is 1 type of desktop map - with or without directions
							//console.log("desktop");
							c = "map_desktop";
						} // what type of map
					} else { // no map open for this provider, so return map_none
						//console.log("none");
						c = "map_none";
					} // is there a map

					return c;
				}

				// return true if there is a map with directions open for a provider
				$scope.isDirectionsOpen = function(provider) {
					if (provider.isMap) {
						// there is a map, so see if there are directions
						return $scope.map.directions;
					} else { // no map open for this provider, so return false
						return false;
					}
				}

				// return the class name for the driving directions for a provider
				// directions_desktop, directions_mobile, directions_none
				$scope.getDirectionsClass = function(provider) {
					var c = "directions_none";  // default
					if (provider.isMap && $scope.map.directions) { // provider has map and we are doing directions
						var c = "directions_" + $scope.map.type;
					}
					return c;
				}

				// display a map for a provider
				$scope.openProviderMap = function(provider) {
					var proLat = null;
					var proLong = null;
					var destination='';

					if(   provider &&  provider.providerDetailsResponse &&
								provider.providerDetailsResponse.individualProviderDetails &&
								provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
								provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude!=null &&
								provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude!=null  )
						{
							if(provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude==0.00 && provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude==0.00){
								destination = $scope.createAddress(provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address)
							}else{
								proLat = provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude;
								proLong = provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude;
							}
						}
						else if( provider && provider.providerDetailsResponse &&
								provider.providerDetailsResponse.hospitalProviderDetails &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude!=null &&
								provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude!=null )
						{
							if(provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude==0.00 && provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude==0.00){
								destination = $scope.createAddress(provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address)
							}else{
								proLat = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude;
								proLong = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude;
							}
						}
						else if( provider && provider.providerDetailsResponse &&
								provider.providerDetailsResponse.organizationalProviderDetails &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude!=null &&
								provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude!=null )
						{
							if(provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude==0.00 && provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude==0.00){
								destination = $scope.createAddress(provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address)
							}else{
								proLat = provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude;
								proLong = provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude;
							}
						}
						else if( provider &&  provider.providerLocations && provider.providerLocations[0] &&
								provider.providerLocations[0].address.latitude!=null && provider.providerLocations[0].address.longitude!=null)
						{
							if(provider.providerLocations[0].address.latitude==0.00 && provider.providerLocations[0].address.longitude==0.00){
								destination = $scope.createAddress(provider.providerLocations[0].address)
							}else{
								proLat = provider.providerLocations[0].address.latitude;
								proLong = provider.providerLocations[0].address.longitude;
							}
						}

					//Map can only be created if there is lat long.TODO - when we dont have lat long.
					if((proLat!=null &&  proLong!=null) || destination!=""){

					//displayProviderMap: This attribute decides if the map has already been created or not. The aim is to reduce the number of
					//google api calls. createMap hence should not be called if the map already exists.
						if(displayProviderMap==false){

							 var markerContent = document.getElementById("iw-container");
							 if((proLat == 0.00 && proLong == 0.00) || destination!=""){
								mapsService.createMapWithAddress(destination,16,"map");
 							 	mapsService.addMarkerFromAddress(destination,markerContent,true);
							 }else{
							 	mapsService.createMap(proLat,proLong,16,"map");
							 	mapsService.addMarker(proLat,proLong,markerContent,true);
							 }
							 $("#hideGoogleMap").focus();
							 displayProviderMap=true;

						 }
						 else{
							var element = document.getElementById('map');
							var mapCancelButton=document.getElementById('map_cancel');
							if(element == undefined)
								return;
							if(element.style.display == "none"){
								element.style.display = "block";
								mapCancelButton.style.display = "block";
								$("#hideGoogleMap").focus();
							}else{
								element.style.display = "none";
								mapCancelButton.style.display = "none";
							}
							displayProviderMap=true;
						 }
					}

					//Removed old maquest code to make code more readable.
				}

				// Display directions below the map // This is not needed anymore. WE will not be displaying directions on our website. Rather we will take the user //to google maps.
				window.openDirections = function() {
					function scroll() {

						if(provider.nameFull)
							var id = 'map_details';
						else
							var id = 'map_details_office';
						var scrollHere = document.getElementById(id);
						scrollHere.scrollIntoView();
					}

					$scope.map.directions = true;  // display driving directions

					// scroll to map but wait for things to settle
					setTimeout(scroll, 200);

					// angularJS did not call this function, so we need to tell it that it was called
					// so it can update any view changes.
					angular.element(document.getElementById('providerDetails')).scope().$apply();
				}

				// close the map for a provider
				$scope.closeProviderMap = function(provider) {
					/*if(provider.nameFull)
						var id = 'map_details';
					else
						var id = $scope.getMapId(provider);
					provider.isMap = false;  // this provider does not have a map
					try {
						$scope.map.mqMap.remove();
					} catch(e) {};
					$scope.map.mqMap = null;
					$scope.map.directions = false;  // not displaying driving directions yet
					$scope.map.routeListing = null;*/

					mapsService.toggleMap();
				}

				// create the HTML that displays the provider on the map
				function createPOIHtml() {
					var poiHtml =
						'<strong>' + $scope.map.label +
						'</strong><br>' +
						$scope.map.phone +
						"<br><a href='javascript:openDirections()'>Directions</a>";
					return poiHtml;
				}

				$scope.createAddress = function(provAddress)
				{
					var destination = ""
					var address = provAddress;
					//Streetline3 is buildingName
					if(address.buildingName){
						destination = address.buildingName + ", ";
					}
					if(address.streetLine3)
						destination = address.streetLine3 + ", ";
					destination  = destination + address.streetLine1 + ", "
					if(address.streetLine2)
						destination = destination + address.streetLine2 + ", ";

					destination = destination + address.city+ ", "+ address.state +" "+ address.postalCode.substring(0,5);
					return destination;
				}

				$scope.getDirections = function() {
					var destination  =  "";

							if(   $scope.provider &&  $scope.provider.providerDetailsResponse &&
										$scope.provider.providerDetailsResponse.individualProviderDetails &&
										$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
										$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0]  )
								{

										if($scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address != undefined &&
											$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address != null &&
											$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude != undefined &&
											$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude != null &&
											$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude != undefined &&
											$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude != null){
												if($scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude==0.00 && $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude==0.00){
													destination = $scope.createAddress($scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address)
												}else{
													destination = $scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.latitude+','+$scope.provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.longitude;
												}
											}

								}else if( $scope.provider &&  $scope.provider.providerDetailsResponse &&
										$scope.provider.providerDetailsResponse.hospitalProviderDetails &&
										$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider )
								{

										if($scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address != undefined &&
											$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address != null &&
											$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude != undefined &&
											$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude != null &&
											$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude != undefined &&
											$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude != null){
												if($scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude==0.00 && provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude==0.00){
													destination = $scope.createAddress($scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address)
												}else{
													destination = $scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.latitude+','+$scope.provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.longitude;
												}
											}

								}
								else if( $scope.provider &&  $scope.provider.providerDetailsResponse &&
										$scope.provider.providerDetailsResponse.organizationalProviderDetails &&
										$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations )
								{
										if($scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address != undefined &&
											$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address != null &&
											$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude != undefined &&
											$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude != null &&
											$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude != undefined &&
											$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude != null){
												if($scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude==0.00 && provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude==0.00){
													destination = $scope.createAddress($scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address)
												}else{
													destination = $scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.latitude+','+$scope.provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.longitude;
												}
											}

								}
								else if( $scope.provider &&  $scope.provider.providerLocations && provider.providerLocations[0] &&
										$scope.provider.providerLocations[0].address )
								{

										if($scope.provider.providerLocations[0].address != undefined &&
											$scope.provider.providerLocations[0].address != null &&
											$scope.provider.providerLocations[0].address.latitude != undefined &&
											$scope.provider.providerLocations[0].address.latitude != null &&
											$scope.provider.providerLocations[0].address.longitude != undefined &&
											$scope.provider.providerLocations[0].address.longitude != null){
												if($scope.provider.providerLocations[0].address.latitude==0.00 && $scope.provider.providerLocations[0].address.longitude==0.00){
													destination = $scope.createAddress($scope.provider.providerLocations[0].address)
												}else{
													destination = $scope.provider.providerLocations[0].address.latitude+','+$scope.provider.providerLocations[0].address.longitude;
												}
											}

								}

					return mapsService.createGoogleMapsDirectionURL(destination);

				}

				$scope.closeDirections = function() {
					$scope.map.directions = false;  // not displaying driving directions
					$scope.map.routeListing = null;
					$scope.map.mqMap.removeLayer($scope.map.routeLayer);
				}

		/* Map changes end */
		// NEW map chages End -----------------------------------------------------------

		$scope.getPleatPlanName = function(pName) {
			if (pName) {
				if(pName.indexOf('NAP')>-1){
						pName = pName.replace("javascript:popUpResize('","");
						pName = pName.replace("\')","\" target='blank'");
				}
			}
			return pName;
		}

		$scope.showDes=function(value, link){
			if(value.indexOf('hospitalsafetyscore')>-1){
				ProviderResultsService.showDisclaimer(value,'standard',null)
			}
			else{
				$scope.openURL(value);
			}

		}

		$scope.openURL = function(URL)
		{
			ProviderResultsService.openURL(URL);
		}

		$scope.showMore = function(){
			$scope.setClass=!$scope.setClass;
			if(!$scope.setClass){
				$('body,html').animate({
				     scrollTop: $("#headingOne").offset().top
			         }, 100);
	               $('body,html').clearQueue();
			}
		}

		$scope.showGrpIPAMore = function(){
			$scope.setGrpIPAClass=!$scope.setGrpIPAClass;
			if(!$scope.setGrpIPAClass){
				$('body,html').animate({
				     scrollTop: $("#headingOne").offset().top
			         }, 100);
	               $('body,html').clearQueue();
			}
		}

		$scope.showFlags = function(){
			$scope.showFlag=!$scope.showFlag;
		}

		$scope.dateConversion = function(date){
			 return new Date(date);

		}
		//For displaying clinical efficiency pleat
		$scope.finalClinicalDes=null;
		$scope.isClinicalDesignations = function(designations){

			var des=[];
			index=0;
			var flag=false;
			$scope.isHospital = false;
			if(designations)
				{
					if (angular.isArray(designations)) {
						des = designations;
					} else {
						des = [designations];
					}

					for(i=0;i<des.length;i++)
						{
							if(des[i].type == 'Clinical Efficiency')
							{
								$scope.finalClinicalDes=des[i];
								flag=true;
								if($scope.finalClinicalDes!=null)
									fetchClinicalDetails($scope.finalClinicalDes.descriptionURL);
								//break;

							}
							else if(des[i].code == 'hospital')
							{
								$scope.isHospital= true;

							}
						}
				}
				return flag;
		};
		function fetchClinicalDetails(aexcelUrl){
			var deferred = $q.defer();
			var url=configuration.aexcelDomain+aexcelUrl;
			$http.get(url)
			.then(
				function(response) {
					$scope.provider.clinicalEff = response.data;
					deferred.resolve(results);
				},
				function error(response)
				{
					deferred.reject(response);
					return deferred.promise;
				});

		}

		$scope.printPage = function() {
			$window.print();
		}

		/* Get the URL for clicking on a rating.  This takes you to the review
		 page of DocSpot.  In secure It depends on whether the user is a guest ID or a
		 regular user.  Guest IDs only read reviews, regular IDs can add a review.
		 In public this condition is not applciable and the user will always be taken to the
		 	add reviews page
		 */
		$scope.getReviewURL = function() {
			// get the feature to see which URL we should use for reviews
			var readOnly = false;  // assume restricted user
			if(readOnly) {
				return ReviewsService.getReadReviewsURL();
			} else {
				return ReviewsService.getAddReviewURL();
			}
		}

		$scope.getBoardCertications = function(designations){

			var des=[];
			var finalDes=[];
			if(designations)
			{
				if (angular.isArray(designations)) {
					des = designations;
				} else {
					des = [designations];
				}

				var j=0;
				for(i=0;i<des.length;i++)
					{
						if(des[i].type == 'boardCertified')
							{
								finalDes[j++] = des[i];
							}
					}
			}
			if(finalDes.length > 0)
				return finalDes;
			else
				return null;
		};

		// indicate if we have office hours to display
		$scope.isOfficeHours = function(provider) {
			/* Check for individuals */
			if (  provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.individualProviderDetails &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0] &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].operationHours &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].operationHours.length > 0 )
			{
				return true;
			}
			/* Check for organization  */
			else if(  provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.organizationalProviderDetails &&
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations &&
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0] &&
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].operationHours	&&
					provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].operationHours.length > 0 )
			{
				return true;
			}
			/* Check for hospitals */
			else if (  provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.hospitalProviderDetails &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0] &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].operationHours	&&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].operationHours.length > 0 )
			{
				return true;
			}
			else
			{
				return false;
			}
		};

		// turn office hours data into displayable text
		//$scope.getOfficeHours = function(provider) {
		function getOfficeHours(provider) {
			// turn the hours into a displayable piece of text
			try {

				var h;

				/* Check for individuals */
				if (  provider && provider.providerDetailsResponse &&
						provider.providerDetailsResponse.individualProviderDetails &&
						provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
						provider.providerDetailsResponse.individualProviderDetails.providerLocations[0] &&
						provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].operationHours	&&
						provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].operationHours.length > 0 )
				{
					h = provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].operationHours;
				}
				/* Check for Organizations.*/
				else if(  provider && provider.providerDetailsResponse &&
						provider.providerDetailsResponse.organizationalProviderDetails &&
						provider.providerDetailsResponse.organizationalProviderDetails.providerLocations &&
						provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0] &&
						provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].operationHours	&&
						provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].operationHours.length > 0 )
				{
					h = provider.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].operationHours;
				}
				/* Check for hospitals */
				else if (  provider && provider.providerDetailsResponse &&
						provider.providerDetailsResponse.hospitalProviderDetails &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0] &&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].operationHours	&&
						provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].operationHours.length > 0 )
				{
					h = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].operationHours;
				}
				else
				{
					return null;
				}



				// since we have office hours, make sure the data is arrays.  The
				// service tends to return 1-element arrays as the object itself.
				if(!angular.isArray(h)) {
					h = [h];
				}

				var rows = [];  // what to return
				for (var i=0; i<h.length; i++) {
					var row = {};
					row.day = h[i].dayOfWeek;
					var open = h[i].workingDay === "true";
					if (open) {
						var t = h[i].timeRange;
						if (t && !angular.isArray(t)) {
							t = [t];
						}
						for (j=0; j<t.length; j++) {
							if (h[i].workingDay === "true") {
								row.hours = t[j].timeStart + ' - ' + t[j].timeStop;
							}
							rows.push(row); // closed day on one row
							row = {};  // next set of hours has a new row without the day of week
							row.day = '';
						}
					}
					else{
						if(row.day === "Not Available" || row.day === "No disponible"){
							rows.push(row);
						}
						else{
							row.hours = h[i].timeRange[0].timeStart;
							rows.push(row);
						}
					}
				} // loop through all times
			} catch (error) {}

			return rows;
		};

		$scope.openWhiteFlagWindow=function(url){
			window.open(url, '_blank', 'location=yes,height=570,width=520,scrollbars=yes,status=yes');
		};

		$scope.openPdfURL = function( category )
		{
			NavSpinnerService.spin();
			PdfService.openACOpdf( category )
			.then(
					function success(response) {
						if (response && response.data && response.data.ChannelACOMapping
								&& response.data.ChannelACOMapping.link
								&& response.data.ChannelACOMapping.link != '' ) {
							window.open(response.data.ChannelACOMapping.link);
						} else {
							$log.error('There is no pdf info found in response');
						}
						NavSpinnerService.stop();
					},
				function error (errorMsg) {
					$log.error(errorMsg.statusText);
					NavSpinnerService.stop();
				}
			);
		};

		$scope.startanewSearch= function()
		{
			$state.params.proId = '';
			$state.params.locId = '';
			$state.params.pType = '';
			$state.params.distance = '';
			$scope.criteria.isResetFilter = true;
			$scope.criteria.fromDetailsStart = true;
			$sessionStorage.criteria.fromDetailsStart = true;
			// console.log("resetfilter startanewSearch"+ $scope.criteria.isResetFilter);
	 		ProviderResultsService.scrollTo = '';
			ProviderSearchCriteriaService.setPlanPleatShow(false);
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;
			if($state.params.page == "providerHospDetails" && $scope.criteria.hospitalId != ''){
				//ACNLA5_0603 code changes start
				//$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:'', hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
				if($state.params.parameters === "disbaleChangeLocation"){
					$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:$state.params.parameters, hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
				} else {
					$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:'', hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
				}
				//ACNLA5_0603 code changes end
			}else{
				ProviderResultsService.setHospitalId('');
				$scope.criteria.hospitalId = '';
				$scope.criteria.hospitalName = '';
				//ACNLA5_0603 code changes start
				//$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:''});
				if($state.params.parameters === "disbaleChangeLocation"){
					$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:$state.params.parameters});
				} else {
					$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:''});
				}
				//ACNLA5_0603 code changes end
			}
		};

		$scope.navigate=function(data){
			ProviderResultsService.setProvider(data);
			var proId =  data.providerInformation.providerID;
			var locId = data.providerLocations.locationID;
			var distance = data.providerLocations.address.distance;
			var pType = data.providerInformation.type;
			//$state.reload();
			$state.go('contentPage',{page:'providerDetails',proId:proId, locId:locId, pType:pType, distance:distance, parameters:'',site_id:siteId,language:language});
		};

		// Set the ID for a tier message in a provider.  The ID is passed to other functions to determine
		// the CSS classes needed to generate the HTML.  This is needed because the service does not return
		// anything about the type of tier message except text.
		// Note: Right now, the classes are determined by the actual text of the message - yuck
		// We need a code returned by the service so we can test on something better.
		function setTierMessageId (provider) {
			// return null if no designations for provider
			/*var providerType = ProviderResultsService.getProviderType();
			if(providerType == undefined || providerType == null || providerType == ''){
				providerType = $scope.criteria.provType;
			}
			if(providerType != null && providerType != undefined){
				if(providerType == 'Individual')
					var d = provider.providerDetailsResponse.individualProviderDetails.designations;
				else if(providerType == 'Hospital'){
					var d = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.designations;
				}else if(providerType == 'Organization'){
					var d = provider.providerDetailsResponse.organizationalProviderDetails.designations;
				}
			}*/
			var d = null;
			if(provider.providerDetailsResponse){
				if(provider.providerDetailsResponse.individualProviderDetails && provider.providerDetailsResponse.individualProviderDetails.designations){
					d = provider.providerDetailsResponse.individualProviderDetails.designations;
				}
				else if(provider.providerDetailsResponse.hospitalProviderDetails && provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider
						&& provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.designations){
					d = provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.designations;
				}
				else if(provider.providerDetailsResponse.organizationalProviderDetails && provider.providerDetailsResponse.organizationalProviderDetails.designations){
					d = provider.providerDetailsResponse.organizationalProviderDetails.designations;
				}
			}

			if (!d) {
				provider.tierMessageId = null;
				return;
			}
			if (!Array.isArray(d)) {
				d = [d];
			}

			for (var i=0; i<d.length; i++) {
				var designation = d[i];
				if (designation.type === 'tier' && designation.description) {
					var msg = designation.description.split('_');
					provider.tierMessageId = msg.length > 1 ? msg[0] : null;
					provider.tierMessage = msg.length > 1 ? msg[1] : msg[0];
					break;
				} // if tier designation
			} // loop through all designations

			return;
		}

		$scope.checkForExpand=function(){
			//var itemsLength = Object.keys($scope.providerDetailsPleatTracker).length;
			var trueCount=0;
			var falseCount=0;
			var temp=$( "#accordion" ).find( ".panel-collapse" ).length;
			for (var i in $scope.providerDetailsPleatTracker) {
				 if($scope.providerDetailsPleatTracker[i]==true){
					 trueCount=trueCount+1;
				 }
				 if(i !== "isCollapsedNonReleventPlans" && i !== "isCollapsedReleventPlans"){
					 if($scope.providerDetailsPleatTracker[i]==false){
						 falseCount=falseCount+1;
					 }
			 	}
  		}
			if(falseCount==temp || falseCount==Object.keys($scope.providerDetailsPleatTracker).length){
				$scope.collapse=false;
			}
			else{
				$scope.collapse=true;
			}
		}

		//Check environment to show debug option
		var checkIfToShowPlanPleatDebug = function(){
			if(configuration.debugPNIPleatInfo == true){
				return true; // Always show debugInfo if the environment is either QA, Stress or Dev.
			}else{
				if(window.location.href.indexOf("debug=true") > -1){ // Check "debug=true" in the URL for PROD
					if($scope.diagnosticInfoPresent == true){ // Check Debug Info in response 
						return true; // Show debug Info
					}else{
						return false; // DO NOT show debug Info
					}
				}else{
					return false; // DO NOT show debug Info
				}
			}
		};

		//Show and hide PNI debug Info
		$scope.showPNIDebugInformation = function(){
			$scope.isShowDebugInfo = !$scope.isShowDebugInfo;
		};
		
		$scope.checkForExpandPlanPleat=function(){
			//$scope.isshowDebbuggerForNetwork=!$scope.isshowDebbuggerForNetwork;
			var trueCount=0;
			var falseCount=0;
			var temp=$( "#accordion" ).find( ".panel-collapse" ).length;
			for (var i in $scope.providerDetailsPleatTracker) {
				 if($scope.providerDetailsPleatTracker[i]==true){
					 trueCount=trueCount+1;
				 }
				 if(i !== "isCollapsedNonReleventPlans" && i !== "isCollapsedReleventPlans"){
					 if($scope.providerDetailsPleatTracker[i]==false){
						 falseCount=falseCount+1;
					 }
				}
  		}
			if(falseCount==temp || falseCount==Object.keys($scope.providerDetailsPleatTracker).length){
				$scope.collapse=false;
			}
			else{
				$scope.collapse=true;
			}
			if($scope.selectedPlan == undefined && $scope.releventPlans == undefined && $scope.nonReleventPlans == undefined){
						fetchAndSetPlanPleatInfo(vProId, vLocId);
			}
		}


				$scope.getSpecRating = function(index){
					var avgRat=0;
					var currStar='temp';
					for(var j=1;j<6;j++){
							currStar = $scope.getSpecificStarClass(index, j);
							if(currStar == 'pos'){
								avgRat = avgRat + 1;
							}else if(currStar == 'neg'){
								// avgRat = avgRat + 1;
							}else{
								avgRat = avgRat + 0.5;
							}
					}
					return avgRat;
				};

				$scope.getAvgRating = function(){
					var avgRat=0;
					var currStar='temp';
					for(var j=1;j<6;j++){
							currStar = $scope.getAverageStarClass(j);
							if(currStar == 'pos'){
								avgRat = avgRat + 1;
							}else if(currStar == 'neg'){
								// avgRat = avgRat + 1;
							}else{
								avgRat = avgRat + 0.5;
							}
					}
					return avgRat;
				};

				$scope.getStarImage = function(j){
							var starName='unrated_star.png';
							var currStar = $scope.getAverageStarClass(j);
							if(currStar == 'pos'){
									starName='rated_star.png';
							}else if(currStar == 'neg'){
									starName='unrated_star.png';
							}else{
									starName='star_half_rated.png';
							}
							return starName;
				};

				/* started report incorrect information functionality */
				$scope.publicMember = {};
				$scope.publicMember.firstName = '';
				$scope.publicMember.lastName = '';
				$scope.publicMember.email = '';

						//Report incorrect information object...
						$scope.reportInfo = {
								incAddress: false,
								incGender: false,
								incPhone: false,
								incSpeciality: false,
								incGroup: false,
								incDeceased: false,
								duplicateList: false,
								praLocation: false,
								noAccept: false,
								incindicates: false,
								incHospitalAff: false,
								incLanguage: false
							}

						$scope.reportIncorrectInfoData = function(data){
							$scope.currentProviderData = data;
							$scope.reportIncorrectDetailsFlag=true;
							angular.element("#incorrectInfo" ).show();
							setTimeout(function(){ $rootScope.focusForModal('incorrectInfo'); }, 100);
							angular.element("#incorrectInfo" ).css("display","block");
							angular.element("#incorrectInfo" ).addClass("fadeIn");
							angular.element("#incorrectInfo" ).removeClass("fade");
							angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
							if(data){
								if(window.location.href.indexOf("page=providerHospDetails") > -1){
											 $scope.reportProviderName = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full;
											 $scope.reportProviderPin = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerID;
											 $scope.reportProviderLocId = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].locationID;
											 if(data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine1 != undefined){
													 $scope.reportProviderAddressLine1 = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine1;
											 }
											 if(data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine2 != undefined){
													 $scope.reportProviderAddressLine2 = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine2;
											 }
											 if(data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine3 != undefined){
													 $scope.reportProviderAddressLine3 = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine3;
											 }
											 $scope.reportProviderAddressCity = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.city;
											 $scope.reportProviderAddressState = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.state;
											 $scope.reportProviderAddressZip = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.postalCode;
											 $scope.reportProviderAddressPhone = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.contacts[0].primaryPhone.number;
								} else if(window.location.href.indexOf("page=providerDetails") > -1){
											 $scope.reportProviderName = data.providerDetailsResponse.individualProviderDetails.practitioner.nameFull
											 $scope.reportProviderPin = data.providerDetailsResponse.individualProviderDetails.providerID;
											 $scope.reportProviderLocId = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID;
											 if(data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine1 != undefined){
													 $scope.reportProviderAddressLine1 = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine1;
											 }
											 if(data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine2 != undefined){
													 $scope.reportProviderAddressLine2 = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine2;
											 }
											 if(data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine3 != undefined){
													 $scope.reportProviderAddressLine3 = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine3;
											 }
											 $scope.reportProviderAddressCity = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.city;
											 $scope.reportProviderAddressState = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.state;
											 $scope.reportProviderAddressZip = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.postalCode;
											 $scope.reportProviderAddressPhone = data.providerDetailsResponse.individualProviderDetails.contacts[0].primaryPhone.number;
								} else if(window.location.href.indexOf("page=providerOrgDetails") > -1){
							 		 		 $scope.reportProviderName = data.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full;
									 		 $scope.reportProviderPin = data.providerDetailsResponse.organizationalProviderDetails.providerID;
									 		 $scope.reportProviderLocId = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].locationID;
									 		 if(data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine1 != undefined){
									 				 $scope.reportProviderAddressLine1 = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine1;
									 		 }
									 		 if(data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine2 != undefined){
									 				 $scope.reportProviderAddressLine2 = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine2;
									 		 }
									 		 if(data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine3 != undefined){
									 				 $scope.reportProviderAddressLine3 = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine3;
									 		 }
									 		 $scope.reportProviderAddressCity = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.city;
									 		 $scope.reportProviderAddressState = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.state;
									 		 $scope.reportProviderAddressZip = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.postalCode;
									 		 $scope.reportProviderAddressPhone = data.providerDetailsResponse.organizationalProviderDetails.contacts[0].primaryPhone.number;
								}else{}

								var stateTag = "RSP_PROVIDER_MSG_" + $scope.reportProviderAddressState;

		 						if( $scope['languageData'][stateTag] )
		 						{
		 							$scope.reportIncorrectInfoStateMsg = $scope['languageData'][stateTag];
		 						}
		 						else
		 						{
		 							$scope.reportIncorrectInfoStateMsg = null;
		 						}
							}
							if(($scope.RIPStateMessage && $scope.RIPMessageContent && data && data.providerData && data.providerData.providerAtLocation && data.providerData.providerAtLocation.officeContacts && data.providerData.providerAtLocation.officeContacts.postalAddresses && data.providerData.providerAtLocation.officeContacts.postalAddresses.state)){
								if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'CA'){
									if($scope.criteria.lang === 'en'){
										$scope.RIPTextMessage = $scope.RIPMessageContent.EN.CA;
									} else {
										 $scope.RIPTextMessage = $scope.RIPMessageContent.ES.CA;
									}
								} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'GA' || data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'CT'){
									if($scope.criteria.lang === 'en'){
											$scope.RIPTextMessage = $scope.RIPMessageContent.EN.GA;
										} else {
											$scope.RIPTextMessage = $scope.RIPMessageContent.ES.GA;
									}
								} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'TX'){
									if($scope.criteria.lang === 'en'){
										$scope.RIPTextMessage = $scope.RIPMessageContent.EN.TX;
									} else {
											$scope.RIPTextMessage = $scope.RIPMessageContent.ES.TX;
									}
								}

							}
						};

						$scope.isSelectedCorrectedData = function(){
									if($scope.reportInfo.incAddress || $scope.reportInfo.incGender
									|| $scope.reportInfo.incPhone || $scope.reportInfo.incSpeciality
									|| $scope.reportInfo.incGroup || $scope.reportInfo.incDeceased
									|| $scope.reportInfo.duplicateList || $scope.reportInfo.praLocation
									|| $scope.reportInfo.noAccept || $scope.reportInfo.incindicates
									|| $scope.reportInfo.incHospitalAff || $scope.reportInfo.incLanguage ){
										return false;
									} else {
										return true;
									}
						};

						//Submit Incorrect Info
						this.submitInfo = function(providerPage){
							var callNewFunctionality = false;
					
							if( $scope.languageData.USE_PRMS_FOR_REPORT_INCORRECT_INFO && 
					   			$scope.languageData.USE_PRMS_FOR_REPORT_INCORRECT_INFO ==  "ON" )
							{
								callNewFunctionality = true;
							}
							
							if (callNewFunctionality) {	
								var apiUrl;
							    var accessToken;									   
							    
							    if($sessionStorage.isExternal && $sessionStorage.isExternal == true) {
									apiUrl = configuration.externalReportIncorrectAPIURL;
								} else {
									apiUrl = configuration.internalReportIncorrectAPIURL;			
								}
							    
							    var requesterName = $scope.publicMember.firstName + ' ' + $scope.publicMember.lastName;
							    var requesterEmailId = $scope.publicMember.email;
							    var today = new Date();
								var formattedDateA = $filter('date')(today, 'yyyy-MM-dd');
								var formattedDateB = $filter('date')(today, 'yyyyMMddHHmmss');
							    							    							    							    
								if (providerPage == 'providerDetails') {									
									var providerName = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.practitioner.nameFull;
									var providerId = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.providerID;
									var providerStateCode = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.state;
									var providerType = 'Individual Provider';
									var providerLocationId = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID;									
								    var providerPhoneNumber = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.contacts[0].primaryPhone.number;
								    var providerAddress = $scope.currentProviderData.providerDetailsResponse.individualProviderDetails.providerLocations[0].address;
																											
								} else if (providerPage == 'providerOrgDetails') {								
									var providerName = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full;
									var providerId = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.providerID;
									var providerStateCode = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.state;
									var providerType = 'Non-Individual Provider';
									var providerLocationId = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].locationID;
								    var providerPhoneNumber = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.contacts[0].primaryPhone.number;
								    var providerAddress = $scope.currentProviderData.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address;																	    
									
								} else {								
									var providerName = $scope.currentProviderData.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full;
									var providerId = $scope.currentProviderData.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerID;
									var providerStateCode = $scope.currentProviderData.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.state;
									var providerType = 'Non-Individual Provider';
									var providerLocationId = $state.params.locId;								
								    var providerPhoneNumber = $scope.currentProviderData.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.contacts[0].primaryPhone.number;
								    var providerAddress = $scope.currentProviderData.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address;
								}			
								
								var description = "ProviderFullName : " + providerName + ' ; ' + 
							    "ProviderPIN : " + providerId + ' ; ' + 
							    "ProviderServiceLocationID : " + providerLocationId + " ; " + 
							    "ProviderType : " + $scope.providerType + " ; " +
							    "CorrectionType : " + $scope.chkedOptions + " ; " +
							    "ProviderPhoneNumber : " + providerPhoneNumber + " ; " +
							    "ProviderAddress : " + providerAddress.streetLine1 + ',' + providerAddress.city + ',' +
							    providerAddress.postalCode + ',' + providerAddress.state;															
																						    								    							    											    							    							    							    					    							    							    							    							    							    					     												    
						        ProviderResultsService.getTokenForReportIncorrect().then(
						            function success(response) {
						            	accessToken = response.data.access_token;
						                if (accessToken) {				             
						                    accessToken = 'Bearer ' + accessToken;
						                    var dataObj = {
						                        "salesforcecase": [{
						                            "origin": "DocFind",
						                            "subject": "DocFind - Data Correction Form",
						                            "priority": "Normal",
						                            "description": description,
						                            "externalId": "DocFind-" + formattedDateB,
						                            "account": {
						                                "name": providerName,
						                                "providerId": providerId,
						                                "externalId": "94~" + providerId
						                            },
						                            "providerCase": {
						                                "attestDate": formattedDateA,
						                                "sourceSystem": "EPDB",
						                                "maintainedBy": "Multiple",
						                                "changeType": "Change",
						                                "transactionName": providerType,
						                                "numberOfProvidersFacilities": "1",
						                                "primaryRoutingState": providerStateCode,
						                                "providerChanges": {
						                                    "effectiveDate": formattedDateA,
						                                    "requesterName": requesterName,
						                                    "requesterEmailId": requesterEmailId
						                                }
						                            }
						                        }]
						                    }
		
						                    $http({
						                        method: 'POST',
						                        url: apiUrl,
						                        headers: {
						                            'Content-Type': 'application/json',
						                            'Authorization': accessToken,
						                        },
						                        data: dataObj
						                    }).then(function successCallback(response) {
						                        // this callback will be called asynchronously
						                        // when the response is available				                    	
						                        console.log(response);
						                        alert('SUCCESS! \n\nResponse from service: \n' + JSON.stringify(response));
						                    }, function errorCallback(response) {
						                        // called asynchronously if an error occurs
						                        // or server returns response with an error status.				                    	
						                        console.log(response);
						                        alert('Some Error! \n\nResponse from service: \n' + JSON.stringify(response));
						                    });
						                }
						            },
						            function error(response) {
						                console.log("Some error occured");
						                console.log(response);
						            }
						        );
				    																				
							} else {
								$scope.reportIncorrectDetailInfo=false;
								var url = ProviderResultsService.submitData($scope.reportIncorrectInfo,$scope.currentProviderData, $scope.providerType, $scope.chkedOptions, false, $scope.publicMember);
								this.closeIncorrectInfo();
								$window.open(url, "_blank");

								/*.then(
										function success(response) {
											$scope.incorrectInfoSubmitted = true;
											$scope.incorrectInfoSuccess = response;
										},function error(response){
											$scope.incorrectInfoSubmitted = true;
																	$scope.incorrectInfoSuccess = response;
											});*/								
							}								
						}

						//Close report incorrect information popupAnchor
						this.closeIncorrectInfo = function() {
							$scope.reportIncorrectDetailsFlag=false;
							$scope.publicMember = {};
							$scope.publicMember.firstName = '';
							$scope.publicMember.lastName = '';
							$scope.publicMember.email = '';
							$scope.reportInfo ={
								incAddress: false,
								incGender: false,
								incPhone: false,
								incSpeciality: false,
								incGroup: false,
								incDeceased: false,
								duplicateList: false,
								praLocation: false,
								noAccept: false,
								incindicates: false,
								incHospitalAff: false,
								incLanguage: false
							}
							document.getElementById('provider-1').checked = false;
							document.getElementById('provider-2').checked = false;
							document.getElementById('provider-3').checked = false;
							document.getElementById('provider-4').checked = false;
							$scope.selectedProvider = "";
							$scope.providerType = "";
							$scope.chkedOptions = [];
							$scope.incorrectInfoSuccess = false;
							$scope.incorrectInfoSubmitted = false;
							angular.element("#incorrectInfo" ).hide();
							angular.element("#incorrectInfo" ).addClass("fade");
							angular.element("#incorrectInfo" ).removeClass("fadeIn");
							angular.element(".modal-backdrop" ).css("display","none");
						};

						$scope.chkedOptions = [];
						$scope.changeImage = function(data){
							// Make sure there is / or & added to chkedOptions.
							if(data === 'address'){
								$scope.reportInfo.incAddress = !$scope.reportInfo.incAddress;
								if($scope.reportInfo.incAddress){
									$scope.chkedOptions.push("Incorrect Address");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect Address');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'phone'){
								$scope.reportInfo.incPhone = !$scope.reportInfo.incPhone;
								if($scope.reportInfo.incPhone){
									$scope.chkedOptions.push("Incorrect Phone no");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect Phone no');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'gender'){
								$scope.reportInfo.incGender = !$scope.reportInfo.incGender;
								if($scope.reportInfo.incGender){
									$scope.chkedOptions.push("Incorrect gender");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect gender');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'speciality'){
								$scope.reportInfo.incSpeciality = !$scope.reportInfo.incSpeciality;
								if($scope.reportInfo.incSpeciality){
									$scope.chkedOptions.push("Incorrect speciality");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect speciality');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'group'){
								$scope.reportInfo.incGroup = !$scope.reportInfo.incGroup;
								if($scope.reportInfo.incGroup){
									$scope.chkedOptions.push("Incorrect Provider or group");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect Provider or group');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'deceased'){
								$scope.reportInfo.incDeceased = !$scope.reportInfo.incDeceased;
								if($scope.reportInfo.incDeceased){
									$scope.chkedOptions.push("Incorrect deceased");
								} else {
									var index = $scope.chkedOptions.indexOf('Incorrect deceased');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'duplicateList'){
								$scope.reportInfo.duplicateList = !$scope.reportInfo.duplicateList;
								if($scope.reportInfo.duplicateList){
									$scope.chkedOptions.push("Duplicate Listing");
								} else {
									var index = $scope.chkedOptions.indexOf('Duplicate Listing');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'praLocation'){
								$scope.reportInfo.praLocation = !$scope.reportInfo.praLocation;
								if($scope.reportInfo.praLocation){
									$scope.chkedOptions.push("Practitioner does not schedule appointments at service location listed");
								} else {
									var index = $scope.chkedOptions.indexOf('Practitioner does not schedule appointments at service location listed');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'noAccept'){
								$scope.reportInfo.noAccept = !$scope.reportInfo.noAccept;
								if($scope.reportInfo.noAccept){
									$scope.chkedOptions.push("No longer accepts new patients");
								} else {
									var index = $scope.chkedOptions.indexOf('No longer accepts new patients');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'incindicates'){
								$scope.reportInfo.incindicates = !$scope.reportInfo.incindicates;
								if($scope.reportInfo.incindicates){
									$scope.chkedOptions.push("Doctor indicates he or she no longer accepts Aetna Insurance");
								} else {
									var index = $scope.chkedOptions.indexOf('Doctor indicates he or she no longer accepts Aetna Insurance');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'hospitalAffliation'){
								$scope.reportInfo.incHospitalAff = !$scope.reportInfo.incHospitalAff;
								if($scope.reportInfo.incHospitalAff){
									$scope.chkedOptions.push("Hospital Affiliation incorrect");
								} else {
									var index = $scope.chkedOptions.indexOf('Hospital Affiliation incorrect');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							} else if(data === 'language'){
								$scope.reportInfo.incLanguage = !$scope.reportInfo.incLanguage;
								if($scope.reportInfo.incLanguage){
									$scope.chkedOptions.push("Language spoken incorrect or missing");
								} else {
									var index = $scope.chkedOptions.indexOf('Language spoken incorrect or missing');
									if(index!=-1){
										$scope.chkedOptions.splice(index, 1);
									}
								}
							}
						};

						//Set Selected Provider type

						$scope.setSelectedProvider = function(providerType){
							$scope.providerType = providerType;
						};

						/* Ended report incorrect information functionality*/




		$scope.accesibilityFunc1=function(){
			if($("#acc1").attr("aria-expanded")=="true"){
				$('#acc1').attr("class","collapsed noDecoration");
				$("#acc1").attr("aria-expanded","false");
				$("#acc1").attr("aria-pressed","false");
			}else{
				$('#acc1').attr("class","noDecoration");
				$("#acc1").attr("aria-expanded","true");
				$("#acc1").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc2=function(){
			if($("#acc2").attr("aria-expanded")=="true"){
				$('#acc2').attr("class","collapsed noDecoration");
				$("#acc2").attr("aria-expanded","false");
				$("#acc2").attr("aria-pressed","false");
			}else{
				$('#acc2').attr("class","noDecoration");
				$("#acc2").attr("aria-expanded","true");
				$("#acc2").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc4=function(){
			if($("#acc4").attr("aria-expanded")=="true"){
				$('#acc4').attr("class","collapsed noDecoration");
				$("#acc4").attr("aria-expanded","false");
				$("#acc4").attr("aria-pressed","false");
			}else{
				$('#acc4').attr("class","noDecoration");
				$("#acc4").attr("aria-expanded","true");
				$("#acc4").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc5=function(){
			if($("#acc5").attr("aria-expanded")=="true"){
				$('#acc5').attr("class","collapsed noDecoration");
				$("#acc5").attr("aria-expanded","false");
				$("#acc5").attr("aria-pressed","false");
			}else{
				$('#acc5').attr("class","noDecoration");
				$("#acc5").attr("aria-expanded","true");
				$("#acc5").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc6=function(){
			if($("#acc6").attr("aria-expanded")=="true"){
				$('#acc6').attr("class","collapsed noDecoration");
				$("#acc6").attr("aria-expanded","false");
				$("#acc6").attr("aria-pressed","false");
			}else{
				$('#acc6').attr("class","noDecoration");
				$("#acc6").attr("aria-expanded","true");
				$("#acc6").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc7=function(){
			if($("#acc7").attr("aria-expanded")=="true"){
				$('#acc7').attr("class","collapsed noDecoration");
				$("#acc7").attr("aria-expanded","false");
				$("#acc7").attr("aria-pressed","false");

			}else{
				$('#acc7').attr("class","noDecoration");
				$("#acc7").attr("aria-expanded","true");
				$("#acc7").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc8=function(){
			if($("#acc8").attr("aria-expanded")=="true"){
				$('#acc8').attr("class","collapsed noDecoration");
				$("#acc8").attr("aria-expanded","false");
				$("#acc8").attr("aria-pressed","false");
			}else{
				$('#acc8').attr("class","noDecoration");
				$("#acc8").attr("aria-expanded","true");
				$("#acc8").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFuncOtherOffice=function(){
			if($("#accOtherOffice").attr("aria-expanded")=="true"){
				$('#accOtherOffice').attr("class","collapsed noDecoration");
				$("#accOtherOffice").attr("aria-expanded","false");
				$("#accOtherOffice").attr("aria-pressed","false");
			}else{
				$('#accOtherOffice').attr("class","noDecoration");
				$("#accOtherOffice").attr("aria-expanded","true");
				$("#accOtherOffice").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFuncPlanDetails=function(){
			if($("#accPlanDetails").attr("aria-expanded")=="true"){
				$('#accPlanDetails').attr("class","collapsed noDecoration");
				$("#accPlanDetails").attr("aria-expanded","false");
				$("#accPlanDetails").attr("aria-pressed","false");
			}else{
				$('#accPlanDetails').attr("class","noDecoration");
				$("#accPlanDetails").attr("aria-expanded","true");
				$("#accPlanDetails").attr("aria-pressed","true");
			}
		}
		$scope.accesibilityFunc3=function(){
			if($("#expandCollapse").attr("aria-expanded")=="false"){
				$("#expandCollapse").attr("aria-expanded","true");
				$("#expandCollapse").attr("aria-pressed","true");
				$("#expandCollapse").attr("class","accordian-mobile");
				$('#expandCollapse').html('Collapse All')	;
				$scope.isCollapsedOne=false;
				$scope.isCollapsedThree=false;
			}else{
				$("#expandCollapse").attr("aria-expanded","false");
				$("#expandCollapse").attr("aria-pressed","false");
				$("#expandCollapse").attr("class","accordian-mobile");
				$('#expandCollapse').html('Expand All')	;
				$scope.isCollapsedOne=true;
				$scope.isCollapsedThree=true;
			}
			$scope.accesibilityFunc1();
			$scope.accesibilityFunc2();
		}

		$scope.displayBhTypeOfService=function(provider){
			if(  provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.hospitalProviderDetails &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.bhTypeOfService &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.bhTypeOfService[0] &&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.bhTypeOfService[0].description	&&
					provider.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.bhTypeOfService[0].description.length > 0){
				return true;
			}
			return false;
		}
		$scope.removeSeparator=function(description){
			var descriptionArr;
			var updatedArr = [];
			if(description !== undefined && description !== null){
				 descriptionArr = description.split("_separator_");
		 			for(var i=0;i<descriptionArr.length;i++){
		 				if(descriptionArr[i] != 'NONE'){
		 					updatedArr.push(descriptionArr[i]);
		 				}
		 			}
			}
			return updatedArr;
		}
		$scope.hasAdditionalLanguages=function(provider){
			if(	provider && provider.providerDetailsResponse &&
				provider.providerDetailsResponse.individualProviderDetails &&
				provider.providerDetailsResponse.individualProviderDetails.practitioner &&
				provider.providerDetailsResponse.individualProviderDetails.practitioner.languagesSpoken &&
				provider.providerDetailsResponse.individualProviderDetails.practitioner.languagesSpoken.length > 0 &&
				provider.providerDetailsResponse.individualProviderDetails.practitioner.languagesSpoken[0].description != 'None' &&
				provider.providerDetailsResponse.individualProviderDetails.practitioner.languagesSpoken[0].description != 'Ninguno'){
				return true;
			}else if(provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.individualProviderDetails &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].interpreterSupportedLanguage &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].interpreterSupportedLanguage.length > 0 &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].interpreterSupportedLanguage[0].description != '' &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].interpreterSupportedLanguage[0].description != 'None' &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].interpreterSupportedLanguage[0].description != 'Ninguno'){
				return true;
			}else if(provider && provider.providerDetailsResponse &&
					provider.providerDetailsResponse.individualProviderDetails &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].staffSupportedLanguage &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].staffSupportedLanguage.length > 0 &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].staffSupportedLanguage[0].description != '' &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].staffSupportedLanguage[0].description != 'None' &&
					provider.providerDetailsResponse.individualProviderDetails.providerLocations[0].staffSupportedLanguage[0].description != 'Ninguno'){
				return true;
			}
			return false;
		}
	}
})();

},{}],14:[function(require,module,exports){
(function() {
	angular
	.module('nav-ui')
	.controller('ProviderResultsController', ProviderResultsController);

	ProviderResultsController.$inject = ['$scope', '$http', 'configuration' ,'ProviderResultsService',
	'ProviderSearchCriteriaService','$q','$log','$filter','$state','$sessionStorage','usSpinnerService','$timeout',
	'$window','phoneFormatFilter','$rootScope',
	'NavSpinnerService','$translate', 'RatingsService', 'PdfService','AnalyticsService','mapsService',
	'CompareProviderService','$compile','LanguageDataService','CommonUtilsService'];

	function ProviderResultsController($scope, $http, configuration, ProviderResultsService,
	 ProviderSearchCriteriaService,$q,$log,$filter,$state,$sessionStorage,usSpinnerService,$timeout,
	 $window,phoneFormatFilter,$rootScope,
	 NavSpinnerService,$translate, RatingsService,PdfService,AnalyticsService,mapsService,
	 CompareProviderService,$compile,LanguageDataService,CommonUtilsService) {
		$rootScope.$on("destroyScope", function(){
				$scope.$destroy();
		 });
		 		// Detecting IE Browser
		 		function detectIE() {
		 		    var ua = window.navigator.userAgent;

		 		    var msie = ua.indexOf('MSIE ');
		 		    if (msie > 0) {
		 		        // IE 10 or older => return version number
		 		        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		 		    }

		 		    var trident = ua.indexOf('Trident/');
		 		    if (trident > 0) {
		 		        // IE 11 => return version number
		 		        var rv = ua.indexOf('rv:');
		 		        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		 		    }

		 		    var edge = ua.indexOf('Edge/');
		 		    if (edge > 0) {
		 		       // Edge (IE 12+) => return version number
		 		       return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
		 		    }

		 		    // other browser
		 		    return false;
		 		}
		 		 var isIE = detectIE();
		//console.log("In results controller : " + $scope.$id);

		

              /*var $tempLayoutID = angular.element(document.getElementById('comparePopUpInLayout'));
		$.get("components/publicProvider/compareDialogs.html", function(data){
				$tempLayoutID.append(data);
		}).done(function() {
				if($scope.ComparePopupCreated !== true){
					  var $comparePopupID = angular.element(document.getElementById('#comparePopUp'));
						$compile($tempLayoutID)($scope);
						return;
				}
		});*/




		// var $tempLayoutID = angular.element(document.getElementById('#comparePopUpInLayout'));
		// var $comparePopupID = angular.element(document.getElementById('#comparePopUp'));
		// $tempLayoutID.append($comparePopupID);
		// $compile($tempLayoutID)($scope);

		// var tempLayoutID=$element.parent().children('#skipPlan');
		// angular.element('.menu-list').append($element);
		// $compile(tempLayoutID)($scope);
		 		 
		$sessionStorage.hereUsingBrowserBackButton;
		ProviderResultsService.scrollTo = '';
		ProviderSearchCriteriaService.setPlanPleatShow(false);
		$scope.showDebbugger=false;
		$scope.isPageReady=false;
		if (window.location.href.indexOf("providerResults") != -1){
			$( "#provider-srch" ).addClass( "dateFix" );
		}
		if (window.location.href.indexOf("providerResults") != -1){
			$( "#provider-Results-id" ).addClass( "dateFix2" );
		}
		$scope.providerRes = "";
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.languageData = LanguageDataService.getLanguageData();
		$sessionStorage.filterSameResults = false; // Used for calling same results but with filtering
		
		// Below code will preserve the distance on refresh.
		// if($scope.criteria.groupIPAaPI!=''){
	  //   var distanceIndex = $scope.criteria.groupIPAaPI.indexOf("distance=");
	  //   var distanceOldVal = $scope.criteria.groupIPAaPI.substring(distanceIndex+9, distanceIndex+11);
		// 	$scope.criteria.distance = distanceOldVal;
		// }

		if (window.location.href.indexOf("brC=true") != -1){
			$state.params.proId = '';
			$state.params.locId = '';
			$state.params.pType = '';
			$state.params.distance = '';
			$scope.criteria.isResetFilter = true;
			$scope.criteria.fromDetailsStart = true;
			$sessionStorage.criteria.fromDetailsStart = true;
			// console.log("resetfilter startanewSearch"+ $scope.criteria.isResetFilter);
			ProviderResultsService.scrollTo = '';
			ProviderSearchCriteriaService.setPlanPleatShow(false);
			// if($state.params.page == "providerHospDetails" && $scope.criteria.hospitalId != ''){
			// 	$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:'', hosId:$scope.criteria.hospitalId, hosName:$scope.criteria.hospitalName});
			// }else{
			// 	ProviderResultsService.setHospitalId('');
			// 	$scope.criteria.hospitalId = '';
			// 	$scope.criteria.hospitalName = '';
			// 	$state.go('contentPage',{page:'providerResults', locId:'', pType:'', distance:'', proId:'', site_id:siteId, language:language, parameters:''});
			// }
		}


		/* This variable : $scope.criteria.searchFocus is used to dim the screen for small
		 * devices when typeahead is opened. Resetting the value here since if the user goes to
		 * LandingPage using Aetna logo from Results page without using start A new search button
		 * the value is true and plan list page is Dimmed. */
		$scope.criteria.searchFocus = false;

		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		// if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
		//  			return $state.go('contentPage',{page:'providerSearchLanding',parameters:'',site_id:siteId,language:language});
		// }
		// console.log("reset:"+$scope.criteria.isResetFilter);
		//$scope.criteria.direction = '';
		var resultsService = ProviderResultsService;
		resultsService.resultSearch = 0;
		$scope.searchStatus = 'notSearching';

		if($sessionStorage.criteria.browserBack == true){ // setting back filter values and alphasort values in case of backbutton
				$scope.criteria.isResetFilter = true;
				$scope.criteria.browserBack = false;
				$sessionStorage.criteria.browserBack = false;
		}

		if($sessionStorage.visitedDetails == 1){
			$scope.fromDetailsStart = true;
			$scope.criteria.isResetFilter = true;
			$sessionStorage.visitedDetails = 0;
		}else{
			$scope.fromDetailsStart = false;
		}

		$scope.sortOrder=($scope.criteria.isResetFilter && $scope.criteria.filterOrder) ? $scope.criteria.filterOrder : null;
		$scope.compareListArray=[];
		var selectedFilters =($scope.criteria.isResetFilter && $scope.criteria.selectedFilters) ? $scope.criteria.selectedFilters : "";
		$scope.reportIncorrectInfo = configuration.reportIncorrectInfo;
		ProviderSearchCriteriaService.setOrder($scope.sortOrder);
		var listSelections=($scope.criteria.isResetFilter && $scope.criteria.listSelections) ? $scope.criteria.listSelections : null;
		$scope.showPrintDirectory=false;
		ProviderSearchCriteriaService.setListSelection(listSelections);
		$sessionStorage.criteria.listSelections = listSelections;
		$scope.errorCode = "";
		$scope.backendError=false;
		// ACNLA5_1202_MS SR - Changes start
		$scope.NYAdequecyError = false;
		// ACNLA5_1202_MS SR - Changes end
		$scope.pinSearch=false;
		$scope.fromDetails = false;
		$scope.isShowSortFilterWindow=false;
		$scope.showFilterContent=($scope.criteria.isResetFilter && $scope.criteria.showFilterContent) ? $scope.criteria.showFilterContent:[];
		$scope.showSecLevelContent=($scope.criteria.isResetFilter && $scope.criteria.showSecLevelContent) ? $scope.criteria.showSecLevelContent:[];
		$scope.checkedItem=($scope.criteria.isResetFilter && $scope.criteria.checkedItem) ? $scope.criteria.checkedItem : [];
		$scope.checkedItemChildren=($scope.criteria.isResetFilter && $scope.criteria.checkedItemChildren) ? $scope.criteria.checkedItemChildren : [];
		$scope.checkedContentItem=[];
		$scope.showFirstLevel=true;
		$scope.checkedSecondLevelContentItem=[];
		var isFirstNavigate = true;
		$scope.isArray = angular.isArray;
		$scope.printDirectoryURL = configuration.printDirectoryURL;
		var filterResultsFocus = false;
		$scope.responseErrorDesc = '';
		$scope.responseErrorTitle = '';
		$scope.triggerMessages = [];


		if($state.current.name.indexOf('provSearch')==-1)
			$scope.displayOR = false;
		else
			$scope.displayOR = true;

		resultsService = ProviderResultsService;
		$scope.compareListArray=[];
		var compareData = resultsService.compareData;
		compareData.showCompare = false;
		CompareProviderService.reset();

		function toArray(input)
		{
			if(input!= undefined){
				if (angular.isArray(input)) {
					return input;
				} else {
					return [input];
				}
			}

		};

		// toggle language between English and Spanish or use specified language
		$scope.changeLanguage = function(lang) {
			if (lang == null || lang == undefined) {
				var lang = $translate.use();
				lang = lang == 'en' ? 'es' : 'en';
			}
			// start over on the search page when switching languages
			// $state.go('contentPage',{page:'providerSearch',language:lang});
		};

		
		// Below code would be to suppress distance sort in case of find doctors of the same hospitals
		if(ProviderResultsService.getFindDoctors()){
			$scope.sameHospital = true;
		}else{
			$scope.sameHospital = false;
		}
		
		
		if($scope.criteria.findDocPrevId === null){
			ProviderResultsService.setFindDoctors("");
		}

	 if($state.params.hosId!=null && $state.params.hosId!=undefined && $state.params.hosId!=''){
	 					ProviderResultsService.setHospitalId($state.params.hosId);
						$scope.criteria.hospitalName = $state.params.hosName;
						$scope.criteria.hospitalId = $state.params.hosId;
						$scope.criteria.isProviderForHospital = true;
						$scope.criteria.isProviderForIPA = false;
						$scope.criteria.isProviderForGroup = false;
						/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
						$scope.criteria.isFindDoctor = false;
						$scope.criteria.findDocPrevId = null;
	 }
	 else
	 {
		 $scope.criteria.isProviderForHospital = false;
	 }

 	 if(($state.params.proOrgDispName!=null && $state.params.proOrgDispName!=undefined && $state.params.proOrgDispName!='') ||
			($state.params.proOrgName!=null && $state.params.proOrgName!=undefined && $state.params.proOrgName!='') ){
			 	if($state.params.poin != 'NA'){
				 		ProviderResultsService.setIpaDetails($state.params.poin);
				 		$scope.criteria.ipaName = $state.params.proOrgName;
						$sessionStorage.criteria.ipaName = $state.params.proOrgName;
				 		$scope.criteria.isProviderForIPA = true;
				 		$scope.criteria.isProviderForGroup = false;
				 		$scope.criteria.isProviderForHospital = false;
				 		$scope.criteria.isFindDoctor = false;
						$scope.criteria.findDocPrevId = null;
			 	}
			 	else{
			 		if( $state.params.assocProvSrchGrp != null && $state.params.assocProvSrchGrp != undefined && $state.params.assocProvSrchGrp == 'Y' )
						ProviderResultsService.setGroupdetails($state.params.groupProId,$state.params.proOrgDispName,true);
					else
						ProviderResultsService.setGroupdetails($state.params.groupProId,$state.params.proOrgDispName,false);
			 		$rootScope.grpName = $state.params.proOrgDispName;
			 		$scope.criteria.isProviderForGroup = true;
			 		$scope.criteria.isProviderForIPA = false;
			 		$scope.criteria.isProviderForHospital = false;
			 		$scope.criteria.isFindDoctor = false;
					$scope.criteria.findDocPrevId = null;
			 	}
	 }else{
		 if($scope.criteria.fromDetailsStart != undefined && $scope.criteria.fromDetailsStart == true && ($scope.criteria.isProviderForGroup == true || $scope.criteria.isProviderForIPA == true)){
							$scope.criteria.groupIPAClicked == false;
							$sessionStorage.criteria.groupIPAClicked == false;
		 					// ProviderResultsService.setHideDistance(true);
		 					// $scope.hideDistanceVal=$scope.getHideDistanceFlag();

							console.log("$scope.criteria"+$scope.criteria);
							console.log("$sessionStorage.criteria : "+$sessionStorage.criteria);
		 					if($scope.criteria.isProviderForGroup == true){
		 							$scope.criteria.isProviderForIPA = false;
		 							// console.log("\n\n\n\n$scope.criteria.groupId"+$scope.criteria.groupId);
		 							// console.log("$rootScope.grpName"+$rootScope.grpName);
		 							// console.log("$scope.criteria.groupName"+$scope.criteria.groupName);
									// console.log("$sessionStorage.criteria.groupName : "+$sessionStorage.criteria.groupName);
		 					}else{
		 							$scope.criteria.isProviderForGroup = false;
		 							/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
		 							$scope.criteria.isProviderForIPA = true;

		 							// console.log("$scope.criteria.ipaId "+ $scope.criteria.ipaId);
		 							// console.log("$scope.criteria.ipaName "+$scope.criteria.ipaName);
									// console.log("$sessionStorage.criteria.ipaId : "+$sessionStorage.criteria.ipaId);
									// console.log("$sessionStorage.criteria.ipaName : "+$sessionStorage.criteria.ipaName);

									$scope.criteria = ProviderSearchCriteriaService.getCriteria();
									$sessionStorage.criteria = ProviderSearchCriteriaService.getCriteria();

		 							// console.log("\n\n\n$scope.criteria.ipaId "+ $scope.criteria.ipaId);
		 							// console.log("$scope.criteria.ipaName "+$scope.criteria.ipaName);
									// console.log("$sessionStorage.criteria.ipaId : "+$sessionStorage.criteria.ipaId);
									// console.log("$sessionStorage.criteria.ipaName : "+$sessionStorage.criteria.ipaName);
		 					}
		 					$scope.criteria.isProviderForHospital = false;
		 					$scope.criteria.isFindDoctor = false;
		 					$scope.criteria.findDocPrevId = null;
		 					$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;

		 					// ProviderResultsService.setGroupdetails(group.providerGroup.providerIdentifier.idValue,group.providerGroup.providerDisplayName.full);
		 					// ProviderResultsService.setIpaDetails(group.poin);
		 					//create URL for this search. It can be the same as the the search.
		 }else{
				 $scope.criteria.isProviderForGroup = false;
				 /*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
			 	 $scope.criteria.isProviderForIPA = false;

			 	ProviderResultsService.setIpaDetails("");
		 		$scope.criteria.ipaName = "";
		 		$sessionStorage.criteria.ipaName = "";
		 		$rootScope.grpName = "";
		 }
	 }

		// set the classes to produce the stars for 10 levels of accuracy
		var starClassNames = ["neg","neg","posneg","posneg","posneg","posneg","posneg","posneg","pos","pos"];
		RatingsService.setStarClassNames(starClassNames);

		// expose ratings functionality
		$scope.ratingStatus = RatingsService.ratingStatus;
		var getRating = RatingsService.getRating;
		$scope.getStarClass = RatingsService.getStarClass;
		$scope.getNumberOfRatings = RatingsService.getNumberOfRatings;

		$rootScope.changeShowDebbugger=function(){
			$scope.showDebbugger=!$scope.showDebbugger;
		}

		/* started report incorrect information functionality */
		$scope.publicMember = {};
		$scope.publicMember.firstName = '';
		$scope.publicMember.lastName = '';
		$scope.publicMember.email = '';

		$scope.statusBeg = $scope.criteria.isResetFilter ? $scope.criteria.statusBeg : true;
		console.log(" 1 : true : $scope.statusBeg" + $scope.statusBeg );
		$scope.statusLast = $scope.criteria.isResetFilter ? $scope.criteria.statusLast : false;
		$scope.criteria.isAlphaSort = $scope.criteria.isResetFilter ? $scope.criteria.isAlphaSort : false;
		$sessionStorage.criteria.isAlphaSort = $scope.criteria.isResetFilter ? $scope.criteria.isAlphaSort : false;
		var defaultAlphabets = ['Num','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
		var tempArray = $scope.criteria.isResetFilter ? ($scope.criteria.selectedListArray != undefined ? $scope.criteria.selectedListArray : []): [];
				//Report incorrect information object...
				$scope.reportInfo = {
						incAddress: false,
						incGender: false,
						incPhone: false,
						incSpeciality: false,
						incGroup: false,
						incDeceased: false,
						duplicateList: false,
						praLocation: false,
						noAccept: false,
						incindicates: false,
						incHospitalAff: false,
						incLanguage: false
					}
					if($scope.languageData.SWITCH_DISPLAY_RIP == 'NONE'){
						$scope.reportIncorrectInfoLink=false;
					}else {
						$scope.reportIncorrectInfoLink=true;
					}
				var currentProviderData;
				var reportProviderType;
				$scope.reportIncorrectInfoData = function(data){
					$scope.reportIncorrectFlag=true;
					currentProviderData = data;
					angular.element("#incorrectInfo" ).show();
					setTimeout(function(){ $rootScope.focusForModal('incorrectInfo'); }, 100);
					angular.element("#incorrectInfo" ).css("display","block");
					angular.element("#incorrectInfo" ).addClass("fadeIn");
					angular.element("#incorrectInfo" ).removeClass("fade");
					angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
					if(data){
							if(data.providerInformation){
									$scope.reportProviderId = data.providerInformation.providerID;
									 $scope.reportProviderName = data.providerInformation.providerDisplayName.full;
			 						 $scope.reportProviderPin = data.providerInformation.providerIdentifier.idValue;
			 						 $scope.reportProviderLocId = data.providerLocations.locationID;
			 						 reportProviderType = data.providerInformation.type;
									 if(data.providerLocations.address.streetLine1 != undefined){
				 	 						 $scope.reportProviderAddressLine1 = data.providerLocations.address.streetLine1;
									 }
									 if(data.providerLocations.address.streetLine2 != undefined){
				 	 						 $scope.reportProviderAddressLine2 = data.providerLocations.address.streetLine2;
									 }
									 if(data.providerLocations.address.streetLine3 != undefined){
				 	 						 $scope.reportProviderAddressLine3 = data.providerLocations.address.streetLine3;
									 }
			 						 $scope.reportProviderAddressCity = data.providerLocations.address.city;
			 						 $scope.reportProviderAddressState = data.providerLocations.address.state;
			 						 $scope.reportProviderAddressZip = data.providerLocations.address.postalCode;
			 						 $scope.reportProviderAddressPhone = data.contacts.primaryPhone.number;

			 						var stateTag = "RSP_PROVIDER_MSG_" + $scope.reportProviderAddressState;

			 						if( $scope['languageData'][stateTag] )
			 						{
			 							$scope.reportIncorrectInfoStateMsg = $scope['languageData'][stateTag];
			 						}
			 						else
			 						{
			 							$scope.reportIncorrectInfoStateMsg = null;
			 						}
									//  if($scope.reportProviderAddressState == 'CA'){
									// 			$scope.CAMsg = true;
									//  }else if($scope.reportProviderAddressState == 'GA'){
									 //
									//  }else if($scope.reportProviderAddressState == 'TX'){
									 //
									//  }
							}
					}

					if(($scope.RIPStateMessage && $scope.RIPMessageContent && data && data.providerData && data.providerData.providerAtLocation && data.providerData.providerAtLocation.officeContacts && data.providerData.providerAtLocation.officeContacts.postalAddresses && data.providerData.providerAtLocation.officeContacts.postalAddresses.state)){
						if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'CA'){
							if($scope.criteria.lang === 'en'){
								$scope.RIPTextMessage = $scope.RIPMessageContent.EN.CA;
							} else {
								 $scope.RIPTextMessage = $scope.RIPMessageContent.ES.CA;
							}
						} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'GA' || data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'CT'){
							if($scope.criteria.lang === 'en'){
									$scope.RIPTextMessage = $scope.RIPMessageContent.EN.GA;
								} else {
									$scope.RIPTextMessage = $scope.RIPMessageContent.ES.GA;
							}
						} else if(data.providerData.providerAtLocation.officeContacts.postalAddresses.state === 'TX'){
							if($scope.criteria.lang === 'en'){
								$scope.RIPTextMessage = $scope.RIPMessageContent.EN.TX;
							} else {
									$scope.RIPTextMessage = $scope.RIPMessageContent.ES.TX;
							}
						}

					}
				};

				$scope.isSelectedCorrectedData = function(){
							if($scope.reportInfo.incAddress || $scope.reportInfo.incGender || $scope.reportInfo.incPhone || $scope.reportInfo.incSpeciality || $scope.reportInfo.incGroup || $scope.reportInfo.incDeceased || $scope.reportInfo.duplicateList || $scope.reportInfo.praLocation || $scope.reportInfo.noAccept || $scope.reportInfo.incindicates || $scope.reportInfo.incHospitalAff || $scope.reportInfo.incLanguage){
								return false;
							} else {
								return true;
							}
				};

				//Submit Incorrect Info
				this.submitInfo = function() {
					var callNewFunctionality = false;
					
					if( $scope.languageData.USE_PRMS_FOR_REPORT_INCORRECT_INFO && 
					   	$scope.languageData.USE_PRMS_FOR_REPORT_INCORRECT_INFO ==  "ON" )
					{
						callNewFunctionality = true;
					}
				    	
				    if (callNewFunctionality) {
				    	var apiUrl;
					    var accessToken;									   
					    
					    if($sessionStorage.isExternal && $sessionStorage.isExternal == true) {
							apiUrl = configuration.externalReportIncorrectAPIURL;
						} else {
							apiUrl = configuration.internalReportIncorrectAPIURL;			
						}
					    
					    var requesterName = $scope.publicMember.firstName + ' ' + $scope.publicMember.lastName;
					    var requesterEmailId = $scope.publicMember.email;
					    var providerName = currentProviderData.providerInformation.providerDisplayName.full;
					    var providerId = currentProviderData.providerInformation.providerID;
					    var providerStateCode = currentProviderData.providerLocations.address.state;
					    var providerType = currentProviderData.providerInformation.type;					    
					    var providerLocationId = currentProviderData.providerLocations.locationID;
					    var providerPhoneNumber = currentProviderData.providerLocations.contacts.phonesVoice.number;
					    var providerAddress = currentProviderData.providerLocations.address;
					    var description = "ProviderFullName : " + providerName + ' ; ' + 
					    "ProviderPIN : " + providerId + ' ; ' + 
					    "ProviderServiceLocationID : " + providerLocationId + " ; " + 
					    "ProviderType : " + $scope.providerType + " ; " +
					    "CorrectionType : " + chkedOptions + " ; " +
					    "ProviderPhoneNumber : " + providerPhoneNumber + " ; " +
					    "ProviderAddress : " + providerAddress.streetLine1 + ',' + providerAddress.city + ',' +
					    providerAddress.postalCode + ',' + providerAddress.state;
					    
					    var today = new Date();
					    var formattedDateA = $filter('date')(today, 'yyyy-MM-dd');
					    var formattedDateB = $filter('date')(today, 'yyyyMMddhhmmss');
					    
					    if (providerType == 'Individual' || providerType == null || providerType == undefined) {
					    	providerType = 'Individual Provider';
					    } else {
					    	providerType = 'Non-Individual Provider';
					    }					     					 
					    
				        ProviderResultsService.getTokenForReportIncorrect().then(
				            function success(response) {
				            	accessToken = response.data.access_token;
				                if (accessToken) {				             
				                    accessToken = 'Bearer ' + accessToken;
				                    var dataObj = {
				                        "salesforcecase": [{
				                            "origin": "DocFind",
				                            "subject": "DocFind - Data Correction Form",
				                            "priority": "Normal",
				                            "description": description,
				                            "externalId": "DocFind-" + formattedDateB,
				                            "account": {
				                                "name": providerName,
				                                "providerId": providerId,
				                                "externalId": "94~" + providerId
				                            },
				                            "providerCase": {
				                                "attestDate": formattedDateA,
				                                "sourceSystem": "EPDB",
				                                "maintainedBy": "Multiple",
				                                "changeType": "Change",
				                                "transactionName": providerType,
				                                "numberOfProvidersFacilities": "1",
				                                "primaryRoutingState": providerStateCode,
				                                "providerChanges": {
				                                    "effectiveDate": formattedDateA,
				                                    "requesterName": requesterName,
				                                    "requesterEmailId": requesterEmailId
				                                }
				                            }
				                        }]
				                    }

				                    $http({
				                        method: 'POST',
				                        url: apiUrl,
				                        headers: {
				                            'Content-Type': 'application/json',
				                            'Authorization': accessToken,
				                        },
				                        data: dataObj
				                    }).then(function successCallback(response) {
				                        // this callback will be called asynchronously
				                        // when the response is available				                    	
				                        console.log(response);
				                        alert('SUCCESS! \n\nResponse from service: \n' + JSON.stringify(response));
				                    }, function errorCallback(response) {
				                        // called asynchronously if an error occurs
				                        // or server returns response with an error status.				                    	
				                        console.log(response);
				                        alert('Some Error! \n\nResponse from service: \n' + JSON.stringify(response));
				                    });
				                }
				            },
				            function error(response) {
				                console.log("Some error occured");
				                console.log(response);
				            }
				        );
				    } else {
				        $scope.reportIncorrectFlag = false;
				        var url = ProviderResultsService.submitData(
				            $scope.reportIncorrectInfo, currentProviderData, $scope.providerType,
				            chkedOptions, false, $scope.publicMember);
				        this.closeIncorrectInfo();
				        $window.open(url, "_blank");


				        /*.then(
				                      function success(response) {
				                             $scope.incorrectInfoSubmitted = true;
				                             $scope.incorrectInfoSuccess = response;
				                      },function error(response){
				                             $scope.incorrectInfoSubmitted = true;
				                             $scope.incorrectInfoSuccess = response;
				                             });*/
				    }
				}
				
				//Close report incorrect information popupAnchor
				var chkedOptions = [];
				this.closeIncorrectInfo = function() {
					$scope.reportIncorrectFlag=false;
					$scope.publicMember = {};
					$scope.publicMember.firstName = '';
					$scope.publicMember.lastName = '';
					$scope.publicMember.email = '';
					$scope.reportInfo ={
						incAddress: false,
						incGender: false,
						incPhone: false,
						incSpeciality: false,
						incGroup: false,
						incDeceased: false,
						duplicateList: false,
						praLocation: false,
						noAccept: false,
						incindicates: false,
						incHospitalAff: false,
						incLanguage: false
					}
					document.getElementById('provider-1').checked = false;
					document.getElementById('provider-2').checked = false;
					document.getElementById('provider-3').checked = false;
					document.getElementById('provider-4').checked = false;
					$scope.selectedProvider = "";
					$scope.providerType = "";
					chkedOptions = [];
					$scope.incorrectInfoSuccess = false;
					$scope.incorrectInfoSubmitted = false;
					angular.element("#incorrectInfo" ).hide();
					angular.element("#incorrectInfo" ).addClass("fade");
					angular.element("#incorrectInfo" ).removeClass("fadeIn");
					angular.element(".modal-backdrop" ).css("display","none");
				};

				chkedOptions = [];
				$scope.changeImage = function(data){
					// Make sure there is / or & added to chkedOptions.


					if(data === 'address'){
						$scope.reportInfo.incAddress = !$scope.reportInfo.incAddress;
						if($scope.reportInfo.incAddress){
							chkedOptions.push("Incorrect Address");
						} else {
							var index = chkedOptions.indexOf('Incorrect Address');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'phone'){
						$scope.reportInfo.incPhone = !$scope.reportInfo.incPhone;
						if($scope.reportInfo.incPhone){
							chkedOptions.push("Incorrect Phone no");
						} else {
							var index = chkedOptions.indexOf('Incorrect Phone no');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'gender'){
						$scope.reportInfo.incGender = !$scope.reportInfo.incGender;
						if($scope.reportInfo.incGender){
							chkedOptions.push("Incorrect gender");
						} else {
							var index = chkedOptions.indexOf('Incorrect gender');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'speciality'){
						$scope.reportInfo.incSpeciality = !$scope.reportInfo.incSpeciality;
						if($scope.reportInfo.incSpeciality){
							chkedOptions.push("Incorrect speciality");
						} else {
							var index = chkedOptions.indexOf('Incorrect speciality');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'group'){
						$scope.reportInfo.incGroup = !$scope.reportInfo.incGroup;
						if($scope.reportInfo.incGroup){
							chkedOptions.push("Incorrect Provider or group");
						} else {
							var index = chkedOptions.indexOf('Incorrect Provider or group');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'deceased'){
						$scope.reportInfo.incDeceased = !$scope.reportInfo.incDeceased;
						if($scope.reportInfo.incDeceased){
							chkedOptions.push("Incorrect deceased");
						} else {
							var index = chkedOptions.indexOf('Incorrect deceased');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'duplicateList'){
						$scope.reportInfo.duplicateList = !$scope.reportInfo.duplicateList;
						if($scope.reportInfo.duplicateList){
							chkedOptions.push("Duplicate Listing");
						} else {
							var index = chkedOptions.indexOf('Duplicate Listing');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'praLocation'){
						$scope.reportInfo.praLocation = !$scope.reportInfo.praLocation;
						if($scope.reportInfo.praLocation){
							chkedOptions.push("Practitioner does not schedule appointments at service location listed");
						} else {
							var index = chkedOptions.indexOf('Practitioner does not schedule appointments at service location listed');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'noAccept'){
						$scope.reportInfo.noAccept = !$scope.reportInfo.noAccept;
						if($scope.reportInfo.noAccept){
							chkedOptions.push("No longer accepts new patients");
						} else {
							var index = chkedOptions.indexOf('No longer accepts new patients');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'incindicates'){
						$scope.reportInfo.incindicates = !$scope.reportInfo.incindicates;
						if($scope.reportInfo.incindicates){
							chkedOptions.push("Doctor indicates he or she no longer accepts Aetna Insurance");
						} else {
							var index = chkedOptions.indexOf('Doctor indicates he or she no longer accepts Aetna Insurance');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'hospitalAffliation'){
						$scope.reportInfo.incHospitalAff = !$scope.reportInfo.incHospitalAff;
						if($scope.reportInfo.incHospitalAff){
							chkedOptions.push("Hospital Affiliation incorrect");
						} else {
							var index = chkedOptions.indexOf('Hospital Affiliation incorrect');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					} else if(data === 'language'){
						$scope.reportInfo.incLanguage = !$scope.reportInfo.incLanguage;
						if($scope.reportInfo.incLanguage){
							chkedOptions.push("Language spoken incorrect or missing");
						} else {
							var index = chkedOptions.indexOf('Language spoken incorrect or missing');
							if(index!=-1){
								chkedOptions.splice(index, 1);
							}
						}
					}
				};

				//Set Selected Provider type

				$scope.setSelectedProvider = function(providerType){
					$scope.providerType = providerType;
				};

				/* Ended report incorrect information functionality*/

				$scope.getStarImage = function(providerId, j){
							var starName='unrated_star.png';
							var currStar = $scope.getStarClass(providerId,j);
							if(currStar == 'pos'){
									starName='rated_star.png';
							}else if(currStar == 'neg'){
									starName='unrated_star.png';
							}else{
									starName='star_half_rated.png';
							}
							return starName;
				};

				$scope.getAvgRating = function(providerId){
					var avgRat=0;
					var currStar='temp';
					for(var j=1;j<6;j++){
							currStar = $scope.getStarClass(providerId,j);
							if(currStar == 'pos'){
								avgRat = avgRat + 1;
							}else if(currStar == 'neg'){
								// avgRat = avgRat + 1;
							}else{
								avgRat = avgRat + 0.5;
							}
					}
					return avgRat;
				};

		// Filter code starts here -------------------------------------------------- //
		var cancelFilter=ProviderResultsService.getCancelFilter();
		var OkFilter=ProviderResultsService.getOkFilter();

		if($scope.criteria.isResetFilter){
					if($scope.checkedItem.length !== 0){
								for(var i=0;i<$scope.checkedItem.length;i++){
										if($scope.checkedItem[i]){
											$scope.isReset = true;
										}
								}
					}
		}

		//Shows the content on clicking of navigation tabs on the left side.
		var clearContentFilter = function()
		{
			var a=$scope.providerRes.listAttributes.length;
			for(var i=0;i<a;i++){
				$scope.showFilterContent[i]=false;
			}
			$scope.criteria.showFilterContent = $scope.showFilterContent;
		};

		//Shows the content on clicking of navigation tabs on the left side.
		$scope.showContent=function($event,index){
						$event.stopPropagation();
						var a=$scope.providerRes.listAttributes.length;
						for(var i=0;i<a;i++){
								if(index==i){
										$scope.showFilterContent[i]=true;
										$scope.showFirstLevel=true;
										var tempSecondDisp = $scope.checkedItemChildren;
										if(Array.isArray(tempSecondDisp[i][0])){
													for(var ij=0;ij<tempSecondDisp[i].length;ij++){
																	$scope.showSecLevelContent[ij] = false;
													}
										}
								}else{
										$scope.showFilterContent[i]=false;
								}
						}
						$scope.criteria.showFilterContent = $scope.showFilterContent;
		};

		$scope.handleAccessibility=function(index){
			var liitems=$('.accessControl');
			for (var i = 0; i < liitems.length; i++) {
				if(index===i){
					var specificItem=liitems[i];
					$(specificItem).attr('aria-expanded',true);
				}
				else{
					var specificItem=liitems[i];
					$(specificItem).attr('aria-expanded',false);
				}
			}
		}

		var bindArrorWithFilterTabs=function(){
				$('.accessControl').on('keydown', function (e) {
	        if ([38,40].indexOf(e.keyCode) == -1) {
	            return;
	        }
	        var link = $(this);
	        switch(e.keyCode) {
	            case 38:
	                    e.preventDefault();
											if(link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').first().length == 0) {
			                    // Focus on the last item in the top level
			                    link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').last().find('a').first().focus();
			                } else {
			                    // Focus on the previous item in the top level
			                    link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').first().find('a').first().focus();
			                }
	                break;
	            case 40:
									e.preventDefault();
									if(link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').first().length == 0){
										link.closest('li .filterRows').prevAll('li .filterRows').filter(':visible').last().find('a').first().focus();
									}
									else{
										link.closest('li .filterRows').nextAll('li .filterRows').filter(':visible').first().find('a').first().focus();
									}
	                break;
	        }
	    });
		}

		$scope.focusForFilterTabs=function(){
			var inputs = $('#'+idModal).find('select, input, textarea, button, a, iframe').filter(':visible');
		                var firstInput = inputs.first();
		                var lastInput = inputs.last();
		                firstInput.focus();
		                lastInput.on('keydown', function (e) {
		                    if ((e.which === 9 && !e.shiftKey) ) {
		                        e.preventDefault();
		                        firstInput.focus();
		                    }

		                });
		                firstInput.on('keydown', function (e) {
		                    if ((e.which === 9 && e.shiftKey) ) {
		                        e.preventDefault();
		                        lastInput.focus();
		                    }

		                });
		            $(".iframeFocus").on('keydown', function (e) {
		                    if ((e.which === 9 && !e.shiftKey) ) {
		                        e.preventDefault();
		                        firstInput.focus();
		                    }
		                });
		}

		//Reset the filters array and or set the selected filters for display
		function createArrayForListFilters(){
						// if($scope.comingFromToggleCheckbox){
						// 		$scope.comingFromToggleCheckbox =false;
						// 		return;
						// }
						var a=$scope.providerRes.listAttributes.length;
						$scope.isLeveltwo =[];
						$scope.showFilterContent=[];
						$scope.criteria.showFilterContent =[];
						$scope.showSecLevelContent=[];
						$scope.criteria.showSecLevelContent =[];

						for(var i=0;i<a;i++){
										$scope.checkedItem[i]=false;
										$scope.checkedItemChildren[i]=[];
										if($scope.providerRes.listAttributes[i].listFilters.length>1){
												$scope.isLeveltwo[i] = true;
												var childrenArray = $scope.providerRes.listAttributes[i].listFilters.length;
												for(var y=0; y<childrenArray; y++){
													if($scope.providerRes.listAttributes[i].listFilters[y].listFilter.description != undefined){
															var objToArrayFil = [];
															objToArrayFil.push($scope.providerRes.listAttributes[i].listFilters[y].listFilter);
															$scope.providerRes.listAttributes[i].listFilters[y].listFilter = objToArrayFil;
													}
														var itemSubChildren = $scope.providerRes.listAttributes[i].listFilters[y].listFilter.length;
														$scope.checkedItemChildren[i][y]=[];
														for(var z=0; z<itemSubChildren; z++){
																$scope.checkedItemChildren[i][y][z]=false;
																// ---------------- Put in the stored filters ------------------
																var code = $scope.providerRes.listAttributes[i].listFilters[y].listFilter[z].code + $scope.providerRes.listAttributes[i].listFilters[y].description;//+y;
																if (selectedFilters.indexOf(code)!= -1)
																{
																	$scope.checkedItem[i]=true;
																	$scope.checkedItemChildren[i][y][z]=true;
																	angular.element("#Filter"+i).removeClass("unchkLabelPrvSrch");
																	angular.element("#Filter"+i).addClass("filterAdded");
																	$scope.isReset=true;
																}
																// -------------------------------------------------------------
														}
												}
										}else{
															$scope.isLeveltwo[i] = false;
															/*var listFilterstoArray = $filter('toArray')($scope.providerRes.listAttributes[i].listFilters);*/
															var itemChildren = $scope.providerRes.listAttributes[i].listFilters[0].listFilter.length;
															if(itemChildren == undefined){
																		var listFilterstoArray = $filter('toArray')($scope.providerRes.listAttributes[i].listFilters[0].listFilter);
																		itemChildren = listFilterstoArray.length;
															}
															for(var k=0; k<itemChildren; k++){
																	$scope.checkedItemChildren[i][k]=false;
																	// ---------------- Put in the stored filters ------------------

																	var code;
																	if($scope.providerRes.listAttributes[i].listFilters[0].listFilter.length == undefined){
																			code = $scope.providerRes.listAttributes[i].listFilters[0].listFilter.code
																	}else{
																			code = $scope.providerRes.listAttributes[i].listFilters[0].listFilter[k].code;
																	}

																	if (selectedFilters.indexOf(code)!= -1)
																	{
																		$scope.checkedItem[i]=true;
																		$scope.checkedItemChildren[i][k]=true;
																		angular.element("#Filter"+i).removeClass("unchkLabelPrvSrch");
																		angular.element("#Filter"+i).addClass("filterAdded");
																		$scope.isReset=true;
																	}
																	// -------------------------------------------------------------
															}
										}
						}
						$scope.criteria.checkedItem = $scope.checkedItem;
						$scope.criteria.checkedItemChildren = $scope.checkedItemChildren;
						$sessionStorage.criteria.checkedItem = $scope.checkedItem;
						$sessionStorage.criteria.checkedItemChildren = $scope.checkedItemChildren;
		};

		//For checking and unchecking of checkboxes.
		var isToggleCheckBox = false;
		var comingFromToggleCheckbox = false;
		$scope.toggleCheckbox=function(index, parentIndex, childIndex){



						isToggleCheckBox = true;
						isFirstNavigate = true;
						comingFromToggleCheckbox=true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								$scope.checkedItemChildren[parentIndex][index]=!$scope.checkedItemChildren[parentIndex][index];
								if($scope.checkedItemChildren[parentIndex][index]){
										$scope.checkedItem[parentIndex]=true;
										angular.element("#Filter"+parentIndex).addClass("filterAdded");
										$scope.isReset=true;
								}else{
										var temp = $scope.checkedItemChildren[parentIndex].length;
										for(var c=0; c<temp; c++){
												if($scope.checkedItemChildren[parentIndex][c]){
													$scope.checkedItem[parentIndex]=true;
													$scope.isReset=true;
													angular.element("#Filter"+parentIndex).addClass("filterAdded");
													break;
												}
												else {
													$scope.isReset=false;
													$scope.checkedItem[parentIndex]=false;
												}
										}
								}
						}else{
								$scope.checkedItemChildren[parentIndex][index][childIndex]=!$scope.checkedItemChildren[parentIndex][index][childIndex];
								if($scope.checkedItemChildren[parentIndex][index][childIndex]){
										$scope.checkedItem[parentIndex]=true;
										angular.element("#Filter"+parentIndex).addClass("filterAdded");
										$scope.isReset=true;
								}else{
											var tempSecOne = $scope.checkedItemChildren[parentIndex].length;
											var tempSecTwo = $scope.checkedItemChildren[parentIndex][index].length;
											listFilterOuterLoop:
												for(var j=0; j<tempSecOne; j++){
															listFilterInnerLoop:
																for(var i=0;i<tempSecTwo;i++)
																{
																			if($scope.checkedItemChildren[parentIndex][j][i]){
																						$scope.checkedItem[parentIndex]=true;
																						$scope.isReset=true;
																						angular.element("#Filter"+parentIndex).addClass("filterAdded");
																						break listFilterOuterLoop;
																			}
																			else {
																						$scope.isReset=false;
																						$scope.checkedItem[parentIndex]=false;
																			}
																}
												}
								}
						}
		};

		//For show and hide of filter window on clicking of filter icon on the results page.
		var isShowCompareWindow = false;
		$scope.filterFlag=false;
		$scope.toggleFilterWindow=function($event){
			$scope.filterFlag=!$scope.filterFlag;
			if (!$scope.criteria.isAlphaSort) {
					if(!$scope.criteria.isResetFilter || isToggleCheckBox || !$scope.criteria.isAlphaSort){
						createArrayForListFilters();
					}
					isShowCompareWindow=false;
					$event.stopPropagation();
					$scope.isShowSortFilterWindow=!$scope.isShowSortFilterWindow;
					if($scope.isShowSortFilterWindow){
						var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables()  };
						//for local
						//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
						//for QA
						// var url = configuration.backURLResults + siteId + "&language=" + language;
						var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
						url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
						history.replaceState(stateObj, "Aetna",url);
											// if (history.state === null) {
											//   console.log("\n\n\n\n din't reload, just pushed \n\n\n\n ");
											//   history.pushState(stateObj, "Aetna",url);
											// } else {
											//   history.replaceState(stateObj, "Aetna",url);
											// }

						// history.replaceState(stateObj, "Aetna", url); // Need to Check

						clearContentFilter();
						$('.filterOptions').show();
						$('.filterOptions').css('z-index',1);
						setTimeout(function(){ $rootScope.focusForModal('filterOptionsModal'); }, 100);
						bindArrorWithFilterTabs();
					}
					else{
						$('.filterOptions').hide();
					}
			}

			secondaryDisp: {
						if($scope.filterFlag == true){
									var tempSecond = $scope.checkedItemChildren;
									for(var ffi=0;ffi<tempSecond.length;ffi++){
													if(Array.isArray(tempSecond[ffi][0])){
																		for(var ij=0;ij<tempSecond[ffi].length;ij++){
																						if(tempSecond[ffi][ij].indexOf(true) !== -1){
																										$scope.showFilterContent[ffi] = true;
																										$scope.showFirstLevel = false;
																										$scope.showSecLevelContent[ij] = true;
																								    break secondaryDisp;
																						}
																		}
													}
									}
						}
			}

		};

		//For showing second level content of doctor facility
		$scope.showSecondLevelContent=function($event,index,arr){
						//$scope.checkedSecondLevelContentItem[index]=[];
						$event.stopPropagation();
						$scope.showFirstLevel=false;
						var a=arr.length;
						for(var i=0;i<a;i++){
							if(index==i){
								$scope.showSecLevelContent[i]=true;
							}
							else{
								$scope.showSecLevelContent[i]=false;
							}
						}
						$scope.criteria.showSecLevelContent = $scope.showSecLevelContent;
		};

		//For showing back first level content of doctor facility
		$scope.backToFilterFirstLevel=function(index){ // Passed by Sumit
						$scope.showSecLevelContent[index]=false;
						$scope.showFirstLevel=true;
		};

		//On click of clearall button clears all the checkboxes.
		$scope.clearAll=function(index, parentIndex, childIndex){
						isToggleCheckBox = true;
						isFirstNavigate = true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								//
								var itemArray=[];
								var tempObj=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								if(tempObj.length == undefined){
									itemArray.push(tempObj);
								}else{
									itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								}
								// var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][j]=false;
								}
								$scope.checkedItem[parentIndex]=false;
						}else{
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[index].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][index][j]=false;
								}
								var tempClrSecOne = $scope.checkedItemChildren[parentIndex].length;
								var tempClrSecTwo = $scope.checkedItemChildren[parentIndex][index].length;
								listClearAllFilterOuterLoop:
									for(var j=0; j<tempClrSecOne; j++){
										listClearAllFilterInnerLoop:
											for(var i=0; i<tempClrSecTwo; i++)
											{
												if($scope.checkedItemChildren[parentIndex][j][i]){
													$scope.checkedItem[parentIndex]=true;
													break listClearAllFilterOuterLoop;
												}
												else {
													$scope.checkedItem[parentIndex]=false;
												}
											}
									}
						}
						for(var i=0; i<a; i++){
								if($scope.checkedItem[i]){
									$scope.isReset=true;
									break;
								}else{
									$scope.isReset=false;
								}
						}
		};

		//On click of checkall button checks all the checkboxes.
		$scope.checkAll=function(index, parentIndex, childIndex){
						isToggleCheckBox = true;
						isFirstNavigate = true;
						var a=$scope.providerRes.listAttributes.length;
						if(childIndex == null){
								//
								var itemArray=[];
								var tempObj=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								console.log(tempObj.length)
								if(tempObj.length == undefined){
									itemArray.push(tempObj);
								}else{
									itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								}
								// var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[0].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][j]=true;
								}
						}else{
								var itemArray=$scope.providerRes.listAttributes[parentIndex].listFilters[index].listFilter;
								for(var j=0; j<itemArray.length; j++){
											$scope.checkedItemChildren[parentIndex][index][j]=true;
								}
						}
						$scope.checkedItem[parentIndex]=true;
						$scope.isReset=true;
		};

		//For reseting the filters
		$scope.filterReset=function(){
					$scope.filterFlag=false;
					$scope.isReset=false;
					$scope.checkedItem=[];
					$scope.checkedItemChildren=[];
					selectedFilters = "";
					isToggleCheckBox = true;
					isFirstNavigate = true;
					clearContentFilter();
					ProviderResultsService.setCancelFilter(true);
					listSelections = "";
					ProviderSearchCriteriaService.setListSelection(listSelections);
					$sessionStorage.criteria.listSelections = "";
					fetchProviderResults();
					filterResultsFocus=true;
					$scope.isShowSortFilterWindow=false;
					$('.filterOptions').hide();
					$scope.criteria.checkedItem = $scope.checkedItem;
					$scope.criteria.checkedItemChildren = $scope.checkedItemChildren;

					$sessionStorage.criteria.checkedItem = $scope.checkedItem;
					$sessionStorage.criteria.checkedItemChildren = $scope.checkedItemChildren;
		};



		//For closing the filter window on click of close icon.
		$scope.closeFilterSortWindow=function($event){
			$scope.filterFlag=false;
						$event.stopPropagation();
						$scope.isShowSortFilterWindow=false;
						clearContentFilter();
						$('.filterOptions').hide();
		};
		//For creating the selections made for the filter and sort.
		$scope.sortValueChange=function(){ // Need to check by Sumit

			$scope.filterFlag=false;
			filterResultsFocus=true;
			AnalyticsService.markFilterAndSort();

			listSelections=encodeURIComponent('['+createListSelection().join(',')+']');
			ProviderSearchCriteriaService.setListSelection(listSelections);
			$sessionStorage.criteria.listSelections = listSelections;
			ProviderSearchCriteriaService.setOrder($scope.sortOrder);
			$sessionStorage.criteria.order = $scope.sortOrder;

			$sessionStorage.filterSameResults = true;

			fetchProviderResults();
			$scope.isShowSortFilterWindow=false;
			$('.filterOptions').hide();
			ProviderResultsService.setOkFilter(true);

			stateObj = {'stateAPI': $scope.criteria, 
					'History.length': history.length,
					'resultState' : ProviderResultsService.getAllVariables() };
			
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.pushState(stateObj, "Aetna", url);


			var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
			url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
			history.pushState(stateObj, "Aetna",url);

		};

		function createListSelection(isAlphaSort,alphabet,isReset){
			if(isReset){

				return tempArray;
			}
			else {
			var listFilterCode=[];
			var listFilterName=[];
			var arr=[];
			var code='';
			var name='';
			var listAttributes=$scope.providerRes.listAttributes;
			var listSelection='';
			//Reset selected Filters everytime results is called.
					if(!isAlphaSort){
			selectedFilters = "";
					}


			for(var i=0;i<listAttributes.length;i++){
						var filterObj=listAttributes.slice(i,i+1)[0];
						listSelection='';
						listFilterCode=[];
						listFilterName=[];
								listSelection=listSelection+'{';
								if(!isAlphaSort && $scope.checkedItem[i]){
								if(listAttributes[i].listFilters.length==1){
												var a=$filter('toArray')(filterObj.listFilters[0].listFilter);
												for(var j=0;j<a.length;j++){
															var listFilterObj=a.slice(j,j+1)[0];
															if($scope.checkedItemChildren[i][j]){
																		code=listFilterObj.code.split(":")[1];
																		name=listFilterObj.code.split(":")[0];
																		listFilterCode.push(code);
																		//TO store the selected filters.
																		selectedFilters = selectedFilters + listFilterObj.code;
															}
												}
												var selectedCode=listFilterCode.join('$');
												// listSelection=listSelection+'listAttributeName='+name+'%%listFilterCode='+selectedCode+')';
												listSelection=listSelection+'"listAttributeName":'+'\"'+name+'\"'+',"listFilterCode":'+'\"'+selectedCode+'\"'+'}';
												arr.push(listSelection);
								}else{
												for(var k=0;k<filterObj.listFilters.length;k++){
															var listFilterFirstLevelObj=filterObj.listFilters.slice(k,k+1)[0];
															if(listFilterFirstLevelObj.listFilter.description != undefined){
																	var objToArray = [];
																	objToArray.push(listFilterFirstLevelObj.listFilter);
																	listFilterFirstLevelObj.listFilter = objToArray;
															}
															for(var l=0;l<listFilterFirstLevelObj.listFilter.length;l++){
																		var listFilterSecondLevelObj=listFilterFirstLevelObj.listFilter.slice(l,l+1)[0];
																		if($scope.checkedItemChildren[i][k][l]){
																					code=listFilterSecondLevelObj.code.split(":")[1];
																					name=listFilterSecondLevelObj.code.split(":")[0];
																					listFilterCode.push(code);
																					listFilterName.push(name);
																					//TO store the selected filters.
																					selectedFilters = selectedFilters + listFilterSecondLevelObj.code + listFilterFirstLevelObj.description;// + k;
																		}
															}
															// var selectedCode=listFilterCode.join('$'); // removed
												}

											for(var xx=0;xx<listFilterCode.length;xx++){
												listSelection=listSelection+'"listAttributeName":'+'\"'+listFilterName[xx]+'\"'+',"listFilterCode":'+'\"'+listFilterCode[xx]+'\"'+'}';
												arr.push(listSelection);
												 listSelection = "{";
											}

								}
						}
								if((isAlphaSort && i === listAttributes.length-1) || ($scope.criteria.isAlphaSort && i === listAttributes.length-1)){
									/* if($scope.criteria.isAlphaSort){
										alphabet = $scope.criteria.alphaSet;
										console.log(alphabet);
									} */
									if(alphabet){
										arr = tempArray;
										code=alphabet.code.split(":")[1];
										name=alphabet.code.split(":")[0];
										//$scope.selectedFilters = $scope.selectedFilters + alphabet.code;
										listSelection=listSelection+'"listAttributeName":'+'\"'+name+'\"'+',"listFilterCode":'+'\"'+code+'\"'+'}';
										// listSelection=listSelection+'(listAttributeName='+name+'%%listFilterCode='+code+')';
										arr.push(listSelection);
			}
								}
				}

			/* Find Doctors fix*/
			if( $scope.criteria.hospitalNavigator && $scope.criteria.hospitalNavigator != '' )
			{
				arr.push( $scope.criteria.hospitalNavigator );
			}
			/**/

				tempArray = arr;
				$scope.criteria.selectedFilters = selectedFilters;
				$scope.criteria.selectedListArray = tempArray;
				$sessionStorage.criteria.selectedFilters = selectedFilters;
				$sessionStorage.criteria.selectedListArray = tempArray;

			return arr;
			}
		};
		// Filter code ends here -------------------------------------------------- //

		var newSearchClicked=ProviderResultsService.getNewSearchClicked();

		if(newSearchClicked==true || cancelFilter==true || $scope.okFilter==true){
			showCostButtonIndicator=false;
		}else{
			showCostButtonIndicator=true;
		}

		var getHideDistanceFlag = function()
		{
			var hide = ProviderResultsService.getHideDistance();
			//reset the value
			ProviderResultsService.setHideDistance(false);
			return hide;
		};

		var reset = function(){
			ProviderSearchCriteriaService.init();
			$scope.criteria.typeAheadSearch = '';
			$scope.criteria.isProviderForGroup = false;
			/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
			$scope.criteria.isProviderForIPA = false;
			$scope.criteria.isProviderForHospital = false;
			$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;
			ProviderResultsService.setNewSearchClicked(true);
			ProviderResultsService.setHospitalId('');
			$scope.hideDistanceVal=getHideDistanceFlag();

		}

		//console.log("SearchText from Parent scope : "+ $scope.$parent.searchText);
		//console.log("isGuidedSearch =" + $scope.$parent.isGuidedSearch);

		 if($state.params.searchTerm!=null && $state.params.searchTerm!=undefined)
		 {
			 $scope.criteria.searchText = $state.params.searchTerm;
			 //$scope.criteria.searchTextForBackEnd = $state.params.searchTerm;
		 }
		 
		 /* IOQ changes */
		 if( $state.params.searchTextForBackEnd != null && $state.params.searchTextForBackEnd != undefined )
		 {
			 $scope.criteria.searchTextForBackEnd = $state.params.searchTextForBackEnd;
		 }
		 else
		 {
			 $scope.criteria.searchTextForBackEnd = '';
		 }

		/** 
		 * When the user came via guided search and did a start new search and selected a value from typeahead
		 * The parent scope isGuidedSearch and searchText reamin the one from earlier guided search.
		 * Issue fixed by explicitly deleting "$parent.$parent" attributes
		 */
		/**This is for guided search only **/
		if($state.params.parameters!==null && $state.params.parameters!==undefined)
		{
			if($state.params.parameters.indexOf('isGuidedSearch=true')!=-1){
				$scope.criteria.isGuidedSearch=true;
			}
			else{
				$scope.criteria.isGuidedSearch=false;
			}
		}

		var isGuidedSearch = $scope.criteria.isGuidedSearch || $state.params.isGuidedSearch;
		if($scope.$parent!=null && $scope.$parent!=undefined && $scope.$parent.isGuidedSearch!=undefined)
			isGuidedSearch = isGuidedSearch || $scope.$parent.isGuidedSearch;
		/** For guided search only**/
		if(isGuidedSearch || isGuidedSearch == "true"){
			$scope.criteria.isGuidedSearch = true;
			if($scope.$parent.searchText!=null && $scope.$parent.searchText!=undefined)
			{
				//This is to support search text that have an & in them. The idea is to use ^ but dispay & to the user.
				// Similarly, before calling results service, we need to send '&'
				$scope.criteria.searchText = $scope.$parent.searchText.replace("^","&");
				$scope.criteria.searchText = $scope.criteria.searchText.replace("*","'");
				
				if( $scope.$parent.searchTextForBackEnd !=null && $scope.$parent.searchTextForBackEnd != undefined )
				{
					$scope.criteria.searchTextForBackEnd = $scope.$parent.searchTextForBackEnd.replace("^","&");
					$scope.criteria.searchTextForBackEnd = $scope.criteria.searchTextForBackEnd.replace("*","'");
				}
			}
			else
			{
				if($state.params.searchText!=null && $state.params.searchText!=undefined)
				{
					$scope.criteria.searchText = $state.params.searchText;
				}
				if( $state.params.searchTextForBackEnd !=null && $state.params.searchTextForBackEnd != undefined )
				{
					$scope.criteria.searchTextForBackEnd = $state.params.searchTextForBackEnd;
				}
			}
			//Once set, again initialize the parameters to null so that they get re-initiased on every page load.
			//When we get the paraeter, it gets it from all the nested parents. But when deleting it, we need to explicilty delete it.
			$scope.$parent.$parent.isGuidedSearch = null;
			$scope.$parent.$parent.searchText=null;
			$scope.$parent.$parent.searchTextForBackEnd=null;
		}


		$scope.searchText = $scope.criteria.searchText;
		$scope.searchTextForBackEnd = $scope.criteria.searchTextForBackEnd;
		// $scope.Fname = ProviderSearchCriteriaService.getSelectedMemberFName();

		/* For initial typeahead search for a group - Save state later to be used for browser back button */
		if ( ! $sessionStorage.hereUsingBrowserBackButton && $scope.criteria.typeahead 
		    	&& $scope.criteria.typeahead.subcategory === 'group' )
		{
			var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };

			var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
			url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
			history.replaceState(stateObj, "Aetna",url);
			
			$sessionStorage.hereUsingBrowserBackButton = false;
		}


		fetchProviderResults();

		//For show and hide of compare window on clicking of compare icon on the results page.
		$scope.toggleCompareWindow=function($event){
			$scope.isShowSortFilterWindow=false;
			$event.stopPropagation();
			isShowCompareWindow=!isShowCompareWindow;
			if(isShowCompareWindow){
				$('.compareOptions').show();
			}
			else{
				$('.compareOptions').hide();
			}
			//$('.filterOptions ul li a').addClass('nav-tabs');
		};

		//Action performed on clicking change Location link
		$scope.changelocClicked=function(){
			// $state.go('contentPage',{page:'providerSearch'});
		};

		//On clicking cross icon in compare window
		$scope.compareDialogClose=function(){
			isShowCompareWindow=false;
			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");
		};

		$scope.addtoFavorites = function(idx)
		{
			/*if($scope.providerRes.Providers[idx].fav == true)
				$scope.providerRes.Providers[idx].fav = false;
			else
				$scope.providerRes.Providers[idx].fav = true;
			 */

		};

		$scope.startanewSearch= function()
		{
			reset();
			var lang = $translate.use();
			$scope.criteria.searchFocus = false;
			$scope.criteria.isResetFilter = false;
			$scope.criteria.filterOrder = '';
			// console.log("resetfilter startanewSearch results"+ $scope.criteria.isResetFilter);
			$scope.criteria.checkedItem = [];
			$scope.criteria.checkedItemChildren = [];
			$scope.criteria.showFilterContent=[];
			$scope.criteria.showSecLevelContent=[];
			$scope.criteria.listSelections = null;
			$sessionStorage.criteria.listSelections = null;
			$scope.criteria.direction = '';
			$scope.criteria.order = '';
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			$scope.criteria.selectedFilters = '';
			$scope.criteria.selectedListArray = [];
			$scope.criteria.isProviderForIPA = false;
	 		$scope.criteria.isProviderForGroup = false;
	 		/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
	 		$scope.criteria.isProviderForHospital = false;
	 		$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.criteria.typeAheadSearch = '';
			$scope.criteria.browserCurrentAPI = '';
			$scope.criteria.browserBackAPI = '';

			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;
			ProviderResultsService.setHospitalId('');
			ProviderResultsService.setIpaDetails('');
			ProviderResultsService.setFindDoctors("");
			ProviderResultsService.setGroupdetails('','',false);
			$scope.criteria.groupIPAaPI = "";
			$sessionStorage.criteria.groupIPAaPI = "";
			$scope.criteria.findDocPrevId = "";
	 		$scope.criteria.ipaName = '';
			$sessionStorage.criteria.ipaName = "";
	 		$rootScope.grpName = '';
	 		$state.params.poin='';

			//$state.params.parameters='';
			$state.go('contentPage',{page:'providerSearch',parameters:'',
				site_id:siteId,language:language,poin:'',proOrgName:'',hosId:'',hosName:'',proOrgDispName:'',groupProId:'',assocProvSrchGrp:''});
		};


		/**
		 * The watch function to call the fetchProviderResults gets calls multiple times as the unbinding of it has not occured.
		 * To unbind this, we need to store the scope id of the results controller and only let that controller's watchbe triggered.
		 * The scope ID of the results controller will be stored in the results service everytime it loads.
		 * So this way only the latest watch be invoked. This will avoid duplicate calls to the API.
		 * If there is a better way to do , please let me know.
		 */

		resultsService.results_scopeID = $scope.$id;

		var unbindWatch = $scope.$watch(function(scope) {return resultsService.resultSearch},
				function(newValue, oldValue) {
					//	console.log("In Watch : " + $scope.$id);
					if(resultsService.results_scopeID == $scope.$id){
						// Do not call the results service when its loaded the first time.
						if(newValue != oldValue && newValue > 0)
							fetchProviderResults();
						//	console.log("Scope Belongs to currrent Controller : "+ $scope.$id);
					}
					else{
						//console.log("Unbind watch : " + $scope.$id);
						//Unbind watch for previous scopes.
						unbindWatch();
					}
				}
		);
		var paginationDisable=false;

		function fetchProviderResults() {
			// Return the status if no results are found.  The status is based on the type of
			// thing the user was searching for
			function getNotFoundStatus(result) {
/* TO Do : remove providersResponse */
				if(result.status
						&& ((result.providersResponse.status.statusCode && (result.providersResponse.status.statusCode == '3000'
 						|| result.providersResponse.status.statusCode == '3010'))
							||(result.providersResponse.status.detail && result.providersResponse.status.detail == 'Backend Service Error' || result.providersResponse.status.detail == 'Data Related Error')
							||(result.providersResponse.status.additionalStatus && result.providersResponse.status.additionalStatus.detail && result.providersResponse.status.additionalStatus.detail == 'ServiceException'))){
					$scope.criteria.serviceError = true;
					return 'searchError';
				}
				//console.log("$scope.criteria");
				//console.log($scope.criteria);
					if ($scope.criteria && $scope.criteria.typeahead && $scope.criteria.typeahead.aetnaid) {
						// user selected a provider but it wasn't returned
						return 'noSpecified';
					} else {
						return 'noType';
					}
			}
			if(paginationDisable){
				$scope.statusBeg=true;
				console.log(" 2 : true : $scope.statusBeg" + $scope.statusBeg );
				$scope.statusLast=false;
				paginationDisable=false;
			}
			if($scope.criteria.direction == ''){
				$scope.statusBeg=true;
				console.log(" 3 : true : $scope.statusBeg" + $scope.statusBeg );
				$scope.statusLast=false;
			}
			$scope.searchStatus = 'searching';
			$scope.backendError=false;
			// ACNLA5_1202_MS SR - Changes start
			$scope.NYAdequecyError = false;
			// ACNLA5_1202_MS SR - Changes end
			//Start the spinner when we are fetching results.
			var myElement = angular.element( document.querySelector('#newNavSpinner2'));
			if(myElement[0]==null || myElement[0]==undefined){
				NavSpinnerService.spin();
			}

			// clear the ratings data from any previous search
			RatingsService.initialize();
			var resultsReturned = false;
			var indexForCost = 0;
			ProviderResultsService.getResults()  // Removed the parameter as it was for PS features. Earlier it was --> "ProviderResultsService.getResults($scope.providerSearch)"
			.then(
				function success(result) {
					var reportingData = {};

					$scope.errorCode = "";
					$scope.responseErrorDesc = '';
					$scope.responseErrorTitle = '';
					$scope.compareListArray = [];
					CompareProviderService.reset();
					$scope.pinSearch=false;
					$scope.searchStatus = 'doneSearching';
					$scope.criteria.typeAheadSearch = '';  // clear so next search starts over
					//End Spinner
					//NavSpinnerService.stop();
					// promise was fullfilled (regardless of outcome)
					// checks for information will be peformed here
					$scope.providerRes = result.providersResponse.readProvidersResponse;

					//console.log("$scope.providerRes :: ");
					//console.log($scope.providerRes);
					if($scope.providerRes!=null && $scope.providerRes.providerInfoResponses != undefined )
					{

						$scope.providerRes.providerInfoResponses =
							 $filter('toArray')($scope.providerRes.providerInfoResponses);
						for(var i=0;i<3;i++){
							$scope.compareListArray.push($scope.providerRes.providerInfoResponses[i]);
						}
						//console.log($scope.compareListArray);
						$scope.criteria.compareListArray=$scope.compareListArray;
						CompareProviderService.setProvidersToCompare($scope.compareListArray);
					}
					if($scope.providerRes != "" && $scope.providerRes != null && $scope.providerRes != undefined &&
							$scope.providerRes.listInfoExchanges != null && $scope.providerRes.listInfoExchanges != undefined){
						fetchFauxRows();
					}
					//console.log("providerRes: " + JSON.stringify($scope.providerRes))
					if($scope.providerRes != null && $scope.providerRes != undefined && $scope.providerRes != ""){
						if($scope.providerRes.interfacePaging && $scope.providerRes.interfacePaging.paging && $scope.providerRes.interfacePaging.paging.order)
							$scope.sortOrder = $scope.providerRes.interfacePaging.paging.order;
						else
							$scope.sortOrder = 'BestMatch';
						  $scope.criteria.filterOrder = $scope.sortOrder;
						var totalProviders;
						try {
							totalProviders = parseInt($scope.providerRes.interfacePaging.paging.total);
						} catch (e) {
							totalProviders = 0;
						}

                        // AnalyticsService.trackSearch({
                        //     term: $scope.criteria.searchText,
                        //     results: totalProviders,
                        //     zipcode: $scope.criteria.typeAheadLocationResults.zipcode
                        // });

						//console.log("results object returned: " + totalProviders);
						if(totalProviders > 0 )
						{
							//$scope.setMapType();
							$scope.isPageReady=true;
							resultsReturned = true;
							//if($scope.guestUser!=true)
							fillInTierMessageIds(); // needed for highlighting different tier message types
							indexForCost=0;
							// $scope.fetchCosts();
							fetchRatings();

							/* After APIC has removed mapping listFilters is not an array : Converting to array to minimize impact*/

							$scope.providerRes.listAttributes = $filter('toArray')($scope.providerRes.listAttributes);
							var numberOfFilters = $scope.providerRes.listAttributes.length;

							for( var i = 0 ; i < numberOfFilters ; i++)
							{
								$scope.providerRes.listAttributes[i].listFilters =
									$filter('toArray')($scope.providerRes.listAttributes[i].listFilters);
							}
							/**/

							setAlphabets($scope.providerRes);

							createMapInformation();
							$scope.medicare = ProviderResultsService.identifyMedicareMember;
							// planfitindicator check for all providers <Starts>
							var isAllsPlanfitFalse = true;
							var providerList = [];
							if ($scope.providerRes && $scope.providerRes.providerInfoResponses != undefined && !angular.isArray($scope.providerRes.providerInfoResponses)) {
								providerList.push($scope.providerRes.providerInfoResponses);
							}else{
								providerList = $scope.providerRes.providerInfoResponses;
							}

							var IPAsGroupsSplit = [];
					    var IPAsGroupsSeparators = ['_CAP_OFFICE_SEPARATOR_','_SPECIALTIES_SEPARATOR_'];
   						// var String=str.substring(str.indexOf("_CAP_SEPTR_")+11,str.indexOf("_SPE_SEPTR_")!=-1?str.indexOf("_SPE_SEPTR_"):str.length);
							
							// ACNLA5_1103_MS SR - Changes start
					    if (providerList != undefined) {
					    // ACNLA5_1103_MS SR - Changes end	
					    	for(var i=0;i<providerList.length;i++){
									if(isAllsPlanfitFalse != false && providerList[i].providerPlanFitIndicator == 'true'){
										isAllsPlanfitFalse = false;
									}
	
									if(providerList[i].associatedGroups != undefined && (providerList[i].associatedGroups != null || providerList[i].associatedGroups.length)){
											 providerList[i].associatedGroups = $filter('toArray')(providerList[i].associatedGroups);
										   if(providerList[i].associatedGroups.length != undefined){
														for(var x=0;x<providerList[i].associatedGroups.length;x++){
	 															 IPAsGroupsSplit = providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																 if(providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																	  providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
	 															 			providerList[i].associatedGroups[x].providerGroup.capId = IPAsGroupsSplit[1];
																	 		  providerList[i].associatedGroups[x].providerGroup.specialities = IPAsGroupsSplit[2];
																			$scope.providerRes.providerInfoResponses[i].providerInformation.capOfficeID = '';
																			$scope.providerRes.providerInfoResponses[i].displayPCPEligibilityIndicators.displayProviderIdentfierNumber =false;
																 }else if(providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																 		 providerList[i].associatedGroups[x].providerGroup.specialities = IPAsGroupsSplit[1];
																 }else if(providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																 		 providerList[i].associatedGroups[x].providerGroup.capId = IPAsGroupsSplit[1];
																		 $scope.providerRes.providerInfoResponses[i].providerInformation.capOfficeID = '';
																		 $scope.providerRes.providerInfoResponses[i].displayPCPEligibilityIndicators.displayProviderIdentfierNumber =false;
																 }
	 															 providerList[i].associatedGroups[x].providerGroup.providerDisplayName.full = IPAsGroupsSplit[0];
														}
														$scope.providerRes.providerInfoResponses[i].associatedGroups = providerList[i].associatedGroups;
											 }
									}
	
									if(providerList[i].providerOrganizations != undefined && (providerList[i].providerOrganizations != null || providerList[i].providerOrganizations.length)){
											 providerList[i].providerOrganizations = $filter('toArray')(providerList[i].providerOrganizations);
										   if(providerList[i].providerOrganizations.length != undefined){
														for(var x=0;x<providerList[i].providerOrganizations.length;x++){
	 															 if(providerList[i].providerOrganizations[x].name != undefined){
																	 IPAsGroupsSplit = providerList[i].providerOrganizations[x].name.full.split(new RegExp(IPAsGroupsSeparators.join('|'), 'g'));
																	 if(providerList[i].providerOrganizations[x].name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1 &&
																	 	 providerList[i].providerOrganizations[x].name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																	 	 providerList[i].providerOrganizations[x].capId = IPAsGroupsSplit[1];
																	 	 providerList[i].providerOrganizations[x].specialities = IPAsGroupsSplit[2];
																	 	 $scope.providerRes.providerInfoResponses[i].providerInformation.capOfficeID = '';
																	 	 $scope.providerRes.providerInfoResponses[i].displayPCPEligibilityIndicators.displayProviderIdentfierNumber =false;
																	 }else if(providerList[i].providerOrganizations[x].name.full.indexOf('_SPECIALTIES_SEPARATOR_') != -1){
																	 	providerList[i].providerOrganizations[x].specialities = IPAsGroupsSplit[1];
																	 }else if(providerList[i].providerOrganizations[x].name.full.indexOf('_CAP_OFFICE_SEPARATOR_') != -1){
																	 	providerList[i].providerOrganizations[x].capId = IPAsGroupsSplit[1];
																	 	$scope.providerRes.providerInfoResponses[i].providerInformation.capOfficeID = '';
																	 	 $scope.providerRes.providerInfoResponses[i].displayPCPEligibilityIndicators.displayProviderIdentfierNumber =false;
																	 }
																	 providerList[i].providerOrganizations[x].name.full = IPAsGroupsSplit[0];
																 }
														}
														$scope.providerRes.providerInfoResponses[i].providerOrganizations = providerList[i].providerOrganizations;
											 }
									}
					    	}
					    	
					    }

							// ACNLA5_1103_MS SR - Changes start
					    //if(isAllsPlanfitFalse && $scope.fauxRowsArray && $scope.fauxRowsArray.length <= 0){
					    if(providerList != undefined && isAllsPlanfitFalse && $scope.fauxRowsArray && $scope.fauxRowsArray.length <= 0){ 
					    // ACNLA5_1103_MS SR - Changes end							
								$scope.backendError=true;
								// ACNLA5_1202_MS SR - Changes start
								$scope.NYAdequecyError = false;
						        // ACNLA5_1202_MS SR - Changes end
								if($scope.errorCode != "SysError: DSE004-ST")
								{
									if( ProviderResultsService.getAssociatedProvidersSearchForGroup() )
										$scope.errorCode = "SysError: DSE005-ASSOC-PROV-SRCH-GRP";
									else
										$scope.errorCode = "SysError: DSE005";
								}
								$scope.showButtons=false;

							}
							$scope.providersSuppressed = isAllsPlanfitFalse;
							// planfitindicator check for all providers <Ends>

							
							/* Tactical site sepcific message */
							if( $scope.languageData.PR_SITE_SPECIFIC_MSG && $scope.languageData.PR_SITE_SPECIFIC_MSG !=  '' ){
								$scope.ShowSiteSpecificMessage = true;
							}else {
								$scope.ShowSiteSpecificMessage = false;
							}


						}
						else {
							if($scope.fauxRowsArray.length <= 0)
							{
								// no providers in results
								resultsReturned = false;
								$scope.searchStatus = getNotFoundStatus(result);

							}
							//console.log("searchStatus: " + $scope.searchStatus);
						}
						
						// ACNLA5_1103_MS SR - Changes start
						if(totalProviders > 0 && providerList == undefined && $scope.languageData.SWITCH_NAVIGATE_NEXT_PAGE  == 'ON'){
				    			$scope.showResultSection = true;
				    }
				    else {
				    			$scope.showResultSection = false;
				    }
						// ACNLA5_1103_MS SR - Changes end
						
						// if(totalProviders<=25 && ( false == $scope.criteria.isAlphaSort)){
						if(totalProviders<=25){
							$scope.showButtons=false;
						}
						else{
							// ACNLA5_1103_MS SR - Changes start
							// if($scope.providersSuppressed){
							if($scope.providersSuppressed && !$scope.showResultSection){
							// ACNLA5_1103_MS SR - Changes end
								$scope.showButtons=false;
							}else
								$scope.showButtons=true;
						}
					} else { // no results returned
						resultsReturned = false;
						$scope.searchStatus = getNotFoundStatus(result);
					}

					try{
						reportingData.totalFauxRows = $scope.fauxRowsArray.length;
						reportingData.searchStatus = $scope.searchStatus;
						reportingData.totalProviders = totalProviders;
						reportingData.errorCode = $scope.errorCode;

						AnalyticsService.trackSearch( reportingData );
					}
					catch(e){}

					/*$scope.pageNumber = ProviderSearchCriteriaService.getPage();*/

					var pageNumber = $scope.criteria.page;

											/*ProviderSearchCriteriaService.getCriteria();*/


					if(pageNumber == 1){
						$scope.statusBeg=true;
						console.log(" 4 : true : $scope.statusBeg" + $scope.statusBeg );
						$scope.statusLast=false;
					}else{
						$scope.statusBeg=false;
					}
					NavSpinnerService.stop();
					//bind event if comapre checkbox is disabled then focus on next elemnt
					setTimeout(function(){
					 $( ".purpleCheckbox" ).focus(function() {
						 if($(this).attr('disabled')){
							 $(this).nextAll('a:first').focus();
						 }
					 });
				 }, 1000);
				 if (filterResultsFocus==true) {
					 	$('#filterSortButton').focus();
						filterResultsFocus=false;
  				}
				 else {
					 	$('#mainWrapper').find('select, input, textarea, button, a').filter(':visible:first').focus();
				}
				 setTimeout(function(){
					$( ".pagination-number" ).focus(function() {
						if($(this).attr('disabled')){
							$(this).nextAll('li:first').focus();
						}
					});
				}, 1000);

				},
				function error (errorMsg) {
					//End Spinner.
				  $scope.isPageReady=true;
					NavSpinnerService.stop();
					$scope.criteria.typeAheadSearch = '';  // clear so next search starts over
					$scope.providerRes = null;
					$log.error(errorMsg.statusText);
					$scope.searchStatus = 'searchError';
					//Empty any faux rows from previous search
					$scope.fauxRowsArray=[];
					try{
						reportingData.searchStatus = $scope.searchStatus;
						reportingData.errorCode = errorMsg.statusText;

						AnalyticsService.trackSearch( reportingData );
					}
					catch(e){}
				}
			);
		};
		$scope.previousFocusCompare = function(e) {
	    if($(e.target).prevAll('.purpleCheckbox').attr('disabled')){
				$(e.target).on('keydown', function (e) {
            if ((e.which === 9 && e.shiftKey) ) {
                e.preventDefault();
								$(e.target).prevAll('.purpleCheckbox').parent().siblings().find('a').last().focus();
            }
        });
			}
		}

		$scope.focusOnFirstElement=function(){

		}
		/** This method will be responsible to fetching the costs associated with the providers (if eligible).
		 *
		 */
		var leftProvidersCount=0;
		indexForCost=0;
		var fetchCosts = function ()
		{
			configuration.maxCostEstimatesPerPage=parseInt(configuration.maxCostEstimatesPerPage);
			if(newSearchClicked==true || cancelFilter==true || $scope.okFilter==true){
				configuration.maxCostEstimatesPerPage=configuration.maxCostEstimatesPerPage*2;
				ProviderResultsService.setNewSearchClicked(false);
				ProviderResultsService.setCancelFilter(false);
				ProviderResultsService.setOkFilter(false);
			}

			var spinner ="costSpinner";
			$log.debug("Inside fetchCosts: " +$scope.providerRes);
			var auth = 'Bearer ' + DataCacheService.getToken();
			var noOfEligibleProviders = 0;
			if($scope.providerRes.providerInfoResponses!=null && $scope.providerRes.providerInfoResponses!=undefined){
				//	$log.debug("Inside for loop");
				var length = $scope.providerRes.providerInfoResponses.length !=undefined ? $scope.providerRes.providerInfoResponses.length : $scope.providerRes.interfacePaging.paging.perPage;
				for(indexForCost; indexForCost < length ; indexForCost=indexForCost+1){
					var provider = null;
					if(length == 1)
						provider = $scope.providerRes.providerInfoResponses;
					else
						provider = $scope.providerRes.providerInfoResponses[indexForCost];

					provider.spinnerKey = spinner + indexForCost;
					provider.isEligibleForCost = false;
					provider.costEstimated = false;
					if(isProviderEligible(provider))//matches the selection criteria
					{
						provider.isEligibleForCost = true;
						noOfEligibleProviders = noOfEligibleProviders + 1;
						//There is a limit on the number of providers we can get a estimate on per page.
						if(noOfEligibleProviders <= (configuration.maxCostEstimatesPerPage+leftProvidersCount)){
							//provider.spinnerKey = spinner+index;
							if($scope.guestUser==false && $scope.mpe==true){
								provider.costEstimated = true;
								usSpinnerService.spin(provider.spinnerKey);
								ProviderResultsService.getCost(indexForCost,provider,$scope.costEstimateEndpoint)
								.then(
										function success(response){
											//console.log(response);
											//$timeout(function(){
												var indexResp = response.index;
												//	$scope.providerRes.providerInfoResponses[indexResp].cost = response.cost;
												usSpinnerService.stop(response.spinnerKey);
												//	provider.cost = response.cost;
										//	},5000);

										},
										function error(response){
											usSpinnerService.stop(response.spinnerKey);
											$scope.providerRes.providerInfoResponses[response.index].outOfPocket ="N/A";
										}
								);
							}
							else{
								provider.outOfPocket = "N/A";
								usSpinnerService.stop(provider.spinnerKey);
							}
							if(noOfEligibleProviders==configuration.maxCostEstimatesPerPage){
								$scope.count=(indexForCost+1);
								$scope.maxCostEstimatesPerPage=(indexForCost+1);
							}
							if(indexForCost==length-1 && noOfEligibleProviders<configuration.maxCostEstimatesPerPage && $scope.criteria.page==1){
								remainingCostEligibleProviders(noOfEligibleProviders);
							}
						}
						else{
								//Limit the max cost estimate eligible providers
								provider.outOfPocket = "N/A";
								usSpinnerService.stop(provider.spinnerKey);
						}

					}
					else{
							//Not Eligible
							provider.outOfPocket = "N/A";
							provider.isEligibleForCost = false;
							usSpinnerService.stop(provider.spinnerKey);
							if(indexForCost==length-1 && noOfEligibleProviders<configuration.maxCostEstimatesPerPage && $scope.criteria.page==1){
								remainingCostEligibleProviders(noOfEligibleProviders);
							}
					}
				}
				indexForCost=$scope.count;
			}
			//return false;
		};

		/**Calculating how many providers are left for Cost estimates on the second Page**/

		var remainingCostEligibleProviders=function(noOfEligibleProviders){
				leftProvidersCount=configuration.maxCostEstimatesPerPage-noOfEligibleProviders;
		}

		/**
		 * fetch any ratings for the items being searched.
		 */
		var fetchRatings = function () {
			//console.log('fetchRatings()');
			if ($scope.providerRes.providerInfoResponses) {
				if (Array.isArray($scope.providerRes.providerInfoResponses)) {
					var length = $scope.providerRes.providerInfoResponses.length;
					//console.log('# of providers to add: ' + length);
					for (var index=0; index < length; index++) {
						// provider object will be in array if more than one provider
						var provider = $scope.providerRes.providerInfoResponses[index];
						RatingsService.checkRating(provider.providerInformation.providerID);
					}
				} else {
					//console.log('adding single provider');
					RatingsService.checkRating($scope.providerRes.providerInfoResponses.providerInformation.providerID);
				}

				// call the ratings web service
				var service = RatingsService.getAllRatings();
				service.then(function success(response) {
					//console.log('service finished');
				},function error(response) {
					//console.log('service error: ' + JSON.stringify(response));
				})

			}
		};

		/**
		 * Identify if the provider is eligible to do a cost estimate.
		 * If the provider is eligible then select the bundle associated with him. (TODO)
		 */
		// function isProviderEligible (provider){
		// 	if(provider.providerData.isIndividualProvider=='Y' && provider.costEstimateEligibilityDetails!=null
		// 	   && provider.costEstimateEligibilityDetails.optOutFlag=='Y'
		// 		 && provider.costEstimateEligibilityDetails.serviceBundleId!=undefined && provider.providerPlanFitIndicator == 'true'
		// 		 && provider.costEstimateEligibilityDetails.responseCode=="000" )
		// 	{
		// 			return true;
		// 	}
		// 	else
		// 		//Provider does not participate in MPE or is a non individual provider
		// 		return false ;
		// };

		// function to show button for fetching more costs
		var showCostButtonIndicator = false;
		$scope.showCostButton = function (){
			showCostButtonIndicator=false;
			//if($scope.guestUser!=true)
				fetchCosts();
		}
		$scope.statusBeg=true;
		console.log(" 5 : true : $scope.statusBeg" + $scope.statusBeg );
		$scope.statusLast=false;
		$scope.pagination = function(button){

			var stateObj = {'stateAPI': $scope.criteria, 
							'History.length': history.length, 
							'resultState' : ProviderResultsService.getAllVariables()   };
			
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.replaceState(stateObj, "Aetna", url);


			var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
			url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
			history.replaceState(stateObj, "Aetna",url);

			$scope.criteria.direction=button;
			$sessionStorage.criteria.direction=button;
			if(button=="first"){
				if($scope.statusBeg){
					return;
				}
			}
			else if(button=="previous"){
				if($scope.statusBeg){
					return;
				}
			}
			else if(button=="next"){
				if($scope.statusLast){
					return;
				}
			}
			else if(button=="last"){
				if($scope.statusLast){
					return;
				}
			}
			window.scrollTo(0,0);
			showCostButtonIndicator=false;
			var curPage=parseInt($scope.providerRes.interfacePaging.paging.page);
			var totalProviders=parseInt($scope.providerRes.interfacePaging.paging.total);
			var perPageProviders=parseInt($scope.providerRes.interfacePaging.paging.perPage);
			var lPage=Math.ceil(totalProviders/perPageProviders);
			var firstRecordOnPage=$scope.providerRes.interfacePaging.firstRecordOnPage;
			var lastRecordOnPage=$scope.providerRes.interfacePaging.lastRecordOnPage;
			if(button=="first"){
				curPage=1;
				$scope.statusBeg=true;
				console.log(" 6 : true : $scope.statusBeg" + $scope.statusBeg );
				$scope.statusLast=false;
			}
			if(button=="previous"){
				curPage--;
				if(curPage==1){
					$scope.statusBeg=true;
					console.log(" 7 : true : $scope.statusBeg" + $scope.statusBeg );
					}
				else{}
				$scope.statusLast=false;
			}
			if(button=="next"){
				curPage++;
				if(curPage==lPage){
					$scope.statusLast=true;
					}
				else{}
				$scope.statusBeg=false;

				console.log(" 8 : false : $scope.statusBeg" + $scope.statusBeg );
			}
			if(button=="last"){
				curPage=lPage;
				$scope.statusLast=true;
				$scope.statusBeg=false;

				console.log(" 9 : false : $scope.statusBeg" + $scope.statusBeg );
			}
			ProviderSearchCriteriaService.setPage(curPage);
			ProviderSearchCriteriaService.setDirection(button);
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			ProviderSearchCriteriaService.setTotal(totalProviders);

			$scope.criteria.page=curPage;
			$scope.criteria.firstRecordOnPage=firstRecordOnPage;
			$scope.criteria.lastRecordOnPage=lastRecordOnPage;
			$scope.criteria.total=totalProviders;

			$sessionStorage.criteria.page=curPage;
			$sessionStorage.criteria.firstRecordOnPage=firstRecordOnPage;
			$sessionStorage.criteria.lastRecordOnPage=lastRecordOnPage;
			$sessionStorage.criteria.total=totalProviders;

			indexForCost=0;
			NavSpinnerService.spin();
			if(isIE){
				//timeout added in order to handle $digest already running, as in IE is slow so it needs some time to reflect the UI changes.(For Pagination)
				$timeout(function() {
					fetchProviderResults();
	 			},2000)
			}
			else{
				fetchProviderResults();
			}
			console.log("reached");
			if($scope.criteria.page!=2){
				leftProvidersCount=0;
			}

			/*stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length};*/
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.pushState(stateObj, "Aetna", url);


						/*var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
						url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
						history.pushState(stateObj, "Aetna",url);*/
		};
		
		$scope.getAssociatedProviders = function(provider)
		{
			
			var provider = { "group":
								{
									"providerGroup":
									{
										"providerIdentifier":
										{
											"idValue":provider.providerInformation.providerIdentifier.idValue 
										},
							  			"providerDisplayName":
							  			{
							  				"full":provider.providerInformation.providerDisplayName.full,
								  		}
							  		}, 
								},
							};
			
			/*$scope.criteria.isAssociatedProvidersSearchForGroup = true;*/
			$scope.getGroup( provider.group , true /*$scope.criteria.isAssociatedProvidersSearchForGroup*/ );
		}

		$scope.getGroup = function( group , isAssociatedProvidersSearchForGroup )
		{
			// var xyz = $scope.criteria;
			// $sessionStorage.abc = xyz;
			//CommonUtilsService.setTempObject($scope.criteria);
			//if((criteria.isProviderForIPA != true && criteria.isProviderForGroup != true) && criteria.browserBack != true){
		 						// var criteriaABC = $sessionStorage.abc;
		 						// var criteriaABC =	CommonUtilsService.getTempObject();
								var stateObj = {	'stateAPI': $scope.criteria, 
													'History.length': history.length, 
													'resultState' : ProviderResultsService.getAllVariables() };
								
								//For QA
								// var url = configuration.backURLResults + siteId + "&language=" + language;
								// //For local
								// //var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
		 						// history.replaceState(stateObj, "Aetna", url);
		 						// history.pushState(stateObj, "Aetna", "/#/contentPage?page=providerResults&site_id=dse&language=en");


											var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
											url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
											history.replaceState(stateObj, "Aetna",url);
		 //}
			ProviderResultsService.setHideDistance(true);
			$scope.hideDistanceVal=getHideDistanceFlag();
			$scope.criteria.groupId = group.providerGroup.providerIdentifier.idValue;
			$rootScope.grpName = group.providerGroup.providerDisplayName.full;
			$scope.criteria.groupName = group.providerGroup.providerDisplayName.full;
			$scope.criteria.isProviderForGroup = true;
			$scope.criteria.isProviderForIPA = false;
			$scope.criteria.isProviderForHospital = false;
			$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			$scope.criteria.isResetFilter = false;
			// console.log("resetfilter getGroup"+ $scope.criteria.isResetFilter);
			$scope.criteria.checkedItem = [];
			$scope.criteria.checkedContentItem = [];
			$scope.criteria.checkedSecondLevelContentItem = [];
			$scope.criteria.listSelections = null;
			$sessionStorage.criteria.listSelections = null;
			$scope.criteria.direction = '';
			$scope.criteria.order = '';
			$scope.checkedSecondLevelContentItem=[];
			$scope.checkedItem=[];
			$scope.checkedContentItem=[];
			$scope.criteria.selectedFilters = '';
			selectedFilters ='';
			listSelections = "";
			$scope.criteria.selectedListArray = [];
			//$scope.sortOrder = '';
			var firstRecordOnPage='';
			var lastRecordOnPage='';
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			$scope.statusBeg = true;
			console.log(" 9 : true : $scope.statusBeg" + $scope.statusBeg );
			$scope.statusLast = false;
			$scope.criteria.statusBeg = $scope.statusBeg;
			$scope.criteria.statusLast = $scope.statusLast;
			//ProviderSearchCriteriaService.setOrder($scope.sortOrder);
			
			ProviderSearchCriteriaService.setListSelection(listSelections);
			$sessionStorage.criteria.listSelections = listSelections;
			$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;
			ProviderResultsService.setGroupdetails( group.providerGroup.providerIdentifier.idValue ,
					group.providerGroup.providerDisplayName.full , isAssociatedProvidersSearchForGroup );
			//create URL for this search. It can be the same as the the search.

			$scope.criteria.groupIPAClicked = true;
			$sessionStorage.criteria.groupIPAClicked == true;
			fetchProviderResults();
			stateObj = {'stateAPI': $scope.criteria, 
					'History.length': history.length,
					'resultState' : ProviderResultsService.getAllVariables() };
			
			//For QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// //For local
			// //var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			// history.pushState(stateObj, "Aetna", url);
			// var abcd = 0;
			// abcd = 123;



														var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
														url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
														history.pushState(stateObj, "Aetna",url);
		};

		var hideDistance = false;
		$scope.getIPA = function (group)
		{
			// var xyz = $scope.criteria;
			// $sessionStorage.abc = xyz;
			// CommonUtilsService.setTempObject($scope.criteria);

			var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };
			//For QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// //For local
			// //var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			// history.replaceState(stateObj, "Aetna", url);

														var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
														url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
														history.replaceState(stateObj, "Aetna",url);

			//history.pushState(stateObj, "Aetna", "/#/contentPage?page=providerResults&site_id=dse&language=en");
			ProviderResultsService.setHideDistance(true);
			$scope.hideDistanceVal=getHideDistanceFlag();
			hideDistance = true;
			$scope.criteria.ipaId = group.poin;
			$scope.criteria.ipaName = group.name.full;
			$sessionStorage.criteria.ipaName = group.name.full;
			$scope.criteria.isProviderForIPA = true;
			$scope.criteria.isProviderForGroup = false;
			/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
			$scope.criteria.isProviderForHospital = false;
			$scope.criteria.isFindDoctor = false;
			$scope.criteria.findDocPrevId = null;
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			$scope.criteria.isResetFilter = false;
			// console.log("resetfilter getIPA"+ $scope.criteria.isResetFilter);
			$scope.checkedSecondLevelContentItem=[];
			$scope.checkedItem=[];
			$scope.checkedContentItem=[];
			$scope.criteria.selectedFilters = '';
			selectedFilters='';
			listSelections = "";
			ProviderSearchCriteriaService.setListSelection(listSelections);
			$scope.criteria.listSelections = null;
			$sessionStorage.criteria.listSelections = null;
			$scope.criteria.direction = '';
			$scope.criteria.order = '';
			$scope.criteria.selectedListArray=[];
			//$scope.sortOrder ='';
			var firstRecordOnPage='';
			var lastRecordOnPage='';
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			$scope.statusBeg = true;
			console.log(" 10 : true : $scope.statusBeg" + $scope.statusBeg );
			$scope.statusLast = false;
			$scope.criteria.statusBeg = $scope.statusBeg;
			$scope.criteria.statusLast = $scope.statusLast;
			//ProviderSearchCriteriaService.setOrder($scope.sortOrder);
			$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;
			ProviderResultsService.setIpaDetails(group.poin);

			$scope.criteria.groupIPAClicked = true;
			$sessionStorage.criteria.groupIPAClicked == true;
			fetchProviderResults();
			stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };
			//For QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// //For local
			// //var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			// history.pushState(stateObj, "Aetna", url);


																	var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
																	url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
																	history.pushState(stateObj, "Aetna",url);
		};

		window.onpopstate = function(e) {
				
					$sessionStorage.hereUsingBrowserBackButton = false;
			
					if(e.state != null && $sessionStorage.visitedDetails == 1){
						
						$sessionStorage.hereUsingBrowserBackButton = true;
						
						$sessionStorage.criteria = e.state.stateAPI;
						$scope.criteria = e.state.stateAPI;
						$scope.criteria.browserBack = true;
						$sessionStorage.criteria.browserBack = true;

						$scope.checkedItem = $scope.criteria.checkedItem;
						$scope.checkedItemChildren = $scope.criteria.checkedItemChildren;
						selectedFilters = $scope.criteria.selectedFilters;

						ProviderResultsService.setAllVariables(e.state.resultState);
						
						ProviderResultsService.scrollTo = '';
						ProviderSearchCriteriaService.setPlanPleatShow(false);

						$scope.showDebbugger=false;
						$scope.isPageReady=false;

						$( "#provider-srch" ).addClass( "dateFix" );
						$( "#provider-Results-id" ).addClass( "dateFix2" );

						$scope.providerRes = "";
						$state.params.proId = '';
						$state.params.locId = '';
						$state.params.pType = '';
						$state.params.distance = '';
						$scope.criteria.isResetFilter = true;
						$scope.criteria.fromDetailsStart = true;
						$sessionStorage.criteria.fromDetailsStart = true;

						ProviderResultsService.scrollTo = '';
						ProviderSearchCriteriaService.setPlanPleatShow(false);

						var resultsService = ProviderResultsService;
						resultsService.resultSearch = 0;
						$scope.searchStatus = 'notSearching';

						if($sessionStorage.criteria.browserBack == true){
								$scope.criteria.isResetFilter = true;
								$scope.criteria.browserBack = false;
								$sessionStorage.criteria.browserBack = false;
						}

						$scope.sortOrder=($scope.criteria.filterOrder) ? $scope.criteria.filterOrder : null;
						$scope.compareListArray=[];
						var selectedFilters =($scope.criteria.selectedFilters) ? $scope.criteria.selectedFilters : "";
						$scope.reportIncorrectInfo = configuration.reportIncorrectInfo;
						ProviderSearchCriteriaService.setOrder($scope.sortOrder);
						var listSelections=($scope.criteria.listSelections) ? $scope.criteria.listSelections : null;
						$scope.showPrintDirectory=false;
						ProviderSearchCriteriaService.setListSelection(listSelections);
						$sessionStorage.criteria.listSelections = listSelections;
						$scope.errorCode = "";
						$scope.backendError=false;
						$scope.isShowSortFilterWindow=false;
						$scope.showFilterContent=($scope.criteria.showFilterContent) ? $scope.criteria.showFilterContent:[];
						$scope.showSecLevelContent=($scope.criteria.showSecLevelContent) ? $scope.criteria.showSecLevelContent:[];
						$scope.checkedItem=($scope.criteria.checkedItem) ? $scope.criteria.checkedItem : [];
						$scope.checkedItemChildren=($scope.criteria.checkedItemChildren) ? $scope.criteria.checkedItemChildren : [];
						$scope.checkedContentItem=[];
						$scope.showFirstLevel=true;
						$scope.checkedSecondLevelContentItem=[];
						var isFirstNavigate = true;
						$scope.isArray = angular.isArray;
						$scope.printDirectoryURL = configuration.printDirectoryURL;
						var filterResultsFocus = false;
						$scope.responseErrorDesc = '';
						$scope.responseErrorTitle = '';

						$scope.displayOR = false;

						$scope.compareListArray=[];
						var compareData = resultsService.compareData;
						compareData.showCompare = false;
						CompareProviderService.reset();

						if($scope.criteria.findDocPrevId === null){
							ProviderResultsService.setFindDoctors("");
						}

						if($state.params.hosId!=null && $state.params.hosId!=undefined && $state.params.hosId!=''){
							ProviderResultsService.setHospitalId($state.params.hosId);
							$scope.criteria.hospitalName = $state.params.hosName;
							$scope.criteria.hospitalId = $state.params.hosId;
							$scope.criteria.isProviderForHospital = true;
							$scope.criteria.isProviderForIPA = false;
							$scope.criteria.isProviderForGroup = false;
							/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
							$scope.criteria.isFindDoctor = false;
							$scope.criteria.findDocPrevId = null;
						}else{
							$scope.criteria.isProviderForHospital = false;
						}

						if(($state.params.proOrgDispName!=null && $state.params.proOrgDispName!=undefined && $state.params.proOrgDispName!='')
								|| ($state.params.proOrgName!=null && $state.params.proOrgName!=undefined && $state.params.proOrgName!='') ){
								if($state.params.poin != 'NA'){
									ProviderResultsService.setIpaDetails($state.params.poin);
									$scope.criteria.ipaName = $state.params.proOrgName;
									$sessionStorage.criteria.ipaName = $state.params.proOrgName;
									$scope.criteria.isProviderForIPA = true;
									$scope.criteria.isProviderForGroup = false;
									/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
									$scope.criteria.isProviderForHospital = false;
									$scope.criteria.isFindDoctor = false;
									$scope.criteria.findDocPrevId = null;
								}else{
									if( $state.params.assocProvSrchGrp != null && $state.params.assocProvSrchGrp != undefined && $state.params.assocProvSrchGrp == 'Y' )
										ProviderResultsService.setGroupdetails($state.params.groupProId,$state.params.proOrgDispName,true);
									else
										ProviderResultsService.setGroupdetails($state.params.groupProId,$state.params.proOrgDispName,false);
									$rootScope.grpName = $state.params.proOrgDispName;
									$scope.criteria.isProviderForGroup = true;
									$scope.criteria.isProviderForIPA = false;
									$scope.criteria.isProviderForHospital = false;
									$scope.criteria.isFindDoctor = false;
									$scope.criteria.findDocPrevId = null;
								}
						}else{
							if($scope.criteria.fromDetailsStart != undefined &&
									$scope.criteria.fromDetailsStart == true &&
									($scope.criteria.isProviderForGroup == true ||
									$scope.criteria.isProviderForIPA == true)){
								$scope.criteria.groupIPAClicked == false;
								$sessionStorage.criteria.groupIPAClicked == false;

								if($scope.criteria.isProviderForGroup == true){
									$scope.criteria.isProviderForIPA = false;
								}else{
									$scope.criteria.isProviderForGroup = false;
									$scope.criteria.isProviderForIPA = true;

									$scope.criteria = ProviderSearchCriteriaService.getCriteria();
									$sessionStorage.criteria = ProviderSearchCriteriaService.getCriteria();
								}
								$scope.criteria.isProviderForHospital = false;
								$scope.criteria.isFindDoctor = false;
								$scope.criteria.findDocPrevId = null;
								$scope.isProviderForGroup = $scope.criteria.isProviderForGroup;
							}else{
								$scope.criteria.isProviderForGroup = false;
								/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
								$scope.criteria.isProviderForIPA = false;
								ProviderResultsService.setIpaDetails("");
								$scope.criteria.ipaName = "";
								$sessionStorage.criteria.ipaName = "";
								$rootScope.grpName = "";
							}
						}

						var starClassNames = ["neg","neg","posneg","posneg","posneg","posneg","posneg","posneg","pos","pos"];
						RatingsService.setStarClassNames(starClassNames);

						$scope.ratingStatus = RatingsService.ratingStatus;
						var getRating = RatingsService.getRating;
						$scope.getStarClass = RatingsService.getStarClass;
						$scope.getNumberOfRatings = RatingsService.getNumberOfRatings;

						$scope.publicMember = {};
						$scope.publicMember.firstName = '';
						$scope.publicMember.lastName = '';
						$scope.publicMember.email = '';

						$scope.statusBeg = $scope.criteria.statusBeg;
						$scope.statusLast = $scope.criteria.statusLast;
						$scope.criteria.isAlphaSort = $scope.criteria.isAlphaSort;
						$sessionStorage.criteria.isAlphaSort = $scope.criteria.isAlphaSort;
						var defaultAlphabets = ['Num','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
						var tempArray = $scope.criteria.selectedListArray != undefined ? $scope.criteria.selectedListArray : [];
						//Report incorrect information object...
						$scope.reportInfo = {
								incAddress: false,
								incGender: false,
								incPhone: false,
								incSpeciality: false,
								incGroup: false,
								incDeceased: false,
								duplicateList: false,
								praLocation: false,
								noAccept: false,
								incindicates: false,
								incHospitalAff: false,
								incLanguage: false
							}
							if($scope.languageData.SWITCH_DISPLAY_RIP == 'NONE'){
								$scope.reportIncorrectInfoLink=false;
							}else {
								$scope.reportIncorrectInfoLink=true;
							}
							// fetchProviderResults();
							var garbage = 1;
					}
					if(e.state != null && $sessionStorage.visitedDetails != 1){
						
						$sessionStorage.hereUsingBrowserBackButton = true;

						$sessionStorage.criteria = e.state.stateAPI;
						$scope.criteria = e.state.stateAPI;
						$scope.criteria.browserBack = true;
						$sessionStorage.criteria.browserBack = true;
						
						ProviderResultsService.setAllVariables(e.state.resultState);

						$scope.checkedItem = $scope.criteria.checkedItem;
						$scope.checkedItemChildren = $scope.criteria.checkedItemChildren;
						selectedFilters = $scope.criteria.selectedFilters;

						fetchProviderResults();
						var garbage = 1;
					}
		};

		$scope.openURL = function(URL)
		{
			ProviderResultsService.openURL(URL);
		};
		
		

		$scope.openPdfURL = function( category )
		{
			NavSpinnerService.spin();
			PdfService.openACOpdf( category )
			.then(
					function success(response) {
						if (response && response.data && response.data.ChannelACOMapping
								&& response.data.ChannelACOMapping.link
								&& response.data.ChannelACOMapping.link != '' ) {

							var windowName='popup';
							var winOpts = 'width=900,height=600,scrollbars=yes,resizable=yes,toolbar=yes,overflow=scroll,location=yes,left=180,top=120';
							window.name='INDEX';
							window.open(response.data.ChannelACOMapping.link,windowName,winOpts);

							/*window.open(response.data.ChannelACOMapping.link,'_blank');*/
						} else {
							$log.error('There is no pdf info found in response');
						}
						NavSpinnerService.stop();
					},
				function error (errorMsg) {
					$log.error(errorMsg.statusText);
					NavSpinnerService.stop();
				}
			);
		};

		//ACNLA5_0603 code changes start
		/*$scope.buildProviderDetailURL = function(provider){
			if(provider.providerInformation.type == 'Individual'){
					return '#/contentPage?page=providerDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
			}else if(provider.providerInformation.type == 'Organization'){
					return '#/contentPage?page=providerOrgDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
			}else{
					return '#/contentPage?page=providerHospDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
			}
		};*/
		
		$scope.buildProviderDetailURL = function(provider){
			if(provider.providerInformation.type == 'Individual'){
				if($state.params.parameters === "disbaleChangeLocation"){
					return '#/contentPage?page=providerDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language+'&parameters='+ $state.params.parameters;	
				}else{
				    return '#/contentPage?page=providerDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
				}
			}else if(provider.providerInformation.type == 'Organization'){
				if($state.params.parameters === "disbaleChangeLocation"){
					return '#/contentPage?page=providerOrgDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language+'&parameters='+ $state.params.parameters;	
				}else{
					return '#/contentPage?page=providerOrgDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
				}
			}else{
					if($state.params.parameters === "disbaleChangeLocation"){
						return '#/contentPage?page=providerHospDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language+'&parameters='+ $state.params.parameters;	
					}else{
						return '#/contentPage?page=providerHospDetails&proId='+provider.providerInformation.providerIdentifier.idValue+'&locId='+provider.providerLocations.locationIdentifier.idValue+'&distance='+provider.providerLocations.address.distance+'&pType='+provider.providerInformation.type+'&site_id='+siteId+'&language='+language;
				    }	
			}
		}
		//ACNLA5_0603 code changes end

		$scope.navigateToDetails=function(data){
			if(data.providerInformation.type == 'Individual'){
									return '#/contentPage?page=providerDetails&proId='+data.providerInformation.providerIdentifier.idValue+'&locId='+data.providerLocations.locationIdentifier.idValue+'&distance='+data.providerLocations.address.distance+'&pType='+data.providerInformation.type+'&site_id='+siteId+'&language='+language;
							}else if(data.providerInformation.type == 'Organization'){
									return '#/contentPage?page=providerOrgDetails&proId='+data.providerInformation.providerIdentifier.idValue+'&locId='+data.providerLocations.locationIdentifier.idValue+'&distance='+data.providerLocations.address.distance+'&pType='+data.providerInformation.type+'&site_id='+siteId+'&language='+language;
							}else{
									return '#/contentPage?page=providerHospDetails&proId='+data.providerInformation.providerIdentifier.idValue+'&locId='+data.providerLocations.locationIdentifier.idValue+'&distance='+data.providerLocations.address.distance+'&pType='+data.providerInformation.type+'&site_id='+siteId+'&language='+language;
							}
		};

		$scope.navigate=function(data, pleat){
			$state.params.proId = '';
			$state.params.locId = '';
			$state.params.pType = '';
			$state.params.distance = '';
			if(isFirstNavigate && isToggleCheckBox){
			    createArrayForListFilters();
			}
			if(pleat == 'plan'){
					ProviderSearchCriteriaService.setPlanPleatShow(true);
					ProviderResultsService.scrollTo = 'planDetailsPanel';
			}else{
					ProviderSearchCriteriaService.setPlanPleatShow(false);
			}
			ProviderResultsService.setProviderType(data.providerInformation.type);
			$scope.criteria.provType = data.providerInformation.type;
			ProviderResultsService.setProvider(data);
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;

			ProviderSearchCriteriaService.setPleatProId(data.providerInformation.providerID);
			if(data.providerLocations != undefined){
					ProviderSearchCriteriaService.setPleatLocId(data.providerLocations.locationID);
			}

			if(data.providerInformation != null && data.providerInformation.type != null){
				ProviderResultsService.setProviderType(data.providerInformation.type);
				$scope.criteria.provType = data.providerInformation.type;
				// if(data.providerInformation.type == 'Individual'){
				// 	$state.go('contentPage',{page:'providerDetails',parameters:'',site_id:siteId,language:language});
				// }
				// else if(data.providerInformation.type == 'Hospital'){
				// 	$state.go('contentPage',{page:'providerHospDetails',parameters:'',site_id:siteId,language:language});
				// }
				// else if(data.providerInformation.type == 'Organization'){
				// 	$state.go('contentPage',{page:'providerOrgDetails',parameters:'',site_id:siteId,language:language});
				// }
			}
		};

		// user clicks on read more link from results page.
		// Need to tell details page to open up experience pleat
		$scope.readMoreDetails = function(data){
			//AnalyticsService.trackLink('Provider Search|read more', AnalyticsService.LINK_TYPE_PAGE);
			ProviderResultsService.scrollTo = 'experiencePanel';
			$scope.navigate(data);
		};

		// Takes to the disclaimer at the bottom of the results page
		$scope.showTopDisclaimer = function(){
			   $('html,body').animate({scrollTop: $("[nvstyle='disclaimerFooter']").offset().top},'slow');
		};

		// user clicks on ratings link from results page.
		// Need to tell details page to open up ratings pleat
		$scope.ratingsDetails = function(data){
			//AnalyticsService.trackLink('Provider Search|ratings details', AnalyticsService.LINK_TYPE_PAGE);
			ProviderResultsService.scrollTo = 'ratingsPanel';
			$scope.navigate(data);
		};

		/*Map start*/
		// mapquest map functions
		// $scope.map = {  // all map stuff goes here
		// 		directions: false,  // true if directions being displayed for map
		// 		type: "",  // map type desktop, mobile, iphone
		// 		fromAddress: "",
		// 		toAddress:  "",
		// 		label: "",
		// 		phone: "",
		// 		routeListing: null  // array of route steps
		// }

		// set the map type for displaying a map.
		// - browser size determines if it is desktop or mobile
		// - user agent determines if it's an iphone.  However, we only need this class if the
		//   iphone is in portrait mode (to handle a browser inconsistancy)
		// $scope.setMapType =function(){
		// 	var oldType = $scope.map.type;
		// 	var w = $window.innerWidth;
		// 	var h = $window.innerHeight;
		// 	var ua = $window.navigator.userAgent;
		// 	var iPhone = ( navigator.userAgent.match(/(iPhone|iPod)/g) ? true : false );
		// 	var portrait = w < h;
    //
		// 	// determine map type
		// 	if (iPhone && portrait) {
		// 		$scope.map.type = "iphone";
		// 	} else if (w > 992) {
		// 		$scope.map.type = "desktop";
		// 	} else {
		// 		$scope.map.type = "mobile";
		// 	}
    //
		// 	// if the map type changes, this can be because of a windows event outside of angular control.
		// 	// Have angular redo its stuff
		// 	if (oldType != $scope.map.type && oldType!="") {
		// 		/*
		//     	if ($scope.map.type === 'iphone') {
		//     		alert('entering iphone mode');
		//     	} else if (oldType == 'iphone') {
		//     		alert('leaving iphone mode');
		//     	}
		// 		 */
		// 		try {
		// 			angular.element(document.getElementById('providerResults')).scope().$apply();
		// 		} catch (e) {}
		// 	}
		// }

		// set map type now and whenever the browser size changes

		// $(window).resize(function() {
		// 	$scope.setMapType();
		// });
    //
		// // get the ID for the map, given a provider
		// $scope.getMapId = function(provider) {
		// 	var id = "map_" + $scope.resultsService.getProviderKey(provider);
		// 	return id;
		// }
    //
		// // return true if there is a map open for a provider
		// $scope.isMapOpen = function(provider) {
		// 	return provider.isMap == true;
		// }
    //
		// // return the class name for a map for a provider
		// // map_desktop, map_mobile_full, map_mobile, map_none
		// $scope.getMapClass = function(provider) {
		// 	var c = "map_none";  // default to no map
		// 	if (provider.isMap) {
		// 		// there is a map, so see if we are doing a desktop or mobile map
		// 		var mapType = $scope.map.type;
		// 		if (mapType === 'mobile') {
		// 			// there are 2 types of mobile maps - full screen and non-full screen (for directions)
		// 			if ($scope.map.directions) {
		// 				c = "map_mobile";  // leave room for directions
		// 			} else {
		// 				c = "map_mobile_full";  // map can take entire screen
		// 			} // a mobile map
		// 		} else if (mapType === 'iphone') {
		// 			// there are 2 types of iphone maps - full screen and non-full screen (for directions)
		// 			if ($scope.map.directions) {
		// 				c = "map_iphone";  // leave room for directions
		// 			} else {
		// 				c = "map_iphone_full";  // map can take entire screen
		// 			} // a mobile map
		// 		} else { // a desktop map
		// 			// there is 1 type of desktop map - with or without directions
		// 			c = "map_desktop";
		// 		} // what type of map
		// 	} else { // no map open for this provider, so return map_none
		// 		c = "map_none";
		// 	} // is there a map
    //
		// 	return c;
		// }
    //
		// // return true if there is a map with directions open for a provider
		// $scope.isDirectionsOpen = function(provider) {
		// 	if (provider.isMap) {
		// 		// there is a map, so see if there are directions
		// 		return $scope.map.directions;
		// 	} else { // no map open for this provider, so return false
		// 		return false;
		// 	}
		// }
    //
		// // return the class name for the driving directions for a provider
		// // directions_desktop, directions_mobile, directions_none
		// $scope.getDirectionsClass = function(provider) {
		// 	var c = "directions_none";  // default
		// 	if (provider.isMap && $scope.map.directions) { // provider has map and we are doing directions
		// 		var c = "directions_" + $scope.map.type;
		// 	}
		// 	return c;
		// }

		//Google Maps Starts
		//This information will be used to create markerInfo object so that the html content can be rendered.
		var createMapInformation = function()
		{
			    //Reset Provider creation flag.
				displayProviderMap = false;

				var providerList =[];
				// In this method markerInfo object will get created and each instance will have a lat,long, markerContent,indicator if the provider, is selected, indicator if the providers have the same service location id . The total number of markers should be equal to total number of unique lat/ longs in the list.
				var markerInfo=[];
				var flagmatch = false; // Flag will be set to true once the provider is added to a list of  markerInfo


				//Convert providerInfoResponses to array.
				if ($scope.providerRes && $scope.providerRes.providerInfoResponses != undefined && !angular.isArray($scope.providerRes.providerInfoResponses)) {
					providerList.push($scope.providerRes.providerInfoResponses);
				}else{
					providerList = $scope.providerRes.providerInfoResponses;
				}

				// ACNLA5_1103_MS SR - Changes start
				if (providerList != undefined) {	
				// ACNLA5_1103_MS SR - Changes end
					for(var i=0;i<providerList.length;i++){
						//Provider Should be par.
						if(providerList[i].providerPlanFitIndicator == 'true'){
	
							//There is no markerInfo set yet. This is the first provider.
							if(markerInfo.length == 0)
							{
								markerInfo[0]= {};
								var providerStack=[];
								providerStack.push(providerList[i]);
								markerInfo[0].lat = providerList[i].providerLocations.address.latitude;
								markerInfo[0].long = providerList[i].providerLocations.address.longitude;
								markerInfo[0].providers = providerStack;
	
	
								markerInfo[0].serviceLocationIdsame = false;
	
							}else{
	
								//Reset FlagMatch.
								flagmatch = false;
								for(var j=0;j<markerInfo.length;j++)
								{
									//lat long the same
									if(markerInfo[j].lat == providerList[i].providerLocations.address.latitude
											&& markerInfo[j].long == providerList[i].providerLocations.address.longitude)
									{
	
										for(var k=0;k<markerInfo[j].providers.length;k++)
										{
											// Is the service location id the same
											if(markerInfo[j].providers[k].providerLocations.locationIdentifier.idValue == providerList[i].providerLocations.locationIdentifier.idValue)
											{
	
												markerInfo[j].serviceLocationIdsame = true;
												break;
											}
	
										}
										//THis should happen after the for loop otherwise serviceLocationIdsame will always be true.
										markerInfo[j].providers.push(providerList[i]);
	
										flagmatch = true;
										break;
									}
								}
								if(flagmatch == false)
								{
									var providerStack=[];
									providerStack.push(providerList[i]);
	
									markerInfo.push({
	
										lat:providerList[i].providerLocations.address.latitude,
										long:providerList[i].providerLocations.address.longitude,
										providers:providerStack,
										serviceLocationIdsame:false
									});
	
								}
	
							}
						}
					}
				}
				//Assign so that information windows get Created.
				$scope.markerInfo = markerInfo;
				closeMapCont();
		}

		//Finally create markers.
		var createMarkerInfo = function(){
			var markerInfo = $scope.markerInfo;

			if(markerInfo == undefined || markerInfo.length ==0)
				return;

			for(var i=0;i<markerInfo.length;i++){
				markerContent = "";
				if($("#Marker_"+i)!= undefined)
					markerContent = $("#Marker_"+i).html();

				//add the marker and open the information window.
				if(markerInfo[i].providerSelectedForMap)
				{
					if(markerInfo[i].lat==0.00 && markerInfo[i].long==0.00){
						mapsService.addMarkerFromAddress($scope.createAddressforInformationWindow(markerInfo[i].providers[0]),markerContent,true);
					}else{
						mapsService.addMarker(markerInfo[i].lat,markerInfo[i].long,markerContent,true);
					}
				}
				else{
					if(markerInfo[i].lat==0.00 && markerInfo[i].long==0.00){
						mapsService.addMarkerFromAddress($scope.createAddressforInformationWindow(markerInfo[i].providers[0]),markerContent,false);
					}else{
						mapsService.addMarker(markerInfo[i].lat,markerInfo[i].long,markerContent,false);
					}
				}
			}

			// var tempMarkers=mapsService.getAllMarkers();
			// var bounds = new google.maps.LatLngBounds();
			// for (var i = 0; i < tempMarkers.length; i++) {
			//  bounds.extend(tempMarkers[i].getPosition());
			// }
			// map.fitBounds(bounds);

		}
		function openInfoWindow(markerInfo){
			for(var i=0;i<markerInfo.length;i++){
				if(markerInfo[i].providerSelectedForMap){
					mapsService.openInfoWindow(i);
				}
			}
		}
		function closeMapCont() {
			element = document.getElementById('map');
			var mapCancelButton=document.getElementById('map_cancel');
			if(element == undefined)
				return;
			element.style.display = "none";
			mapCancelButton.style.display = "none";
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}
		function closeMap(){
			// Added for Close Map
			var element = document.getElementById('map');
			var mapCancelButton=document.getElementById('map_cancel');
			element.style.display = "none";
			mapCancelButton.style.display = "none";
			displayProviderMap=true;
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}
		$scope.closeProviderMap = function(provider) {
			mapsService.toggleMap();
			$( ".mapViewButton" ).addClass("active");
			$( ".listViewButton" ).removeClass("active");
			$(".mapViewButton").removeAttr('disabled');
			$(".listViewButton").attr('disabled','true');
			$(".mapViewButton").addClass('map_active');
		}

		//Method will return the full name for the given provider
		$scope.createNameforInformationWindow = function (provider)
		{
				    if(provider.providerInformation.type == "Individual"){
						return provider.providerInformation.providerDisplayName.full;

					}else{
						//still to handle currently working on indivisual
						return provider.providerInformation.providerDisplayName.full;
					}
		}

		$scope.createAddressforInformationWindow = function(provider)
		{

			var destination = ""
			var address = provider.providerLocations.address;
			//Streetline3 is buildingName
			if(address.buildingName){
				destination = address.buildingName + ", ";
			}
			if(address.streetLine3)
				destination = address.streetLine3 + ", ";
			destination  = destination + address.streetLine1 + ", "
			if(address.streetLine2)
				destination = destination + address.streetLine2 + ", ";

			destination = destination + address.city+ ", "+ address.state +" "+ address.postalCode.substring(0,5);
			return destination;
		}

		// Method that will format the phone number in the formation (XXX)XXX-XXXX
		$scope.createPhoneforInformationWindow = function (provider)
		{

			 var phoneNumber = "";
			 var contacts = $filter('toArray')(provider.contacts);

			if( contacts[0].primaryPhone!=null){
				    phoneNumber = contacts[0].primaryPhone;
					phoneNumber = '('+phoneNumber.number.substring(0,3)+') '+phoneNumber.number.substring(3,6)+'-'+phoneNumber.number.substring(6,phoneNumber.number.length);
			}
			return phoneNumber;
		}

		$scope.openMapView=function(typeOfObject){

					var markerInfo = $scope.markerInfo;

					if(markerInfo == undefined || markerInfo.length ==0)
						return;

					if(typeOfObject!=null && typeOfObject=='map'){
						$( ".listViewButton" ).addClass("active");
						$( ".mapViewButton" ).removeClass("active");
						$(".listViewButton").removeAttr('disabled');
						$(".listViewButton").focus();
						$(".mapViewButton").attr('disabled','true');
						$(".listViewButton").addClass('map_active');
					}else{
						$( ".mapViewButton" ).addClass("active");
						$( ".listViewButton" ).removeClass("active");
						$(".mapViewButton").removeAttr('disabled');
						$(".mapViewButton").focus();
						$(".listViewButton").attr('disabled','true');
						$(".mapViewButton").addClass('map_active');
					}

					if(displayProviderMap==false){
						if(markerInfo[0].lat==0.00 && markerInfo[0].long==0.00){
							mapsService.createMapWithAddress($scope.createAddressforInformationWindow(markerInfo[0].providers[0]),14,"map");
						}else{
							mapsService.createMap(markerInfo[0].lat,markerInfo[0].long,14,"map");
						}
						//Add markers and Information Windows
						createMarkerInfo(markerInfo);
						displayProviderMap = true;
					}
					//Map is already created.
					else{
							mapsService.toggleMap();
							displayProviderMap=true;
					}

				}

		/* Get Directions.*/
		$scope.getDirections = function(provider) {
			if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
				return mapsService.createGoogleMapsDirectionURL($scope.createAddressforInformationWindow(provider));
			}else{
				return mapsService.createGoogleMapsDirectionURL(provider.providerLocations.address.latitude+','+provider.providerLocations.address.longitude);
			}
		}
		// display a map for a provider
		$scope.openProviderMap = function(provider) {
			var markerInfo = $scope.markerInfo;
			var selectedProvPin = provider.providerInformation.providerID;
			var selectedProvSvcID = provider.providerLocations.locationIdentifier.idValue;

			for(var j=0;j<markerInfo.length;j++)
			{
				// when the user clicks on second provider
				if(markerInfo[j].providerSelectedForMap){
					delete markerInfo[j].providerSelectedForMap;
				}
					for(var k=0;k<markerInfo[j].providers.length;k++)
					{
						// Is the service location id the same
						if(selectedProvPin  == markerInfo[j].providers[k].providerInformation.providerID && markerInfo[j].providers[k].providerLocations.locationIdentifier.idValue == selectedProvSvcID)
						{

							markerInfo[j].providerSelectedForMap=true;
							break;
						}
					}
			}
			if(displayProviderMap==false){
				if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
					mapsService.createMapWithAddress($scope.createAddressforInformationWindow(provider),14,"map");
				}else{
					mapsService.createMap(provider.providerLocations.address.latitude,provider.providerLocations.address.longitude,14,"map");
				}
				//Add markers and Information Windows
				createMarkerInfo(markerInfo);
				displayProviderMap = true;
			}
			//Map is already created.
			else{
				if(provider.providerLocations.address.latitude==0.00 && provider.providerLocations.address.longitude==0.00){
					mapsService.updateCenterFromAddress($scope.createAddressforInformationWindow(provider));
				}else{
					mapsService.updateCenter(provider.providerLocations.address.latitude,provider.providerLocations.address.longitude);
				}
				//createMarkerInfo(markerInfo);
				openInfoWindow(markerInfo);
				var element = document.getElementById('map');
				var mapCancelButton=document.getElementById('map_cancel');
				if(element == undefined)
					return;
				if(element.style.display == "none"){
					element.style.display = "block";
					mapCancelButton.style.display = "block";
					$("#hideGoogleMap").focus();
				}
				displayProviderMap=true;
			}
			$( ".listViewButton" ).addClass("active");
			$( ".mapViewButton" ).removeClass("active");
			$(".listViewButton").removeAttr('disabled');
			$(".mapViewButton").attr('disabled','true');
			$(".listViewButton").addClass('map_active');
			$('body,html').animate({
			    scrollTop: $("#map_cancel").offset().top
		  }, 2000);
			$("#hideGoogleMap").focus();
    	$('body,html').clearQueue();
			// function scroll() {
			// 	var id = $scope.getMapId($scope.map.provider);
			// 	var scrollHere = document.getElementById(id);
			// 	scrollHere.focus();
			// 	scrollHere.scrollIntoView();
			// }
      //
			// if (provider.isMap) {
			// 	return;  // map is already open
			// }
      //
			// /* If requesting map for the second time for same provider.
	 		//  Don't call mapQuest again just unhide the map earlier loaded. */
			// /*if( provider.mapAvailable )
			// {
			// 	provider.isMap = true;
			// 	return;
			// }*/
      //
			// var id = $scope.getMapId(provider);
			// $scope.map.provider = provider;
			// provider.isMap = true;  // this provider has a map
      //
			// // fill in map object with info needed for the map
			// try {
			// 	$scope.map.label = provider.providerInformation.providerDisplayName.full;
			// 	/*provider.providerData.isIndividualProvider == "Y" ?
			// 			provider.providerData.individualProvider.nameFull :
			// 				provider.providerData.organizationProvider.nameFull;*/
			// } catch (e) {}
			// try {
			// 	$scope.map.phone = provider.contacts[0].primaryPhone.number;
			// 		/*provider.providerData.providerAtLocation.officeContacts.primaryPhone.number*/;
			// 	$scope.map.phone = phoneFormatFilter($scope.map.phone);
			// } catch (e) {}
			// $scope.map.toAddress =
			// 	provider.providerLocations.address.streetLine1 + ' ' +
			// 	provider.providerLocations.address.city + ' ' +
			// 	provider.providerLocations.address.state + ' ' +
			// 	provider.providerLocations.address.postalCode ;
			// 	/*provider.providerData.providerAtLocation.officeContacts.postalAddresses.streetLine1 + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.city + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.state + ' ' +
			// 	provider.providerData.providerAtLocation.officeContacts.postalAddresses.postalCode
			// 	;*/
			// $scope.map.directions = false;  // not displaying driving directions yet
			// $scope.map.routeListing = null;
      //
			// // create the actual map
			// L.Icon.Default.imagePath = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images';
			// var mapId = $scope.getMapId(provider);  // where to put the map
			// $scope.map.mqMap = L.map(mapId, {
			// 	layers: MQ.mapLayer(),
			// 	zoom: 16
			// });
      //
			// // put the provider address on the map
			// MQ.geocode({
			// 	map: $scope.map.mqMap,
			// 	icon: L.icon({
			// 		iconUrl: '../images/distance.png',
			// 		iconSize: [ 22, 28 ],
			// 		iconAnchor: [ 11, 28 ],
			// 		popupAnchor: [ 0, -22 ]
			// 	})
			// }).search($scope.map.toAddress).on('success', function(e) {
			// 	var best = e.result.best, latlng = best.latlng;
			// 	L.marker([ latlng.lat, latlng.lng ])
			// 	.addTo($scope.map.mqMap)
			// 	.bindPopup(createPOIHtml( provider ))
			// 	.openPopup();
			// });
      //
			// // scroll to map but wait for things to settle
			// setTimeout(scroll, 200);
		}
		//Google Maps Ends
		// Display directions below the map
		// window.openDirections = function() {
		// 	function scroll() {
		// 		var id = $scope.getMapId($scope.map.provider);
		// 		var scrollHere = document.getElementById(id);
		// 		scrollHere.scrollIntoView();
		// 	}
    //
		// 	$scope.map.directions = true;  // display driving directions
    //
		// 	// scroll to map but wait for things to settle
		// 	setTimeout(scroll, 200);
    //
		// 	// angularJS did not call this function, so we need to tell it that it was called
		// 	// so it can update any view changes.
		// 	angular.element(document.getElementById('providerResults')).scope().$apply();
		// }

		// close the map for a provider
		// $scope.closeProviderMap = function(provider) {
		// 	//var id = $scope.getMapId(provider);
		// 	provider.mapAvailable = true;
		// 	provider.isMap = false;  // this provider does not have a map
		// 	try {
		// 		$scope.map.mqMap.remove();
		// 	} catch(e) {};
		// 	$scope.map.mqMap = null;
		// 	$scope.map.directions = false;  // not displaying driving directions yet
		// 	$scope.map.routeListing = null;
		// 	$scope.map.fromAddress = "";
		// }

		// create the HTML that displays the provider on the map
		// function createPOIHtml( provider ) {
    //
		// 	var details = "";
		// 	if( provider.providerLocations.address.streetLine2 )
		// 	{
		// 		details = provider.providerLocations.address.streetLine1 + '<br> ' +
		// 		provider.providerLocations.address.streetLine2 + '<br> ' +
		// 		provider.providerLocations.address.city + ' ' +
		// 		provider.providerLocations.address.state + ' ' +
		// 		provider.providerLocations.address.postalCode;
		// 	}
		// 	else
		// 	{
		// 		details = provider.providerLocations.address.streetLine1 + '<br> ' +
		// 		provider.providerLocations.address.city + ' ' +
		// 		provider.providerLocations.address.state + ' ' +
		// 		provider.providerLocations.address.postalCode;
		// 	}
    //
		// 	var poiHtml =
		// 		'<strong>' + $scope.map.label +
		// 		'</strong><br>' +
		// 		details +
		// 		'<br/>' +
		// 		$scope.map.phone +
		// 		"<br><a href='javascript:openDirections()'>Directions</a>";
		// 	return poiHtml;
		// }

		// create the HTML that displays the provider on the map
		/*function createPOIHtml() {
			var poiHtml =
				'<strong>' + $scope.map.label +
				'</strong><br>' +
				$scope.map.phone +
				"<br><a href='javascript:openDirections()'>Directions</a>";
			return poiHtml;
		}*/
    //
		// $scope.getDirections = function() {
		// 	var dir = MQ.routing.directions()
		// 	.on('success', function(data) {
		// 		var legs = data.route.legs,
		// 		html = '',
		// 		maneuvers,
		// 		i;
    //
		// 		if (legs && legs.length) {
		// 			maneuvers = legs[0].maneuvers;
    //
		// 			// create an array of route steps to display
		// 			$scope.map.routeListing = [];
		// 			for (i=0; i<maneuvers.length; i++) {
		// 				$scope.map.routeListing[i] = maneuvers[i].narrative;
		// 			}
    //
		// 			// angularJS did not call this functions, so we need to tell it that it was called
		// 			// so it can update any view changes.
		// 			angular.element(document.getElementById('providerResults')).scope().$apply();
    //
		// 		}
		// 	});
    //
		// 	dir.route({
		// 		locations: [
		// 		            $scope.map.fromAddress,  // starting point
		// 		            $scope.map.toAddress  // ending point
		// 		            ]
		// 	});
    //
		// 	$scope.map.routeLayer = MQ.routing.routeLayer({
		// 		directions: dir,
		// 		fitBounds: true
		// 	});
    //
		// 	$scope.map.mqMap.addLayer($scope.map.routeLayer);
    //
		// };
		/* Map End*/



		// create a map centered on the provider stored in the scope
		// $scope.createSearchResultsMap = function() {
		// 	// only do this if the popover is open
		// 	if (!$scope.map.open) return;
		// 	if ($scope.map.created) return;
    //
		// 	if (!$scope.map.mqMap) {
		// 		//console.log("create map once");
		// 		L.Icon.Default.imagePath = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images';
		// 		$scope.map.mqMap = L.map('searchResultsMap', {
		// 			layers: MQ.mapLayer(),
		// 			zoom: 16
		// 		});
		// 	}
		// 	//console.log("geocode map");
		// 	MQ.geocode({
		// 		map: $scope.map.mqMap,
		// 		icon: L.icon({
		// 			iconUrl: '/images/distance.png',
		// 			iconSize: [ 22, 28 ],
		// 			iconAnchor: [ 11, 28 ],
		// 			popupAnchor: [ 0, -22 ]
		// 		})
		// 	}).search($scope.map.toAddress).on('success', function(e) {
		// 		var best = e.result.best, latlng = best.latlng;
		// 		//console.log("found location: " + latlng.lat + ', ' + latlng.lng);
		// 		L.marker([ latlng.lat, latlng.lng ])
		// 		.addTo($scope.map.mqMap)
		// 		.bindPopup(createPOIHtml( provider ))
		// 		.openPopup();
		// 		$scope.map.created = true;
    //
		// 	});
    //
		// };
    //
		// $scope.closeDirections = function() {
		// 	$scope.map.directions = false;  // not displaying driving directions
		// 	$scope.map.routeListing = null;
		// 	$scope.map.mqMap.removeLayer($scope.map.routeLayer);
		// };

		$scope.dateConversion = function(date){
			 return new Date(date);
		};

		$scope.closeModal=function(id){
			angular.element("#"+id).hide();
			angular.element("#"+id).addClass("fade");
			angular.element("#"+id).removeClass("fadeIn");
			angular.element("#"+id).css("display", "none");
			angular.element(".modal-backdrop" ).css("display","none");
		}


		function fetchFauxRows(){
			$scope.networkTransitionMessage=false;
			$scope.PCPInquryTimeOutMessage = false;
			$scope.urgentCareMessage = false;
			$scope.EAP = "";
			$scope.fauxRowsArray=[];
			$scope.walkinCA = false;
			var obj;
			$rootScope.lastUpdatedDate="";
			if (!$scope.providerRes.listInfoExchanges) return;
			if (!$scope.providerRes.listInfoExchanges.listInfoExchange) return;
			var listInfoExchange=$scope.providerRes.listInfoExchanges.listInfoExchange;

			if(!angular.isArray(listInfoExchange))
				listInfoExchange = [listInfoExchange];

			for(var i=0;i<listInfoExchange.length;i++){

				var listValue = "";
				var listDesc = "";
				if ( Array.isArray(listInfoExchange[i].values.value))
				{
					listValue = listInfoExchange[i].values.value[0];
					listDesc = listInfoExchange[i].values.value[2];
				}
				else
				{
					listValue = listInfoExchange[i].values.value;
				}

				if(listInfoExchange[i].name=='Network Transition Message'){
					$scope.transMessage=listInfoExchange[i].values.value;
					$scope.networkTransitionMessage=true;
				}
				if(listInfoExchange[i].name == 'Exception')
				{
						$scope.backendError=true;
						$scope.errorCode= listValue.key;
						if(listValue.key == "SysError: DSE004-ST" || listValue.key == "SysError: DSE004-ST-PAR" || listValue.key == "SysError: DSE004-ST-PAR-NN"){
							    // ACNLA5_1202_MS SR - Changes start
							    $scope.NYAdequecyError = true;
							    // ACNLA5_1202_MS SR - Changes end
								$scope.responseErrorDesc = listDesc.value;
								$scope.responseErrorTitle = listValue.value;
						}
							//listInfoExchange[i].values.value[0].key;
				}
				if(listInfoExchange[i].name == "directoryLastUpdatedDate"){
					$rootScope.lastUpdatedDate = listValue.value;
						//listInfoExchange[i].values.value[0].value;
				}
				if(listInfoExchange[i].name == "PCPInquryTimeOut"){
					$scope.PCPInquryTimeOutMessage = listValue.value;
						//listInfoExchange[i].values.value.value;
				}
				if(listInfoExchange[i].name == "stateHmoInd"){
					$scope.urgentCareMessage = listValue.value;
						//listInfoExchange[i].values.value[0].value;
				}
				if(listInfoExchange[i].name == "triggerMessage"){
					$scope.triggerMessages = [];
					if (!Array.isArray(listInfoExchange[i].values.value)){
						listInfoExchange[i].values.value = [listInfoExchange[i].values.value];
					} 
					for(var j=0;j<listInfoExchange[i].values.value.length;j++){
							if(listInfoExchange[i].values.value[j].type == 'text'){
								$scope.triggerMessages.push(listInfoExchange[i].values.value[j].value);
								//$scope.isTriggerMessage =  true;
							} else if(listInfoExchange[i].values.value[j].type == 'link'){
								$scope.triggerURL = listInfoExchange[i].values.value[j].value;
								window.open($scope.triggerURL);
							}
					}
				}

				if(listInfoExchange[i].name == "EAPSearch" && listInfoExchange[i].values.value.value == "true" ){
					$scope.EAP = listValue.value;
						//listInfoExchange[i].values.value.value;
				}
				if(listInfoExchange[i].name == "fauxRow" ){
					var keyValues=listInfoExchange[i].values.value;
					obj={};
					for(var j=0;j<keyValues.length;j++){
						if(keyValues[j].key=="description"){
							obj.description=keyValues[j].value;
						}
						else if(keyValues[j].key=="altText"){
							obj.altText=keyValues[j].value;
						}
						else if(keyValues[j].key=="iconUrl"){
							obj.iconUrl=keyValues[j].value;
						}
						else if(keyValues[j].key=="label"){
							obj.label=keyValues[j].value;
						}
						else if(keyValues[j].key=="url"){
							obj.url=keyValues[j].value;
						}
						else if(keyValues[j].key=="descriptionUrlExternal"){
							obj.external=keyValues[j].value;
						}
						else if(keyValues[j].key=="redirect"){
							obj.redirect=keyValues[j].value;
							if(obj.redirect=="true"){
								$window.open(obj.url,"","");
								break;
							}
						}
						else if(keyValues[j].key=="openInCurrentWindow"){
							obj.openInCurrentWindow=keyValues[j].value;							
						}
					}
					$scope.backendError=false;
					$scope.fauxRowsArray.push(obj);
				}
				if(listInfoExchange[i].name=='searchCheckReason'){
					var listValue = "";
					if ( Array.isArray(listInfoExchange[i].values.value))
					{
						listValue = listInfoExchange[i].values.value[0];
					}
					else
					{
						listValue = listInfoExchange[i].values.value;
					}
					if(listValue.value=='pinSearchNotFound'){
						 $scope.pinSearch=true;
						 $scope.backendError=false;
		 				if($sessionStorage.pinFromDetails !=null && $sessionStorage.pinFromDetails !=undefined){
		 				 if($sessionStorage.pinFromDetails){
		 					 $scope.pinSearch=false;
							 $scope.fromDetails=true;
		 					 $sessionStorage.pinFromDetails=false
		 				 }
						 else{
							 $scope.fromDetails=false;
						 }
		 			 }
					}
				}
			}
		}

		//whenever plan is changed from the results Page itself
		$rootScope.planChangeClick=function(value, proc){
			if(value){
				paginationDisable=true;
			}
			var firstRecordOnPage = 1;
			var lastRecordOnPage = 0
			if($scope.providerRes.interfacePaging){
				if($scope.providerRes.interfacePaging.paging && $scope.providerRes.interfacePaging.paging.total && $scope.providerRes.interfacePaging.paging.perPage){
					var totalProviders=parseInt($scope.providerRes.interfacePaging.paging.total);
					var perPageProviders=parseInt($scope.providerRes.interfacePaging.paging.perPage);
					var lPage=Math.ceil(totalProviders/perPageProviders);
				}
				if($scope.providerRes.interfacePaging.firstRecordOnPage){
					firstRecordOnPage=$scope.providerRes.interfacePaging.firstRecordOnPage;
				}
				if($scope.providerRes.interfacePaging.lastRecordOnPage){
					lastRecordOnPage=$scope.providerRes.interfacePaging.lastRecordOnPage;
				}
			}
			ProviderSearchCriteriaService.setPage(1);
			ProviderSearchCriteriaService.setDirection("");
			if(proc=="skip"){
				$scope.criteria.planProductCode="";
			}
			else{
				$scope.criteria.planProductCode=proc;
			}
			
			/* Save state later for browser back button */
			/*var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };

			var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
			url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
			history.replaceState(stateObj, "Aetna",url);*/
			
			fetchProviderResults();
		};

		$scope.printPage = function() {
			$window.print();
		}
		// control the colorful display of tier messages

		// return the ID for a tier message in a provider.  The ID is passed to other functions to determine
		// the CSS classes needed to generate the HTML.  This is needed because the service does not return
		// anything about the type of tier message except text.
		// Note: Right now, the classes are determined by the actual text of the message - yuck
		// We need a code returned by the service so we can test on something better.
		function tierMessageId (provider) {
			// return null if no designations for provider
			var d = provider.providerDesignations;
			if (!d) return null;
			if (!Array.isArray(d)) {
				d = [d];
			}

			for (var i=0; i<d.length; i++) {
				var designation = d[i];
				if (designation.type === 'tier' && designation.description) {
					// the code is in the message text
					var msg = designation.description.split('_');
					return msg;
				}
			}
			return null;  // if we get here, no tier designation
		}

		// fill in the tier message ID for all providers since we aren't given this info in the service.
		function fillInTierMessageIds() {
			if ($scope.providerRes.providerInfoResponses) {
				if (Array.isArray($scope.providerRes.providerInfoResponses)) {
					var length = $scope.providerRes.providerInfoResponses.length;
					for (var index=0; index < length; index++) {
						// provider object will be in array if more than one provider
						var provider = $scope.providerRes.providerInfoResponses[index];
						var msg = tierMessageId(provider);  // get code and text
						if (!msg) continue;  // skip if no tier info
						provider.tierMessageId = msg.length > 1 ? msg[0] : null;
						provider.tierMessage = msg.length > 1 ? msg[1] : msg[0];
					}
				} else {  // just one provider
					var provider = $scope.providerRes.providerInfoResponses;
					var msg = tierMessageId(provider);  // get code and text
					if (!msg) return;
					provider.tierMessageId = msg.length > 1 ? msg[0] : null;
					provider.tierMessage = msg.length > 1 ? msg[1] : msg[0];
				}

			}

		}

		// get a unique key for a provider
		function getProviderKey(provider) {
					// handle bad provider parameter
					if (!provider || !provider.providerInformation || !provider.providerLocations
						|| !provider.providerLocations.locationID
						|| !provider.providerInformation.providerID) {
						return null;  // bad data - no key
					}

					var key = provider.providerInformation.providerID
						+ '.'
						+ provider.providerLocations.locationID;
					return key;
		}

		$scope.openFauxRowURL = function(fauxcontent) {

			
			URL = fauxcontent.url;
			currentWindow = fauxcontent.openInCurrentWindow;
			
			if(fauxcontent.external == "true") 
			{
				ProviderResultsService.showDisclaimer(URL,'standard',null);
				return;
			}
			else if(URL.indexOf("contentPage?") > -1 )
			{
					URL = URL + "&site_id=" + siteId + "&language=" + language;
					$scope.criteria.direction = '';
					$scope.criteria.page = 1;
			}
				
			if(currentWindow == "true")
			{
				window.location.href = URL;
			}
			//All url's will by default open in new window unless the indicator currentWindow is true.
			else{
				
				ProviderResultsService.openURL(URL);
			}
			/*
			if (label != null && label != undefined && label.indexOf("vision") > -1) {
				ProviderResultsService.showDisclaimer(URL,'vision',null);
			 }
			 else if (URL != null && URL != undefined && URL.indexOf("aetna") == -1) {
				 if(label != null && label != undefined && label.indexOf("LGBT") > -1){
					 ProviderResultsService.showDisclaimer(URL,'vision',null);
				 }else
					 ProviderResultsService.showDisclaimer(URL,'standard',null);
			}
			 else{
				 ProviderResultsService.openURL(URL);
			 }
		*/};


		/* Support for compare providers functionality start */

		resultsService.compareInit();  // always do it once

		// indicate if we are doing a compare - if user has checked any providers to compare
		$scope.doingCompare = function() {
			return compareData.items.length > 0;
		};

		// return array of providers being compared
		var providersBeingCompared = function() {
			return compareData.items;
		};
		// return array of providers being compared
		$scope.providersBeingComparedOrder = function() {
			return compareData;
		};

		// indicate if we are currently comparing a given provider
		$scope.comparingProvider = function(provider) {
			if (!$scope.doingCompare()) {
				return false;  // not comparing anything
			}

			var key = resultsService.getProviderKey(provider);
			if (!key) {
				return false;  // invalid provider object
			}

			return compareData.lookup[key];  // indicate if comparing provider
		};

		// indicate if user can add any more providers to compare
		function canCompareMore() {
			return compareData.items.length < compareData.MAX_SIZE;
		}

		// indicate if user can compare the checked providers
		$scope.canDoCompare = function() {
			return compareData.items.length > 1;
		};

		// add provider to list of providers to be compared if possible.  Handle too many items and duplicate
		$scope.addToCompare = function(provider) {
			if (!canCompareMore()) {
				return;  // cannot compare any more items
			}

			var key = resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (compareData.lookup[key]) {
				return;  // item is already being compared
			}

			compareData.items.push(provider);  // add to list
			compareData.lookup[key] = provider;  // add to lookup
		}

		// remove provider from list of providers being compared.  Handle errors
		var removeFromCompare = function(provider) {
			var key = resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (!compareData.lookup[key]) {
				return;  // item is not being compared
			}

			for (var i=0; i<compareData.items.length; i++) {
				var key2 = resultsService.getProviderKey(compareData.items[i]);
				if (key === key2) {
					compareData.items.splice(i, 1);
					break;  // found it
				} // if found
			} // look through providers being compared
			compareData.lookup[key] = null;  // remove from lookup
		}

		// remove all providers from list of providers being compared.
		var cancelCompare = function() {
			resultsService.compareInit();
		}


		// handle user clicking on a checkbox for a particular provider.  This may do or undo the compare.
		$scope.providerCompare = function(provider) {
			if (!$scope.providerCheckable(provider)) {
				return;  // not allowed to check this provider so ignore
			}
			var key = resultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}
			if (compareData.lookup[key]) {  // we are already comparing this item, so stop comparing it
				removeFromCompare(provider);

				AnalyticsService.trackAddRemoveCompare({
					providerID : provider.providerInformation.providerID,
					locationID : provider.providerLocations.locationID,
					key : key}, 'remove');
			} else {
				$scope.addToCompare(provider);

				AnalyticsService.trackAddRemoveCompare({
					providerID : provider.providerInformation.providerID,
					locationID : provider.providerLocations.locationID,
					key : key} , 'add');
			}
		}

		// determine if checkbox is read/write (checkable)
		$scope.providerCheckable = function(provider) {
			if (canCompareMore()) {
				return true;  // all checkboxes are checkable
			}

			// at this point, a checkbox is read/write only if it is already involved in a compare.
			var key = resultsService.getProviderKey(provider);
			if (!key) {
				return false;  // invalid provider object
			} else if (compareData.lookup[key]) {  // we are already comparing this provider, so it is checkable
				return true;
			} else {
				return false;
			}
		}

		$scope.changeCheckboxImage=function(provider){
			if($scope.comparingProvider(provider)){
				return 'images/purple-checked.png';
			}
			else if(!$scope.comparingProvider(provider)){
				if($scope.providerCheckable(provider)){
					return 'images/purple-unchecked.png';
				}
				else{
					return 'images/unchecked_box.png';
				}
			}
		}

		$scope.getCompareList = function(){
			return $scope.compareListArray;
		};

		$scope.getCompareListFromService = function(){
			 $scope.compareListArray = CompareProviderService.getProvidersToCompare();

			return $scope.compareListArray;
		};

		$scope.showHospitalsFromService = function()
		{
			//$scope.showHospitals = CompareProviderService.getShowHospitals();
			return CompareProviderService.getShowHospitals();
		};

		$scope.getHosCountFromService = function()
		{
			return CompareProviderService.getHosCount();;
		};



		// compare the checked providers
		var hosCount = 0;
		var showHospitals = false;
		$scope.doCompare = function() {
			//$scope.isShowCompareWindow=!$scope.isShowCompareWindow;

			if(!compareData.showCompare){
				compareData.showCompare = true;
				window.scrollTo(0,0);
				$scope.compareListArray = providersBeingCompared();

				CompareProviderService.setProvidersToCompare($scope.compareListArray);
				CompareProviderService.setShowComparePopUp(compareData.showCompare);

				$scope.hosOrder = $scope.providersBeingComparedOrder();
				$scope.isShowSortFilterWindow=false;
				hosCount=0;

				CompareProviderService.setHosCount(hosCount);

				// code for hospital Affliations <starts>
				$scope.hospitalAffiliations = [];
				for(var i=0; i<$scope.compareListArray.length; i++){
						if($scope.compareListArray[i].providerInformation.type === 'Individual'){
								showHospitals = true;

								CompareProviderService.setShowHospitals(showHospitals);

								ProviderResultsService.setProvider($scope.compareListArray[i]);
									ProviderResultsService.getProviderDetails()
									.then(
												function success(result) {
													hosCount++;

													CompareProviderService.setHosCount(hosCount);

													if( result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID != undefined){
																	var hosLocId = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID;
													}
													if( result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].providerID != undefined){
																	var hosProId = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.providerLocations[0].providerID;
													}
													var orderKey = hosProId
														+ '.'
														+ hosLocId;
														for(var k=0;k<$scope.compareListArray.length; k++){
																	var tempkey = $scope.compareListArray[k].providerInformation.providerID
																		+ '.'
																		+ $scope.compareListArray[k].providerLocations.locationID;
																		// alert("k ::  " + k + " tempkey :" + tempkey + " and orderKey : " + orderKey);
																		if(tempkey === orderKey){
																				$scope.compareListArray[k].itsHosps = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals;  // add to list
																				// alert("After Hospitals " + k +" : "+ $scope.compareListArray[k].itsHosps[0].providerDisplayName.full);
																				CompareProviderService.setProvidersToCompare($scope.compareListArray);
																		}
														}
													  // result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals.orderName = result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.practitioner.nameLast;
														// $scope.hospitalAffiliations.push(result.providerResponse.readProviderResponse.providerDetailsResponse.individualProviderDetails.associatedHospitals);
												}
									);
						}else{
								hosCount++;
								CompareProviderService.setHosCount(hosCount);
						}
				}

				AnalyticsService.trackCompare();
				// code for hospital Affliations <ends>
				$('.compareOptions').show();
				/*angular.element("#comparePopUp" ).show();
				angular.element("#comparePopUp" ).show();*/

				CompareProviderService.setProvidersToCompare($scope.compareListArray);
				$scope.showPopUpFormService =

				setTimeout(function(){ $rootScope.focusForModal('comparePopUp'); }, 100);
				angular.element("#comparePopUp" ).css("display","block");
				angular.element("#comparePopUp" ).addClass("fadeIn");
				angular.element("#comparePopUp" ).removeClass("fade");

				$("#comparePopUpInLayout").siblings().attr('aria-hidden',true);;
				$("#comparePopUpInLayout").attr('aria-hidden',false);

				$(".SI_eh2H1xGrz3D73a5_SliderContainer").attr('aria-hidden',true);

				setTimeout(function(){ $rootScope.focusForModal('compareOptionsModal'); }, 100);
				setTimeout(function(){$('#compareOptionsModal').focus(); }, 200);
				angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");

				/*angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");*/

			}
			else{
				$scope.compareListArray = providersBeingCompared();
				$scope.isShowSortFilterWindow=false;
				CompareProviderService.setProvidersToCompare($scope.compareListArray);
			}
		}


		// allow other controllers to do a compare
		/*var unregisterCompareFn = $scope.$on('doCompare', function (event, arg) {
			$scope.doCompare();
		});*/


		// functions to handle compare island
		// indicate if we are doing a compare - if user has checked any providers to compare
		//and the compare popup is not being displayed currently
		$scope.doingCompare1 = function() {
			return $state.params.page == "providerResults" && ProviderResultsService.compareData.items &&
			       ProviderResultsService.compareData.items.length > 0 && ProviderResultsService.compareData.showCompare == false;
		}

		// indicate if user can compare the checked providers
		$scope.canDoCompare1 = function() {
			return ProviderResultsService.compareData.items &&
			      ProviderResultsService.compareData.items.length > 1;
		}

		// return array of providers being compared
		$scope.providersBeingCompared1 = function() {
			return ProviderResultsService.compareData.items;
		}

		// remove provider from list of providers being compared.  Handle errors
		$scope.removeFromCompare1 = function(provider) {
			var key = ProviderResultsService.getProviderKey(provider);
			if (!key) {
				return;  // invalid provider object
			}

			if (!ProviderResultsService.compareData.lookup[key]) {
				return;  // item is not being compared
			}

			for (var i=0; i<ProviderResultsService.compareData.items.length; i++) {
				var key2 = ProviderResultsService.getProviderKey(ProviderResultsService.compareData.items[i]);
				if (key === key2) {
					ProviderResultsService.compareData.items.splice(i, 1);
					break;  // found it
				} // if found
			} // look through providers being compared
			ProviderResultsService.compareData.lookup[key] = null;  // remove from lookup
		};

		// remove all providers from list of providers being compared.
		$scope.cancelCompare1 = function() {
			ProviderResultsService.compareInit();
			CompareProviderService.reset();
		};

		//On clicking cross icon in compare window
		$scope.compareDialogClose=function(){

			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");

			var returnToLinkId;
			if ( $scope.compareListArray && $scope.compareListArray.length >= 1)
			{
				var lastElement = $scope.compareListArray.length - 1 ;
				returnToLinkId = $scope.compareListArray[lastElement].providerInformation.providerID;
			}
			$scope.compareListArray=[];
			cancelCompare();
			compareData.showCompare = false;

			if ( returnToLinkId )
			{
					returnFocusToRprtIncLink( returnToLinkId );
			}

		};

		$scope.compareDialogCloseFromService =function(){

			$("#comparePopUpInLayout").siblings().attr('aria-hidden',false);;
			$("#comparePopUpInLayout").attr('aria-hidden',true);
			$(".SI_eh2H1xGrz3D73a5_SliderContainer").attr('aria-hidden',false);

			$('.compareOptions').hide();
			angular.element("#comparePopUp" ).hide();
			angular.element("#comparePopUp" ).addClass("fade");
			angular.element("#comparePopUp" ).removeClass("fadeIn");
			angular.element("#comparePopUp" ).css("display","none");
			angular.element(".modal-backdrop" ).css("display","none");

			var returnToLinkId;
			$scope.compareListArray = CompareProviderService.getProvidersToCompare();

			if ( $scope.compareListArray && $scope.compareListArray.length >= 1)
			{
				var lastElement = $scope.compareListArray.length - 1 ;
				returnToLinkId = $scope.compareListArray[lastElement].providerInformation.providerID;
			}
			$scope.compareListArray=[];
			cancelCompare();
			compareData.showCompare = false;

			if ( returnToLinkId )
			{
				returnFocusToRprtIncLink( returnToLinkId );
			}

			CompareProviderService.reset();

		};


		/*The Focus will return to the report incorrect information link of the
		 * last provider in the compare array */
		var returnFocusToRprtIncLink=function(id){
			$('#'+id).focus();
		};
		var remFrmCompare=function(index){
			hosCount--;
			CompareProviderService.setHosCount(hosCount);
			$scope.compareListArray.splice(index,1);
			if($scope.compareListArray.length==1)
				$scope.compareDialogClose();
		};

		$scope.remFrmCompareFromService=function(index){

			hosCount = CompareProviderService.getHosCount();
			hosCount--;
			CompareProviderService.setHosCount(hosCount);
			$scope.compareListArray.splice(index,1);

			CompareProviderService.setProvidersToCompare($scope.compareListArray);

			if($scope.compareListArray.length==1)
				$scope.compareDialogCloseFromService();
		};
		// compare the checked providers
		/*$scope.doCompare1 = function() {
			// just send an event to the controller doing the compare
			$rootScope.$broadcast('doCompare', 'message');
		}*/

		/* Support for compare providers functionality end */
		/*$scope.$on('$destroy', unregisterCompareFn);*/

		/*Alpha sort functionality*/
		$scope.getResultsBasedonAlphaSort = function(alphabet){

			var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.replaceState(stateObj, "Aetna", url);


																	var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
																	url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
																	history.replaceState(stateObj, "Aetna",url);

			$(".datGridSort").addClass("dataGridSortOnReset");
			$scope.criteria.isAlphaSort = true;
			$sessionStorage.criteria.isAlphaSort = true;
			var firstRecordOnPage='';
			var lastRecordOnPage='';
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			$scope.statusBeg = true;
			console.log(" 11 : true : $scope.statusBeg" + $scope.statusBeg );
			$scope.statusLast = false;
			/*Resetting page=1 to hide First and Previous button - Ankur*/
			$scope.criteria.page = 1;
			$scope.criteria.statusBeg = $scope.statusBeg;
			$scope.criteria.statusLast = $scope.statusLast;
			listSelections=encodeURIComponent('['+createListSelection(true, alphabet).join(',')+']');
			ProviderSearchCriteriaService.setListSelection(listSelections);
			$sessionStorage.criteria.listSelections = listSelections;
			ProviderSearchCriteriaService.setOrder($scope.sortOrder);
			ProviderSearchCriteriaService.setAlphabetOrder(alphabet);

			$scope.criteria.alphaSet = alphabet;
			$sessionStorage.criteria.alphaSet = alphabet;

			fetchProviderResults();

			stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables() };
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.pushState(stateObj, "Aetna", url);


																	var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
																	url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
																	history.pushState(stateObj, "Aetna",url);
		};
		//Reset button functionality
		$scope.resetAlphaSort = function(){

			var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length,'resultState' : ProviderResultsService.getAllVariables() };
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.replaceState(stateObj, "Aetna", url);


																				var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
																				url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
																				history.replaceState(stateObj, "Aetna",url);

			$(".datGridSort").removeClass("dataGridSortOnReset");
			var firstRecordOnPage='';
			var lastRecordOnPage='';
			ProviderSearchCriteriaService.setFirstRecordOnPage(firstRecordOnPage);
			ProviderSearchCriteriaService.setLastRecordOnPage(lastRecordOnPage);
			$scope.statusBeg = true;
			console.log(" 12 : true : $scope.statusBeg" + $scope.statusBeg );
			$scope.statusLast = false;
			/*Resetting page=1 to hide First and Previous button - Ankur*/
			$scope.criteria.page = 1;
			$scope.criteria.statusBeg = $scope.statusBeg;
			$scope.criteria.statusLast = $scope.statusLast;
			$scope.criteria.isAlphaSort = false;
			$sessionStorage.criteria.isAlphaSort = false;
			/* Find Doctors fix*/
			if( $scope.criteria.hospitalNavigator && $scope.criteria.hospitalNavigator != '' )
			{
				tempArray.splice(-1,1);
				tempArray.splice(-1,1);
				tempArray.push( $scope.criteria.hospitalNavigator );
			}
			/**/
			else
			{
				tempArray.splice(-1,1);
			}
			listSelections=encodeURIComponent('['+createListSelection(false,'',true).join(',')+']');
			ProviderSearchCriteriaService.setListSelection(listSelections);
			$sessionStorage.criteria.listSelections = listSelections;
			//createArrayForListFilters();
			fetchProviderResults();

			stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length,'resultState' : ProviderResultsService.getAllVariables() };
			//for local
			//var url = "/#/contentPage?page=providerResults&site_id="+siteId+"&language="+language;
			//for QA
			// var url = configuration.backURLResults + siteId + "&language=" + language;
			// history.pushState(stateObj, "Aetna", url);


																							var url = configuration.backURLResults;  ///#/contentPage?page=providerResults
																							url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
																							history.pushState(stateObj, "Aetna",url);
		};
		$scope.disableAlphasort = function(isSort){
			if(isSort){
				return false;
			} else{
				return true;
			}
		};
		/**
				* Adding Alphabets and Codes based response
				*/
		var setAlphabets = function(alphasetData){
			$scope.alphabetsArray = [];
			if(alphasetData && alphasetData.listAttributes){
				if(Array.isArray(alphasetData.listAttributes) && alphasetData.listAttributes.length !==0){
					for(var i=0;i<alphasetData.listAttributes.length;i++){
						if(alphasetData.listAttributes[i].listFilters[0].description === 'Alpha Sort'){
							for(var j=0;j<defaultAlphabets.length;j++){
								var alphabetsObj = {};
								alphabetsObj.description = defaultAlphabets[j];
								alphabetsObj.isEnable = false;
								alphabetsObj.code = '';
								$scope.alphabetsArray[$scope.alphabetsArray.length] = alphabetsObj;
							}
							getAlphabets($scope.alphabetsArray, alphasetData.listAttributes[i].listFilters[0].listFilter);
						}
					}
				}
			}
		};
		var getAlphabets = function(alphabets, alphaAttributes){
			for(var i=0;i<alphaAttributes.length;i++){
				for(j=0;j<alphabets.length;j++){
					if(alphaAttributes[i].description === alphabets[j].description){
						$scope.alphabetsArray[j].code = alphaAttributes[i].code;
						$scope.alphabetsArray[j].isEnable = true;
						break;
					}
				}
			}
		};
		//setTimeout(function(){var src = $('#checkURL1').attr('src');
		//alert("source of image with alternate text = example - " + src);},10000);

		//var tempcheck= $("checkURL1").attr("src");

		this.navigatePCP = function(provider, role)
		{
			document.getElementById("Provider_Name").value = provider.providerInformation.providerDisplayName.full;
			document.getElementById("Provider_ID").value = provider.providerInformation.capOfficeID;
			//document.getElementById("Medical_Group_ID").value = provider.providerInformation.capOfficeID;
			document.getElementById("PIN").value=provider.providerInformation.providerID;
			document.getElementById("drxForm").action = $scope.criteria.returnUrl;
			document.getElementById("drxForm").submit();
		};
		
		/*$rootScope.$on('$locationChangeStart', function(event, newUrl, oldUrl) {
			if (oldUrl.indexOf("providerResults") != -1 && 
					(newUrl.indexOf("providerOrgDetails") != -1 || oldUrl.indexOf("providerDetails") != -1 || 
							newUrl.indexOf("providerHospDetails") != -1 )){
			
				var stateObj = {'stateAPI': $scope.criteria, 'History.length': history.length, 'resultState' : ProviderResultsService.getAllVariables()  };
				var url = oldUrl;  ///#/contentPage?page=providerResults
				//url = url + window.location.href.substring(window.location.href.indexOf("&")); ///#/contentPage?page=providerResults
				history.replaceState(stateObj, "Aetna",url);
			}
		});*/
	}

	angular.module('nav-ui')
	.filter('trust', function($sce) {
		function HTMLEncode(str){
			var i = str.length,
			aRet = [];

			while (i--) {
				var iC = str[i].charCodeAt();
				if (iC < 65 || iC > 127 || (iC>90 && iC<97)) {
					aRet[i] = '&#'+iC+';';
				} else {
					aRet[i] = str[i];
				}
			}
			return aRet.join('');
		}

		return function(text) {
			//console.log('trust: ' + text);
//			text = HTMLEncode(text);
			text = $sce.trustAsHtml(text);
			//console.log('new text: ' + text);
			return text;
		}
	});



})();

angular.module('nav-ui').directive('replace', [function(configuration){

	  return {
	    require: 'ngModel',
	    scope: {
	      regex: '@replace',
	      with: '@with'
	    },
	    link: function(scope, element, attrs, model) {
	      model.$parsers.push(function(val) {
	        if (!val) { return; }
	        var regex = new RegExp(scope.regex);
	        var replaced = val.replace(regex, scope.with);
	        if (replaced !== val) {
	          model.$setViewValue(replaced);
	          model.$render();
	        }
	        return replaced;
	      });
	    }
	  };

}]);

},{}],15:[function(require,module,exports){
(function() {
	angular.module('nav-ui').controller('ProviderSearchController', ProviderSearchController);

	ProviderSearchController.$inject = ['$scope', 'configuration', '$sessionStorage',
	'ProviderSearchCriteriaService', '$q', '$state', '$log', '$rootScope', '$http',
	'ProviderResultsService','$translate','$sce','$timeout','$window', 'AnalyticsService','$location','NavSpinnerService','PlanListService','CommonUtilsService','mapsService','$compile','LanguageDataService'];

	function ProviderSearchController($scope, configuration, $sessionStorage,
		ProviderSearchCriteriaService, $q, $state, $log, $rootScope, $http,
		ProviderResultsService,$translate,$sce,$timeout,$window, AnalyticsService,$location,NavSpinnerService,PlanListService,CommonUtilsService,mapsService,$compile,LanguageDataService) {
			$rootScope.$on("destroyScope", function(){
				 $scope.$destroy();
			});

		/* Page title*/
		if(window.location.href.indexOf("providerSearchLanding") !== -1){
			document.title =  "Provider Search - Home";
		}
		else if(window.location.href.indexOf("providerSearchPlanList") !== -1){
			document.title =  "Select a Plan";
		}
		else if(window.location.href.indexOf("page=providerSearch&") !== -1){
			document.title =  "Find a Provider";
		}
		else if (window.location.href.indexOf("providerResults") != -1){
			document.title =  "Provider Search Results";
		}
		else if (window.location.href.indexOf("providerDetails") != -1){
			document.title =  "Provider Details";
		}
		else {
			document.title =  "Find a Provider";
		}
		
		var ctrl = this;
		ctrl.person = {};
		$scope.showLocation=false;
		ctrl.isChangeLocation = false;  // if location popup is open
		ctrl.showRestrictedMessage=false;
		var flagForSess=sessionStorage.getItem('boolForGeo');
		clicked = false;
		// ProviderSearchCriteriaService.setCriteria();

		if(window.history && window.history.pushState) {
			//window.history.pushState('forward', null, './#forward');
			$(window).on('popstate',function() {
				angular.element(".modal-backdrop" ).css("display","none");
				// var historyObj = window.history;
				// if(location.href=="url"){
				// 		history.go(-1);
				// 	}
			});
		}
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.planCriteria = ProviderSearchCriteriaService.getPlanCriteria();

		$scope.languageData = LanguageDataService.getLanguageData();

		var currentPage = $location.search().page;
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		
		//ACNLA5_0603 code changes start
		if($state.params.parameters === "disbaleChangeLocation"){
			$scope.linkStatus = true;
		}else{
			$scope.linkStatus = false;
		}
		//ACNLA5_0603 code changes end

		if((currentPage == "providerSearchGeo" || currentPage == "providerSearchLanding") && siteId=="provider"){
			angular.element(".modal-backdrop" ).css("display","none");
		}

		if(currentPage != "providerResults" && (currentPage == "providerSearchLanding" || currentPage == "providerSearchPlanList" || currentPage == "providerSearch")){
			$sessionStorage.visitedDetails = 0;
		}else if(currentPage != "providerDetails" || currentPage != "providerHospDetails" || currentPage != "providerOrgDetails") {
			$sessionStorage.visitedDetails = 1;
		}

		if ($scope.languageData.SWITCH_PLANNAME_LANDING == 'ON') {

			if((currentPage == "providerSearchGeo" || currentPage == "providerSearchLanding") && $location.search().planValue){
				$scope.criteria.dummyPlanCode = '';
				$scope.criteria.planName = '';
				$scope.criteria.planProductCode = '';
				$scope.listOfPlans = '';

				$scope.criteria.planValue = $location.search().planValue;
				executePlanPrefillFlow();
			}

		}
		var sliderValue=25;
		if($scope.languageData != undefined &&  $scope.languageData.DEFAULT_DISTANCE != undefined ){
		    sliderValue=$scope.languageData.DEFAULT_DISTANCE;
		}
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		setTimeout(function(){
			 $('.rz-pointer-min').attr('aria-describedby','minMaxValue');
			 $compile($(".rz-pointer-min"))($scope);
		 }, 500);
    // code to adjust height of the block <starts>
	  // function larg(){
		// 		var linkHeightArray=[];
		// 		var linkBlocks=$('.dynamicHeight').children();
		// 		if(linkBlocks && linkBlocks.length){
		// 										for (var i = 0; i < linkBlocks.length; i++) {
		// 																		linkHeightArray.push($(linkBlocks[i]).find('.search-block-description').outerHeight(true));
		// 																		//linkHeightArray.push(linkBlocks[i].find('.search-block-description').height());
		// 										}
		// 										var max = Math.max(...linkHeightArray);
		// 										$('.search-block-description').css('height',max);
		// 		}
	  // }
		// $(document).ready(larg);
		// $(window).resize(function(){
		// 								if($(window).width()<=991){
		// 																$('.search-block-description').css('height','auto');
		// 								}
		// 								else{
		// 										var linkHeightArray=[];
		// 										var linkBlocks=$('.dynamicHeight').children();
		// 										if(linkBlocks && linkBlocks.length){
		// 																		for (var i = 0; i < linkBlocks.length; i++) {
		// 																										linkHeightArray.push($(linkBlocks[i]).find('.search-block-description').outerHeight(true));
		// 																										//linkHeightArray.push(linkBlocks[i].find('.search-block-description').height());
		// 																		}
		// 																		var max = Math.max(...linkHeightArray);
		// 																		$('.search-block-description').css('height',max);
		// 										}
		// 								}
		// });
    // code to adjust height of the block <ends>

		var memberPleat = false;
		var geoPleat = false;
		var isLocationboxClicked = false;
		var currentLocationAllowed = "";

		var pDiv = $(".My_Coverage")[0];
		if(pDiv){
			if (pDiv.firstChild.firstChild.innerHTML.length === 0){
					var ele = pDiv.firstChild;
					pDiv.removeChild(ele);
			}
		}
		// var emptyLink = document.getElementById("emptyLink");
		// if(emptyLink){
		// 	var innerText = emptyLink.innerHTML;
		// 	if(innerText.length ===0){
		// 		var ele = emptyLink.parentElement;
		// 		ele.parentElement.removeChild(ele);
		// 	}
		// }


		var redirectURLSingle = '';
		var externalURLSingle = '';
		if(window.location.href.indexOf("providerSearchLanding") !== -1){
			$scope.checkIfLandingPage = true;
			$scope.criteria.typeAheadSearch= '';  // value in the search box
			$scope.criteria.typeAheadLocation= '';  // value in the location box
			$scope.criteria.typeAheadLocationClicked= null;  // what was clicked on for location search
			$scope.criteria.typeAheadLocationResults= {};

			if( $sessionStorage.criteria && $sessionStorage.criteria.typeAheadLocationResults )
			{
				$sessionStorage.criteria.typeAheadLocationResults = {};
			}

			// Empty href Issue on landing Page buttons 
			$("[linkToReplace]").each(function() {
				if($(this).attr("href")==""){
					var curLink = $(this).attr("linkToReplace");
					$(this).attr("href",curLink);
				}else{
					$(this).removeAttr("linkToReplace");
				}
			});

    		// $("[linkToReplace]").attr("href", "red");
		}else{
			$scope.checkIfLandingPage = false;
			// if(!(window.location.href.indexOf("providerSearchGeo") !== -1)){
			// 	if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
			// 				$state.go('contentPage',{page:'providerSearchLanding',parameters:'',site_id:siteId,language:language});
			// 	}
			// }
		}

		/* Criteria related to search which are reset during 'Start a new search should be done on Search page for all searches */
		function startanewSearch()
		{
						//$scope.reset();
						$scope.criteria.searchFocus = false;
						$scope.criteria.isResetFilter = false;
						// console.log("resetfilter startanewSearch results"+ $scope.criteria.isResetFilter);
						$scope.criteria.filterOrder = '';
						$scope.criteria.checkedItem = [];
						$scope.criteria.checkedItemChildren = [];
						$scope.criteria.showFilterContent=[];
						$scope.criteria.showSecLevelContent=[];
						$scope.criteria.listSelections = null;
						$scope.criteria.direction = '';
						$scope.criteria.order = '';
						$scope.criteria.isAlphaSort = false;
						$scope.criteria.selectedFilters = '';
						$scope.criteria.selectedListArray = [];
						$scope.criteria.hospitalNavigator = null;
						$scope.criteria.isProviderForIPA = false;
				 		$scope.criteria.isProviderForGroup = false;
				 		/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
				 		$scope.criteria.isProviderForHospital = false;
				 		$scope.criteria.isFindDoctor = false;
						$scope.criteria.typeAheadSearch = '';
						ProviderResultsService.setHospitalId('');
						ProviderResultsService.setIpaDetails('');
						ProviderResultsService.setFindDoctors("");
						ProviderResultsService.setGroupdetails('','',false);
						$scope.criteria.groupIPAaPI = "";
						$sessionStorage.criteria.groupIPAaPI = "";
						$scope.criteria.findDocPrevId = "";
				 		$scope.criteria.ipaName = '';
				 		$rootScope.grpName = '';
		};

		if(window.location.href.indexOf('page=providerSearch&') > -1){
			$scope.checkIfProvSerPage = true;

			startanewSearch();
			
			/**/
		}else{
			$scope.checkIfProvSerPage = false;
			// if(!(window.location.href.indexOf("providerSearchGeo") !== -1)){
			// 	if($scope.criteria.typeAheadLocationResults.label == "" || $scope.criteria.typeAheadLocationResults.label == null || $scope.criteria.typeAheadLocationResults.label == undefined){
			// 				$state.go('contentPage',{page:'providerSearchLanding',parameters:'',site_id:siteId,language:language});
			// 	}
			// }
		}

		// To add the href's from Child to Parent Anchor
		var allA =$('a.imagr-caption.clearfix');
		if(allA !== undefined){
			$.each( allA, function( key, value ) {
			  $(this).attr('href', $(this).find('a').attr('href'));
			});			
		}


		$scope.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;
		if ( $sessionStorage.criteria )
		{
			$sessionStorage.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;
		}
		var clearSess=function(){
			if(flagForSess=="true"){
				$scope.criteria.typeaheadLocation="";
				//sessionStorage.removeItem('navcriteria');
				sessionStorage.setItem('boolForGeo',"false");
			}
			if (window.performance) {}
  		if (performance.navigation.type == 1) {
    		$scope.criteria.typeaheadLocation="";
  		} else {}
		}
		clearSess();

// code to adjust XML <starts>
// angular.element("#paragraph_31" ).addClass("container");
// code to adjust XML <ends>

		/* $rootScope.$on('openLocationPopUp',function() {
			ctrl.showRestrictedMessage=true;
			//ctrl.isChangeLocation = true;
			angular.element("#changeLocation" ).show();
			angular.element("#changeLocation" ).css("display","block");
			angular.element("#changeLocation" ).addClass("fadeIn");
			angular.element("#changeLocation" ).removeClass("fade");
			angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
			$scope.criteria.typeaheadLocation = '';
			ctrl.crossHide=true;
			ctrl.cancelHide=true;
			 $timeout(function () {
				 $scope.$broadcast('rzSliderForceRender');
		     });

		}); */

		$scope.typeAheadInput=function(id){
			var temp = $('#'+id);
			var ter=temp.find('a');
			if(ter.length>0 && ter[0].innerText!==''){
				$('#zip1').attr('aria-label',ter[0].innerText)
			}
			return true;
		}

		$scope.typeAheadInput2=function(id){
			var temp = $('#'+id);
			var ter=temp.find('a');
			if(ter.length>0 && ter[0].innerText!==''){
				$('#Doctors').attr('aria-label',ter[0].innerText)
			}
			return true;
		}

		var checkPage=function(){
			var contentPage = $location.search().page;
        	if(!contentPage){
        		var urlLink = window.location.href.split("=");
        		contentPage = urlLink[urlLink.length-1];
        	}
			if(contentPage=="providerSearch"){
				$scope.showLocation=false;
			}else{
				$scope.showLocation=true;
			}
		};

		$scope.reportError = function( typeaheadLocation , errorMsg , errorFor ) {

			AnalyticsService.trackError({
				errorFor: errorFor,
				errorMsg: errorMsg,
				geoSearchTerm: typeaheadLocation,
				state: 'error'
			});
	      };

		checkPage();
      $scope.$watch("ctrl.noResultsSearch", function() {
          if ( ctrl && ctrl.noResultsSearch && $scope.criteria.typeAheadSearch.length >= 3) {
        	  AnalyticsService.trackError({
  				errorFor: 'typeahead search',
  				errorMsg: 'noMatchInSearchTypeahead',
  				searchTerm: $scope.criteria.typeAheadSearch,
  				state: 'error'
  			});
          }
          /*focusOnCross();*/
	  });
      /*focusOnCross=function(){
          if ( ctrl && ctrl.noResultsSearch && $scope.criteria.typeAheadSearch.length >= 3) {
        	  document.getElementById("popclose-search").focus();
          }
    }*/
//typeahead close focus:
     /* if(ctrl.noResultsSearch  && $scope.criteria.typeAheadStatus != 'down'){
    	  document.getElementById("popclose-search").focus();
      }*/


// ----------------------------------- CODE FOR AUTOADJUSTING ON ROTATING DEVICE <STARTS>-----------------

	// //bind to resize
	// $(window).resize( function() {
	// 	activateLandingPleats()
	// });


	// //if you need to call it at page load to resize elements etc.
	// $(window).load( function() {
	// 	activateLandingPleats()
	// });


	// //check for the orientation event and bind accordingly
	// if (window.DeviceOrientationEvent) {
	// 	window.addEventListener('orientationchange', activateLandingPleats, false);
	// }

// ----------------------------------- CODE FOR AUTOADJUSTING ON ROTATING DEVICE <ENDS> -----------------


      if(window.location.href.indexOf("providerSearchLanding") != -1){

				var isMainWhiteBlockOne = document.getElementById("mainWhiteBlockOne");
				if(isMainWhiteBlockOne  == undefined){
						$('.aet-content-fluid.linkBlockStyle.container > div:lt(1), .aet-content-fluid.linkBlockStyle.container > h2:lt(1), .aet-content-fluid.linkBlockStyle.container > p:lt(2)').wrapAll('<div class="whiteBoxBlock container widthAdj" role="main" id="mainWhiteBlockOne"></div>');


		    	  //for footer
		    	  /* Most  custom sites will not have the extra links so added check for usefulRescources */
		    	  if( $("[nvstyle='homePgExtraLinks']").length != 0){
							$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //'Important Information' block
							$("[nvstyle='homePgExtraLinks']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //Extra links on Landing Page
							if($("[nvstyle='usefulResourcesContent']").length!=0){
								$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //'Other useful resources' block
							}
							// $("#emptyLink").first().attr("style","padding:3px 20px !important; width:240px !important;");
							//$("#buttonEmptyLink").addClass("landingBtnWidth txtAlgCntr");
							//$("#emptyLink").addClass("BtnWidth txtAlgCntr");
						}
		    	  else{
							if($("[nvstyle='usefulResourcesContent']").length!=0){
								$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
		    		  	$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
							}
							else{
								if($(".customLinkDiv").length!=0){
									$(".customLinkDiv").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //For Important Info block if Other Useful resources block is not present.
								}
								else
									$("#mainWhiteBlockOne").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>'); //For Important Info block if Other Useful resources block is not present.
							}
		    	  }
		    	  // $("[nvstyle='customCenterLink']:first").prepend("<br/><br/>");
						//$("[nvstyle='customCenterImg']").nextAll().wrap('<div class="customLinkDisplay"></div>');
						$("[nvstyle='customCenterImg']").wrapAll('<div></div>');
		    	  $("[nvstyle='customCenterImg']").addClass('planSponsorLogoDisplay');
		    	  // $("[nvstyle='customCenterLink']").after("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;");
		    	  // $("[type='columnTwo']").addClass('sectionPartition');
				  $("[type='columnTwo']").addClass('sectionPartition landingMarT15 columnTwoTablet columnTabletWidth');
				  $( ".purplePleat h2.firstPleatHead" ).nextAll().wrapAll( "<div class='minHt420' id='firstPleatBody'></div>" );


				// activateLandingPleats();

				if( (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)) && $(window).width() < 992 ){

							if(window.location.href.indexOf("openPleats") != -1){
										memberPleat = false;
										geoPleat = false;
							}else{
										memberPleat = $scope.criteria.memberPleat;
										geoPleat = $scope.criteria.geoPleat;
							}
							if(memberPleat === false){
										$("#firstPleatBody").hide();
							}
							if(geoPleat === false){
										$(".secondPleatBody").hide();
							}
							$(".firstPleatHead").attr("tabindex", "0");
							$(".secondPleatHead").attr("tabindex", "0");

							$(".firstPleatHead").keypress(function(e) {
								if(e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
											memberPleat = !memberPleat;
											$scope.criteria.memberPleat = !memberPleat;
											$("#firstPleatBody").toggle(1000);
								}
							});
							$(".secondPleatHead").keypress(function(e) {
								if(e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
											geoPleat = !geoPleat;
											$scope.criteria.geoPleat = !geoPleat;
											$(".secondPleatBody").toggle(1000);
								}
							});
							$(".firstPleatHead").click(function(){
									memberPleat = !memberPleat;
									$scope.criteria.memberPleat = !memberPleat;
									$("#firstPleatBody").toggle(1000);
							});
							$(".secondPleatHead").click(function(){
									geoPleat = !geoPleat;
									$scope.criteria.geoPleat = !geoPleat;
									$(".secondPleatBody").toggle(1000);
									$timeout(function () {
											$scope.$broadcast('reCalcViewDimensions');
									}, 1001);
							});
					}


				$("#firstPleatBody").wrap( "<div class='customFltLt'></div>" );

				$("#firstPleatBody > a:lt(2), #firstPleatBody > span:lt(1)").wrapAll('<div class="col-lg-12 col-xs-12 col-sm-12 col-md-12 pad0 padT10 padB20" id="landingbuttonBlock"></div>');

				$("[nvstyle='secure_button']").wrap("<div class='col-lg-6 col-md-12 col-sm-12  col-xs-12 pad0 secureButtonBlk' id='secureButtonBlock'></div>");
				$("#secureButtonBlock").next('span').next().addBack().wrapAll("<div class='col-lg-6 col-md-12 col-sm-12  col-xs-12 pad0 padL10 registerButtonBlk'></div>");

				$('.customFltLt').prev().addClass('greyshdw');
				$('.secondPleatHead').addClass('greyshdw');
				$('.registerButtonBlk > span').addClass('marR10');
				// $("[nvstyle='homePageUnordered']:first").nextAll(':lt(2)').wrapAll( "<div class='customFltRt'></div>" );

				}
      }else if(window.location.href.indexOf("providerSearchPlanList") != -1){
						var isWhitePlanList = document.getElementById("whitePlanList");
						if(isWhitePlanList  == undefined){
								// $('.aet-content-fluid.linkBlockStyle.container > div:lt(1), .aet-content-fluid.linkBlockStyle.container > span:lt(2), .aet-content-fluid.linkBlockStyle.container > a:lt(2)').wrapAll('<div class="whiteBoxBlock container"></div>');
								if($(".aet-content-fluid.linkBlockStyle.container > div").length < 5){
										$('.aet-content-fluid.linkBlockStyle.container > div:lt(1), .aet-content-fluid.linkBlockStyle.container > span:lt(2), .aet-content-fluid.linkBlockStyle.container > a:lt(2), .aet-content-fluid.linkBlockStyle.container > p:lt(1)').wrapAll('<div class="whiteBoxBlock container"></div>');
								}else {
										$('.aet-content-fluid.linkBlockStyle.container > div:lt(2), .aet-content-fluid.linkBlockStyle.container > span:lt(2), .aet-content-fluid.linkBlockStyle.container > a:lt(2), .aet-content-fluid.linkBlockStyle.container > p:lt(1)').wrapAll('<div class="whiteBoxBlock container"></div>');
								}
								$("[type='contentTop'][parenttype='page']").prependTo(".whiteBoxBlock.container");
								$(".whiteBoxBlock.container").addClass("widthAdj");
								//for footer
								if($("[nvstyle='usefulResourcesContent']").length != 0){
									$("[nvstyle='usefulResourcesContent']").before($('.customLinkDiv'));
									$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container padT10 padB10 widthAdj" id="whitePlanList"></div>');
									$( "[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container padT10 padB10 widthAdj"></div>');
								}else{
									var disclaimerContentDiv = document.getElementById("disclaimerContent");
									if(disclaimerContentDiv == undefined)
										if($("[nvstyle='disclaimerFooter']").length > 1){
											$("[nvstyle='disclaimerFooter']").nextAll().addBack().wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
										}else {
											$("[nvstyle='disclaimerFooter']").wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
										}
								}

								//$('.customLinkDiv').parent().before($('.customLinkDiv'));
								// $("[nvstyle='customCenterImg']:first").css("display","block");
				    	  // $("[nvstyle='customCenterImg']:first").css("padding-bottom","20px");
								$("[nvstyle='customCenterImg']").wrapAll('<div></div>');
				    	  $("[nvstyle='customCenterImg']").addClass('planSponsorLogoDisplay');
						}
		}else if(window.location.href.indexOf("providerSearch&") != -1){
					var isWhiteBoxFooter= document.getElementById("otherUsefulResourceCont");
					//if(isWhiteBoxFooter == undefined){
					if(isWhiteBoxFooter == undefined){
						if($("[nvstyle='usefulResourcesContent']").length != 0){
							$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
							$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj" id="otherUsefulResourceCont"></div>');
						}else{
							var disclaimerContentDiv = document.getElementById("disclaimerContent");
							if(disclaimerContentDiv == undefined){
								if($("[nvstyle='disclaimerFooter']").length > 1){
									$("[nvstyle='disclaimerFooter']").nextAll().addBack().wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
								}else {
									$("[nvstyle='disclaimerFooter']").wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
								}
							}

						}

							// $("[nvstyle='customCenterImg']:first").css("display","block");
							// $("[nvstyle='customCenterImg']:first").css("padding-bottom","20px");
							$("[nvstyle='customCenterImg']").wrapAll('<div></div>');
			    	  $("[nvstyle='customCenterImg']").addClass('planSponsorLogoDisplay');
					}

					console.log(document.getElementsByClassName("imagr-caption.clearfix").href);
		}else{

				var isotherUseRes = document.getElementById("otherUsefulResourceCont");
				if(isotherUseRes  == undefined){
					if($("[nvstyle='usefulResourcesContent']").length != 0){
			    			$("[nvstyle='usefulResourcesContent']").nextAll().wrapAll('<div class="whiteBoxBlock container widthAdj"></div>');
							$("[nvstyle='usefulResourcesContent']").wrapAll('<div class="whiteBoxBlock container widthAdj" id="otherUsefulResourceCont"></div>');
					}else{
						var disclaimerContentDiv = document.getElementById("disclaimerContent");
						if(disclaimerContentDiv == undefined){
							if($("[nvstyle='disclaimerFooter']").length > 1){
								$("[nvstyle='disclaimerFooter']").nextAll().addBack().wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
							}else {
								$("[nvstyle='disclaimerFooter']").wrapAll('<div class="whiteBoxBlock container widthAdj" id="disclaimerContent"></div>');
							}
						}
					}
							// $("[nvstyle='customCenterImg']:first").css("display","block");
							// $("[nvstyle='customCenterImg']:first").css("padding-bottom","20px");
							$("[nvstyle='customCenterImg']").wrapAll('<div></div>');
			    	 $("[nvstyle='customCenterImg']").addClass('planSponsorLogoDisplay');
				}
		}
		var tempVar1=$("[nvstyle='usefulResourcesContent']");
		if(tempVar1 && tempVar1.length){
			if(tempVar1[0].children[0].innerHTML==""){
				tempVar1.css("display","none")
			}
		}



		var langua = $state.params.language;

		if (langua == null || langua == undefined || langua !== "es") {
			langua = "en";
		}
		if(langua!=null && langua!=undefined)
		{
				$scope.criteria.lang = langua;
				var lang = $translate.use();
				lang = langua;
		}

		else{
				$scope.criteria.lang = "en";
				var lang = $translate.use();
				lang = "en";
		}

		if($translate.use() == 'es')
			event = "SP_PRVINQ";
		else
			event = "PRVINQUIRY";
		//call the events api.
		var eventType = "";///psMetrics event handling, send empty eventType
		// EventsService.fireEvent(event, eventType);

		// if($state.params.page!=null && $state.params.page!=undefined && $state.params.page.indexOf('results')==-1){
		// 		 $scope.displayOR = false;
		// }
		// else
		// 	$scope.displayOR = true;

		if($state.params.page!=null && $state.params.page!=undefined && $state.params.page.indexOf('providerSearch')!=-1){
		//if($state.current.name == 'contentPage' && $state.params.page == 'providerSearch'){
				$scope.displayOR = true;
		}
		else
			 $scope.displayOR = false;


		// if($sessionStorage.PSfeatures != undefined){
		// 	for(var i=0;i<$sessionStorage.PSfeatures.length;i++){
		// 		if($sessionStorage.PSfeatures[i].featureName=="providerSearchSpanish"){
		// 			if($sessionStorage.PSfeatures[i].featureEvaluatedResult=='true') {
		// 				$scope.spanishContent=true;
		// 			} else {
		// 				$scope.spanishContent=false;
		// 			}
		// 		}
		// 	}
		// }
		// else { // features service not done yet
		// 	//ProviderSearchCriteriaService.callFeaturesAPI();
		// 	if($scope.criteria.featurePromise!=undefined && $scope.criteria.featurePromise!=null)
		// 	{
		// 		$scope.criteria.featurePromise.then (
		// 		   function success(response) {
		// 				// we can assume it is now in session
		// 				for(var i=0;i<$sessionStorage.PSfeatures.length;i++){
		// 					if($sessionStorage.PSfeatures[i].featureName=="providerSearchSpanish"){
		// 						if($sessionStorage.PSfeatures[i].featureEvaluatedResult=='true') {
		// 							$scope.spanishContent=true;
		// 						} else {
		// 							$scope.spanishContent=false;
		// 						}
		// 					}
		// 				}
		//
		// 			}, function error(response) {
		// 				// error
		// 			});
		// 	}
		//
		// } // test for feature service done


		// what to do if user clicks on Change Location



		$scope.startanewSearch= function()
		{

						var lang = $translate.use();
						$scope.criteria.searchFocus = false;
						$scope.criteria.isResetFilter = false;
						$scope.criteria.filterOrder = '';
						$scope.criteria.checkedItem = [];
						$scope.criteria.checkedItemChildren = [];
						$scope.criteria.showFilterContent=[];
						$scope.criteria.showSecLevelContent=[];
						$scope.criteria.listSelections = null;
						$scope.criteria.direction = '';
						$scope.criteria.order = '';
						$scope.criteria.isAlphaSort = false;
						$scope.criteria.selectedFilters = '';
						$scope.criteria.selectedListArray = [];
						$scope.criteria.typeAheadSearch = '';
						var siteId = $scope.criteria.siteId;
						var language = $scope.criteria.language;
						ProviderResultsService.setHospitalId('');
						ProviderResultsService.setIpaDetails('');
				 		$scope.criteria.ipaName = '';
				 		$rootScope.grpName = '';
						$state.go('contentPage',{page:'providerSearch',parameters:'',site_id:siteId,language:language});
		};
		$scope.disableText=true;
		$scope.changeLocationClick = function() {
			var index;
			var year = $scope.criteria.medicare.planYear;
			var category = $scope.criteria.medicare.category;
			if($state.params.page=="providerSearchPlanList" && $state.params.site_id=="medicare"
				&& $scope.criteria.medicare != undefined)
			{
				if(year && category)
				{
					$scope.criteria.medicare.fixedPlanName = "";
					$scope.criteria.medicare.medOrDen = -1;
					$scope.criteria.planProductCode = "";
					$scope.criteria.medicare.planTypeaHeadLocation = '';
					$state.go('contentPage',{"page":'providerSearchLanding',site_id:siteId,language:lang,year:year,category:category});
				}
			}
			else
			{
				$scope.changeLocationPlanPageFlag=true;
				$scope.changeLocationFlag=true;
				//Open if the popover is close and close if the popover is open.
				isLocationboxClicked = false;//change1
				$scope.criteria.duplicatetypeAheadLocation = $scope.criteria.typeaheadLocation;//change1

				AnalyticsService.trackView('provider search change location', 2);
				$scope.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;

				if ( $sessionStorage.criteria )
				{
					$sessionStorage.criteria.typeaheadLocation = $scope.criteria.typeAheadLocationResults.label;
				}
				ctrl.isChangeLocation = !ctrl.isChangeLocation;
				$scope.disableText=false;
				//$scope.criteria.typeaheadLocation = "";
				justSelectedLocationFlag=false;
				// if(ProviderSearchCriteriaService.getDistance()){
				// 	$scope.slider.value = ProviderSearchCriteriaService.getDistance();
				// }
				// else{
				// 	$scope.slider.value = sliderValue;
				// }
				$scope.slider.value = ($scope.criteria.distance === 0 || $scope.criteria.distance) ? $scope.criteria.distance : sliderValue;
				$scope.criteria.direction = '';
				$timeout(function () {
					$scope.$broadcast('rzSliderForceRender');
				});
				angular.element("#changeLocation" ).show();
				angular.element("#changeLocation" ).css("display","block");
				angular.element("#changeLocation" ).addClass("fadeIn");
				angular.element("#changeLocation" ).removeClass("fade");
				angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
				$scope.criteria.duplicatetypeAheadLocation = $scope.criteria.typeaheadLocation;//change 1
				setTimeout(function(){ $rootScope.focusForModal('changeLocation'); }, 100);
		}

		};

				$scope.init = function(){
					if(!isLocationboxClicked){
					  $scope.criteria.duplicatetypeAheadLocation = $scope.criteria.typeaheadLocation;
					  $scope.criteria.typeaheadLocation = '';
					}
					isLocationboxClicked = true;
				}

		/* $scope.showChangeMemberPlanPopUp=function(){
				angular.element("#changeMemberPlan" ).show();
				angular.element("#changeMemberPlan" ).css("display","block");
				angular.element("#changeMemberPlan" ).addClass("fadeIn");
				angular.element("#changeMemberPlan" ).removeClass("fade");
				angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
			};
 		*/

		$scope.slider = {
			value: sliderValue,
			options: {
				floor: 0,
				ceil: 100,
				step: 1,
				showSelectionBar: true,
				disabled: $scope.criteria.isSliderEnable,
				translate: function(value) {
					return value + ' ' + ($scope.criteria.language == 'en' ? 'Miles' : 'Millas');
				}
			}
		};

		if((window.location.href.indexOf("providerResults") == -1 &&
		window.location.href.indexOf("providerDetails") == -1 &&
		window.location.href.indexOf("providerHospDetails") == -1 &&
		 window.location.href.indexOf("providerOrgDetails") == -1)){
			$scope.criteria.page=1;
		}
		$scope.criteria.useCurrentLocation = false;
		
		//ProviderSearchCriteriaService.criteria.isGuidedSearch = true;
		// toggle language between English and Spanish or use specified language
		$scope.changeLanguage = function(lang) {
			if (lang == null || lang == undefined) {
				var lang = $translate.use();
				lang = lang == 'en' ? 'es' : 'en';
				$scope.criteria.lang = lang;
			}
			// start over on the search page when switching languages

			$state.go('contentPage',{page:'providerSearch',site_id:siteId,language:language});
		};



		// ------------------------- mobile checkbox for location ------------------------------------
		// indicate if we can get the user's current location
		currentLocationAllowed = "unknown";  // yes, no, unknown, getting
		$scope.currentLocationAvailable = function() {
			if(CommonUtilsService.identifyMobileDevices()){
				// see if we already know if we can get current location
				if (currentLocationAllowed === "yes") {
							return true;
				} else if (currentLocationAllowed === "no") {
							return false;
				} else if (currentLocationAllowed === "getting") {
							return false;
				} else if (!navigator.geolocation) {
				    	// browser does not support location
							currentLocationAllowed = "no";
							return false;
			  }

			  // Attempt to get the current location
				currentLocationAllowed = "getting";

				// callback functions from location API
				function gotPosition(position) {
											// see if accuracy is good enough
											if (position.coords.accuracy > 1000) {
												currentLocationAllowed = "no";
											} else {
												currentLocationAllowed = "yes";
											}
											// debug turn on current location always
											// $scope.currentLocationAllowed = "yes";

											// angularJS did not call this functions, so we need to tell it that it was called
											// so it can update any view changes.
											// angular.element(document.getElementById('providerSearch')).scope().$apply();
				}
				function gotError(error) {
											currentLocationAllowed = "no";
												// Below code is for debugging purpose
												/*switch(error.code) {
						 				        case error.PERMISSION_DENIED:
													if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
														|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
														|| navigator.userAgent.match(/Windows Phone/i)){
															alert("Development in progress - 4) Inside gotError() : User denied the request for Geolocation.");
															alert(error.code);
													}
						 				            break;
						 				        case error.POSITION_UNAVAILABLE:
													if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
														|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
														|| navigator.userAgent.match(/Windows Phone/i)){
															alert("Development in progress - 4) Inside gotError() : Location information is unavailable.");
															alert(error.code);
													}
						 				            break;
						 				        case error.TIMEOUT:
													if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
															|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
															|| navigator.userAgent.match(/Windows Phone/i)){
																alert("Development in progress - 4) Inside gotError() : The request to get user location timed out.");
																alert(error.code);
													}
						 				            break;
						 				        case error.UNKNOWN_ERROR:
													if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
															|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
															|| navigator.userAgent.match(/Windows Phone/i)){
																alert("Development in progress - 4) Inside gotError() : An unknown error occurred.");
																alert(error.code);
													}
						 				            break;
												}*/
				}
				var geoProperties = {
								enableHighAccuracy: true
				}
				navigator.geolocation.getCurrentPosition(gotPosition,gotError,geoProperties);
			}
			// not allowed to use current location yet
			return false;
		};

		// this function is called when user clicks checkbox
		$scope.useCurrentLocation = function() {
				$scope.criteria.useCurrentLocation = !$scope.criteria.useCurrentLocation;

				if($scope.criteria.useCurrentLocation  == true){
					function gotPosition(position) {
						// ok to use current location
						$scope.criteria.useCurrentLocation = true;
						$scope.criteria.position = position;
						$scope.criteria.typeaheadLocation = '';  // blank out location box
						$scope.slider.options.disabled = false;
												// Below code is for debugging purpose
												// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
												// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
												// || navigator.userAgent.match(/Windows Phone/i)
												// ){
												// 					alert("position.coords.latitude == ");
												// 					alert(position.coords.latitude);
												// 					alert("fddfd position.coords.longitude == ");
												// 					alert(position.coords.longitude);
												//  }
						// call reverse geo service to get the state from the current location
						// ProviderSearchCriteriaService.getReverseGeoInfo(position.coords.latitude,position.coords.longitude);
						// alert('Calling mapsService.getGeoState');
						mapsService.getGeoState(position.coords.latitude, position.coords.longitude);


						            $scope.criteria.typeAheadLocationClicked = null;
						            var item = {};  // create item from current location
						            item.label = $scope.criteria.text.currentLocation;  // translated message
						            item.category = "location";
						            item.subcategory = "coordinates";
						            item.coordinates = "" + position.coords.latitude + "," + position.coords.longitude;
						            item.stateabbr = $scope.criteria.position.state;
						            $scope.criteria.typeAheadLocationResults = item;

						            if ( $sessionStorage.criteria )
						            {
						            	$sessionStorage.criteria.typeAheadLocationResults = item;
						            }

						$timeout(0);


						// angularJS did not call this functions, so we need to tell it that it was called
						// so it can update any view changes.		
						// angular.element(document.getElementById('useCurrentLocation')).scope().$apply();

						// angular.element(document.getElementById('useCurrentLocation')).injector().get('$rootScope').$root.$eval();
					}

						function gotError(error) {
							$scope.criteria.position = null;
							$scope.slider.options.disabled = false;
													// Below code is for debugging purpose
													/*switch(error.code) {
														case error.PERMISSION_DENIED:
																		// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
																		// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
																		// || navigator.userAgent.match(/Windows Phone/i)
																		// ){
																		// 					alert("Development in progress - 4) Inside gotError() : User denied the request for Geolocation.");
																		// 					alert(error.code);
																		//  }
																break;
														case error.POSITION_UNAVAILABLE:
																		// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
																		// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
																		// || navigator.userAgent.match(/Windows Phone/i)
																		// ){
																		// 					alert("Development in progress - 4) Inside gotError() : Location information is unavailable.");
																		// 					alert(error.code);
																		//  }
																break;
														case error.TIMEOUT:
																		// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
																		// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
																		// || navigator.userAgent.match(/Windows Phone/i)
																		// ){
																		// 					alert("Development in progress - 4) Inside gotError() : The request to get user location timed out.");
																		// 					alert(error.code);
																		//  }
																break;
														case error.UNKNOWN_ERROR:
																		// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
																		// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
																		// || navigator.userAgent.match(/Windows Phone/i)
																		// ){
																		// 					alert("Development in progress - 4) Inside gotError() : An unknown error occurred.");
																		// 					alert(error.code);
																		//  }
																break;
												}*/
						}
						var geoProperties = {
							enableHighAccuracy: true
						}
						// only do something if user checks the box - ignore for uncheck
						if ($scope.criteria.useCurrentLocation) {
							// assume we don't get the location
							$scope.criteria.useCurrentLocation = false;
							// double-check we are allowed to get current location
							if (!$scope.currentLocationAvailable()) {
								return;
							}
							// try and get current location - a callback may be called
							navigator.geolocation.getCurrentPosition(gotPosition,gotError,geoProperties);
						}
				}
		};
		// ------------------------- mobile checkbox for location ------------------------------------

				var changeLocationPopover = {
					templateUrl: 'changeLocation.html'
				};

				$scope.showAllItems = function(group, count) {
					return ProviderSearchCriteriaService.showAllItems(group, count);
				};

				$scope.clickViewMore = function(group, limit) {
					return ProviderSearchCriteriaService.clickViewMore(group, limit);
				};

				$rootScope.closeSpinner=function(){
					CommonUtilsService.closeSpinner();
				}

				$rootScope.returnFocusToLink=function(id,flag1){
					if(!(flag1 && (window.location.href.indexOf("providerResults") != -1 ||
					window.location.href.indexOf("providerDetails") != -1 ||
					window.location.href.indexOf("providerHospDetails") != -1 ||
					 window.location.href.indexOf("providerOrgDetails") != -1))){
						$('#'+id).focus();
					}
				}

	$rootScope.isCurrentStateResults = function(){
		 if($state.current.name == 'providerResults'){
			 return true;
		 }
		 else if($state.current.name == 'contentPage' && $state.params.page == 'providerResults'){
			 return true;
		 }
		 return false;
	 };
$rootScope.focusForModal=function(idModal){
	var inputs = $('#'+idModal).find('select, input, textarea, button, a, iframe, .forFirstFocus').filter(':visible');
                var firstInput = inputs.first();
                var lastInput = inputs.last();
                firstInput.focus();
                lastInput.on('keydown', function (e) {
                    if ((e.which === 9 && !e.shiftKey) ) {
                        e.preventDefault();
                        firstInput.focus();
                    }

                });
                firstInput.on('keydown', function (e) {
                    if ((e.which === 9 && e.shiftKey) ) {
                        e.preventDefault();
                        lastInput.focus();
                    }

                });
            $(".iframeFocus").on('keydown', function (e) {
                    if ((e.which === 9 && !e.shiftKey) ) {
                        e.preventDefault();
                        firstInput.focus();
                    }
                });
}
 	 $scope.isCurrentStatePlan = function(){
 		 //if($state.current.name == 'planSelect'){
		 if($state.current.name == 'contentPage' && $state.params.page == 'providerSearchPlanList'){
			 return true;
		 }
 		 return false;
 	 };


		// called when the search box goes into focus
		$scope.searchFocus = function() {
			$scope.criteria.searchFocus = true;

			// cause the type-ahead list to be redisplayed
	        var e = document.getElementById("Doctors");
	        var ae = angular.element(e);
	        //ae.triggerHandler('focus');
	        ae.triggerHandler('input');

	        // iPhones don't display correctly and the search bar is not on top.  Wait a bit and then
	        // force it to be on top
			if ($window.innerWidth < 992) {  // on cell phone and tabs
				// function scroll() {
				// 	var id = 'Doctors';
				// 	var scrollHere = document.getElementById(id);
				// 	scrollHere.scrollIntoView();
				// }
				// setTimeout(scroll, 1000); // wait a bit for screen to settle
				setTimeout(function(){
					$('html,body').animate({
						 scrollTop: $("#Doctors").offset().top},
						 'slow');
						//$("#Doctors").focus();
				 }, 1000);
			}
		}

		// called when the search box goes out of focus
		$scope.searchBlur = function() {
					// if type-ahead is open, we don't do anything.
					// look for items with class typeahead_grouping
					var numResults = document.getElementsByClassName("typeahead_grouping").length;
					if (numResults > 0) {
						return;
					}

					//$scope.criteria.searchFocus = false;
					// if on a cell phone, clear the search text
					if ($window.innerWidth < 992) {
						$scope.criteria.typeAheadSearch = '';
						$scope.criteria.searchFocus = false;
					}
			
			document.getElementById("popclose-search").focus();
		}

		// called to determine if we should dim the display on mobile device
		$scope.searchDim = function() {
				if ($window.innerWidth < 992 && window.location.href.indexOf("providerSearchPlanList") === -1) {
					if ($scope.criteria.searchFocus || $scope.criteria.typeAheadSearch) {
						angular.element("#emptyModal" ).show();
						angular.element("#emptyModal" ).css("display","block");
						angular.element("#emptyModal" ).addClass("modal-backdrop fade in");
						angular.element("#emptyModal" ).css("z-index",1000);
						return true;
					}
				}
				return false;
		}

		$scope.getAlphaNumericLength = function(val) {
			return val.toString().replace(/[^0-9a-z]/gi, '').length;
		};

		// called when a search term is selected from type-ahead
		$scope.setTypeAheadForSearch = function(item,evt)
		{
			if (evt!=null && evt!=undefined && evt.keyCode === 9) {  // tab key
	        	return;
	        } else {
	        }
			ProviderSearchCriteriaService.setTypeAheadForSearch(item);
			$scope.criteria.isGuidedSearch = false;
			$scope.criteria.isProviderForGroup = false;
			/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
			$scope.criteria.isProviderForIPA = false;
		//	$scope.criteria.isGuidedSearch = false;
			/*  If we are already on the results page,upding this variable will
			 * tell the provider results controller (look for a watch function in that controller on this variable - resultSearch)
			 * to update the provider  results.
			 */
			//console.log("item"+JSON.stringify(item));

			if (window.location.href.indexOf("providerResults") != -1)
				{
					ProviderResultsService.resultSearch  = ProviderResultsService.resultSearch + 1;
				}
			else
			{

				$state.go('contentPage',{page:'providerResults',site_id:siteId,language:language});//,parameters:params});
			}
		};

		// called when guided flow is clicked
		$scope.setTypeAheadForSearchGuidedFlow = function(searchText, searchTextForTalix)
		{
			$scope.criteria.isGuidedSearch = true;
			if(searchTextForTalix != null && searchTextForTalix != undefined){
				$scope.criteria.searchTextToDisplay = searchText;
				$scope.criteria.searchText = searchTextForTalix;
				
				 /* IOQ changes : If searchTextForBackEnd is blank the searchText filed 
				  * will be used for the results service */
				$scope.criteria.searchTextForBackEnd = '';
			}
			else{
				$scope.criteria.searchTextToDisplay = '';
				$scope.criteria.searchText = searchText;
				

				 /* IOQ changes : If searchTextForBackEnd is blank the searchText filed 
				  * will be used for the results service */
				$scope.criteria.searchTextForBackEnd = '';
			}

			$state.go('contentPage',{page:'providerResults',site_id:siteId,language:language});
		}

		// called when guided flow is clicked
		$scope.goToChangePlan = function()
		{
			//$state.go('planSelect');//,parameters:params});
			//$state.go('contentPage',{page:'providerSearchPlanList'});
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;

			$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language});
		}

		$scope.doOpenTextSearch = function() {
			return !$scope.criteria.typeAheadSwitch && $scope.criteria.typeAheadSearch.length >= 3;
		};

		// called when doing a search without type-ahead
		$scope.openTextSearch = function() {
			$scope.criteria.isGuidedSearch = false;
			$scope.criteria.searchText = $scope.criteria.typeAheadSearch;

			$scope.criteria.searchTextForBackEnd = '';
			
			$scope.criteria.isProviderForGroup = false;
			/*$scope.criteria.isAssociatedProvidersSearchForGroup = false;*/
			$scope.criteria.isProviderForIPA = false;
			/*  If we are already on the results page,upding this variable will
			 * tell the provider results controller (look for a watch function in that controller on this variable - resultSearch)
			 * to update the provider  results.
			 */
			if (window.location.href.indexOf("providerResults") != -1)
				{
					ProviderResultsService.resultSearch  = ProviderResultsService.resultSearch + 1;
				}
			else
			{
				//var params = window.encodeURIComponent("searchText='Neha Sancheti';isGuidedSearch='true'");

				$state.go('contentPage',{page:'providerResults',site_id:siteId,language:language});//,parameters:params});
			}

		};

		// a flag which indicates if the user just selected a location.  It will be set when the user selects
		// a location and reset when the user does something that activates type-ahead again.
		var justSelectedLocationFlag = false;
		this.disableLocationJustSelected = function() {
			$scope.disableText=true;
			justSelectedLocationFlag = false;
			$scope.slider.options.disabled = false;
		}

		$scope.setTypeAheadForLocation = function(item)
		{
			ProviderSearchCriteriaService.setTypeAheadForLocation(item);
			// We disable the slider for county or state searches, since they do not use distance
			$scope.slider.options.disabled = item.subcategory === 'county' || item.subcategory === 'state';
			$rootScope.$broadcast('rzSliderForceRender');
			justSelectedLocationFlag = true;
		};


		var activeItemLocation;

		// This function determines if we need to disable the accept location button
		this.disableLocationButton = function()
		{
			// always enable button if using current location (GPS)
			if ($scope.criteria.useCurrentLocation) {
				return false;
			}

			// see if anything has been selected on type-ahead
			var selected = ($('#active').val());

			// enable button if user has just selected something from the location type-ahead
			if (justSelectedLocationFlag) {
				return false;
			}

			if($scope.criteria.typeaheadLocation==""){
				return true;
			}

			//disable if zipcode is incomplete
			if(!isNaN($scope.criteria.typeaheadLocation) && $scope.criteria.typeaheadLocation.length != 5 ){
				return true;
			}
			
			//disable if valid zipcode but junk characters after the zip
			if(!isNaN($scope.criteria.typeaheadLocation.substring(0,5)) && isNaN($scope.criteria.typeaheadLocation.substring(5))){
				return true;
			}
			
			if($scope.criteria.typeaheadLocation!=undefined && $scope.criteria.typeaheadLocation!="" && ($scope.criteria.typeaheadLocation == $scope.criteria.typeAheadLocationResults.label)){
				return false;
			}

			// enable button if something was selected
			if (angular.isDefined(selected)) {

						var obj1=$('#active').val();
						if(angular.isString(obj1)){
							obj1=JSON.parse(obj1);
						}
						if(obj1!='' && angular.isDefined(obj1)){
							activeItemLocation = obj1;
						}

						return false;
			}



			// disable the button
			return true;
		};

		function executePlanPrefillFlow(){
			decodeEncodedCharacters($location.search().planValue);
			fetchAndSetPlan();
		}

		function decodeEncodedCharacters(productPlanName){
			if(productPlanName != undefined && productPlanName != ""){
				productPlanName = productPlanName.replace(/\+/gi, " ");
				productPlanName = productPlanName.replace(/%20/gi, " ");
				productPlanName = productPlanName.replace(/%3a/gi, ":");
				productPlanName = productPlanName.replace(/%24/gi, "$");
				productPlanName = productPlanName.replace(/%25/gi, "%");
				productPlanName = productPlanName.replace(/%26/gi, "&");
				productPlanName = productPlanName.replace(/%28/gi, "(");
				productPlanName = productPlanName.replace(/%29/gi, ")");
				productPlanName = productPlanName.replace(/%7c/gi, "|");
				productPlanName = productPlanName.replace(/%2b/gi, "+");
				productPlanName = productPlanName.replace(/_/gi, " ");
			}
			$scope.criteria.planValFromURL = productPlanName;
		}

		function prefillPlanValue(selectedPlan, planId){
			ProviderSearchCriteriaService.setPlanProductCode(selectedPlan.productCode);
			ProviderSearchCriteriaService.setPlanName(selectedPlan.displayName);
			$scope.criteria.dummyPlanCode = planId;
			$scope.checkedPlanCode = planId;
			$scope.criteria.planName = selectedPlan.displayName;
			$scope.criteria.planPipeName= selectedPlan.pipeName;
			$scope.criteria.planProductCode = selectedPlan.productCode;
			redirectURLSingle = selectedPlan.link.redirectUrl;
			externalURLSingle = selectedPlan.link.externalUrl;

			if ($scope.languageData.SWITCH_PLANNAME_LANDING == 'ON' && $location.search().planValue) {
					$("<p id='planLanding' class='mar0'><span></span><span id='planSpan' ng-bind-html='criteria.planName'></span></p>").insertBefore( ".My_Coverage.stayHealthy" );
					$("#planLanding span").first().text($scope.languageData.SEARCHBY_PLAN_LABEL+" ");
					$compile($("#planSpan"))($scope);
			}else{
					if($scope.redirectURL != null && $scope.redirectURL != ''){
						if($scope.externalURL != null && $scope.externalURL === 'YES'){
							showDisclaimer($scope.redirectURL);
							//showDisclaimer($scope.redirectURL,'standard',null)
						}
						else{
							$window.open($scope.redirectURL, "_blank");
							//ProviderResultsService.openURL($scope.redirectURL);
						}
					}

					$state.go('contentPage',{page:'providerSearch',site_id:siteId,language:language});
					//$sessionStorage.criteria  = $scope.criteria;
					}
		}

		function fetchAndSetPlan() {
			NavSpinnerService.spin();
			PlanListService.getPlanList()
			.then(
					function success(response){
						var planFound = false;
						var listInfoExchange=response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;
						if(!angular.isArray(listInfoExchange))
							listInfoExchange = [listInfoExchange];

						for(var i=0;i<listInfoExchange.length;i++){
							if( listInfoExchange[0].name != undefined && listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i]=='ShowAllPlansLink'){ // for prod
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}else if( listInfoExchange[0].name != undefined && listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i].$=='ShowAllPlansLink'){ // for qa
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}
							else if(listInfoExchange[0].name != undefined && listInfoExchange[0].name == 'ShowAllPlansLink'){ /* for new correct structure*/
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
								break;
							}
							else{
								ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
							}
						}
						$scope.planList = response.data.DocfindSearchPlanList.plans;
						var planArrList = PlanListService.setPlansArr($scope.planList);
						$scope.planCriteria.planArray = planArrList;
						var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

						if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
							processDebugInfo = processDebugInfo.values.value;
						}else{
							for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
								if(processDebugInfo[tempI].name == "DiagnosticInfo"){
									processDebugInfo = processDebugInfo[tempI].values.value;
									break;
								}
							}
						}
						$scope.planCriteria.planDebugInfo = processDebugInfo;

						$scope.listOfPlans = planArrList;
						for (var i=0; i<$scope.planList.headerName.length; i++) {
							for (var j=0; j<$scope.planList.headerName[i].plan.length; j++) {
								if($scope.planList.headerName[i].plan[j].productCode + '|' + $scope.planList.headerName[i].plan[j].pipeName == $scope.criteria.planValFromURL){
									planFound = true;
									prefillPlanValue($scope.planList.headerName[i].plan[j], $scope.planList.headerName[i].plan[j].productCode+"_"+$scope.planList.headerName[i].plan[j].pipeName);
									break;
								}
							}
							if(planFound){
								break;
							}
							for (var l=0; l<$scope.planList.headerName[i].subHeaderName.length; l++) {
								for (var m=0; m<$scope.planList.headerName[i].subHeaderName[l].plan.length; m++) {
									if($scope.planList.headerName[i].subHeaderName[l].plan[m].productCode + '|' + $scope.planList.headerName[i].subHeaderName[l].plan[m].pipeName == $scope.criteria.planValFromURL){
										planFound = true;
										prefillPlanValue($scope.planList.headerName[i].subHeaderName[l].plan[m], $scope.planList.headerName[i].subHeaderName[l].plan[m].productCode+"_"+$scope.planList.headerName[i].subHeaderName[l].plan[m].pipeName);
										break;
									}
								}
								if(planFound){
									break;
								}
							}
						}
						NavSpinnerService.stop();

						if(!planFound){
							$scope.criteria.planValFromURL = '';
							//$state.go('contentPage',{page:'providerSearchPlanList'});
							var siteId = $scope.criteria.siteId;
							var language = $scope.criteria.language;
							if ($scope.languageData.SWITCH_PLANNAME_LANDING == 'OFF') {
								$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language});
							}else if ($scope.languageData.SWITCH_PLANNAME_LANDING == 'ON') {
								// $("<p id='planLanding' class='mar0'><span></span></p>").insertBefore( ".My_Coverage.stayHealthy" );
								// $("#planLanding span").text($scope.languageData.SEARCHBY_PLAN_LABEL);

								var leavingUrl = $state.href('disclaimerPage', {page: 'leavingPage',site_id:siteId,language:language});
								window.open(leavingUrl,"_self");
							}
						}
					},
					function error(response){
						console.log("Error in fetching Plans :  ");
						console.log(response);
						NavSpinnerService.stop();
						$scope.criteria.planValFromURL = '';
						$scope.planCriteria.planArray = 'ERROR';
						$scope.planCriteria.planDebugInfo = [];
						//$state.go('contentPage',{page:'providerSearchPlanList'});
						var siteId = $scope.criteria.siteId;
						var language = $scope.criteria.language;

						if ($scope.languageData.SWITCH_PLANNAME_LANDING == 'OFF') {
							$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language});
						}
					}
			);
		};


		this.continueGo = function () {
			// $scope.criteria.dummyPlanCode = '';
			// $scope.criteria.planName = '';
			// $scope.criteria.planProductCode = '';
			// $scope.listOfPlans = '';
			this.acceptChangeLocation();

			if(activeItemLocation != null){
				// ACNLA5_1201_MS - Changes start
				if($scope.criteria.typeaheadLocation != null) 
					activeItemLocation = $scope.criteria.typeaheadLocation;
				// ACNLA5_1201_MS - Changes end
				$scope.setTypeAheadForLocation(activeItemLocation);
				this.acceptChangeLocation(activeItemLocation);
			}else{
				this.acceptChangeLocation();
			}

			$scope.criteria.memberPleat = memberPleat;
			$scope.criteria.geoPleat = geoPleat;

			$scope.criteria.fromGeo = true;
			ProviderSearchCriteriaService.setFromGeo(true);
			$sessionStorage.criteria  = $scope.criteria;
			var currentPage = $location.search().page;
			var siteId = $scope.criteria.siteId;
			var language = $scope.criteria.language;

			if((currentPage == "providerSearchGeo" || currentPage == "providerSearchLanding") && $location.search().planValue){
					if($scope.languageData.SWITCH_PLANNAME_LANDING == 'OFF'){
							$scope.criteria.dummyPlanCode = '';
							$scope.criteria.planName = '';
							$scope.criteria.planProductCode = '';
							$scope.listOfPlans = '';
							$scope.criteria.planValue = $location.search().planValue;
							executePlanPrefillFlow();
					}else if($scope.languageData.SWITCH_PLANNAME_LANDING == 'ON'){
							if($scope.redirectURL != null && $scope.redirectURL != ''){
								if($scope.externalURL != null && $scope.externalURL === 'YES'){
									showDisclaimer($scope.redirectURL);
									//showDisclaimer($scope.redirectURL,'standard',null)
								}
								else{
									$window.open($scope.redirectURL, "_blank");
									//ProviderResultsService.openURL($scope.redirectURL);
								}
							}

							$state.go('contentPage',{page:'providerSearch',site_id:siteId,language:language});
							//$sessionStorage.criteria  = $scope.criteria;
					}
			}else{
					$scope.criteria.dummyPlanCode = '';
					$scope.criteria.planName = '';
					$scope.criteria.planProductCode = '';
					$scope.listOfPlans = '';

					NavSpinnerService.spin();
					PlanListService.getPlanList()
					.then(
							function success(response){
								var planFound = false;
								// ProviderSearchCriteriaService.setPlanResponse(response); Removed from Criteria

								$scope.planList = response.data.DocfindSearchPlanList.plans;
								var planList = response.data.DocfindSearchPlanList.plans;
								var planArrList = PlanListService.setPlansArr(planList);
								$scope.planCriteria.planArray = planArrList;

								var processDebugInfo = response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;

								if(processDebugInfo.length == undefined && processDebugInfo.values != undefined && processDebugInfo.values.value != undefined){
									processDebugInfo = processDebugInfo.values.value;
								}else{
									for(var tempI = 0; tempI < processDebugInfo.length; tempI++){
										if(processDebugInfo[tempI].name == "DiagnosticInfo"){
											processDebugInfo = processDebugInfo[tempI].values.value;
											break;
										}
									}
								}
								$scope.planCriteria.planDebugInfo = processDebugInfo;

								if(planArrList.length > 1){
									$scope.criteria.isSinglePlan = false;
									ProviderSearchCriteriaService.setIsSinglePlan(false);
								}else{
									$scope.criteria.isSinglePlan = true;
 									ProviderSearchCriteriaService.setIsSinglePlan(true);
								}

								var listInfoExchange=response.data.DocfindSearchPlanList.listInfoExchanges.listInfoExchange;
								if(!angular.isArray(listInfoExchange))
									listInfoExchange = [listInfoExchange];

								for(var i=0;i<listInfoExchange.length;i++){
									if(listInfoExchange[0].name != undefined  && listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i]=='ShowAllPlansLink'){ // for prod
										ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
										break;
									}
									else if( listInfoExchange[0].name != undefined  &&  listInfoExchange[0].name[i] != undefined && listInfoExchange[0].name[i].$=='ShowAllPlansLink'){ // for qa
										ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
										break;
									}
									else if( listInfoExchange[0].name != undefined && listInfoExchange[0].name == 'ShowAllPlansLink'){ /* for new correct structure*/
										ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = true;
										break;
									}
									else{
										ProviderSearchCriteriaService.getCriteria().switchToShowAllPlanLink = false;
									}
								}

								if($scope.criteria.isSinglePlan && $scope.planList.headerName != undefined){
										for (var i=0; i<$scope.planList.headerName.length; i++) {
											for (var j=0; j<$scope.planList.headerName[i].plan.length; j++) {
												if($scope.planList.headerName[i].plan[j].productCode){
													planFound = true;
													prefillPlanValue($scope.planList.headerName[i].plan[j], $scope.planList.headerName[i].plan[j].productCode+"_"+$scope.planList.headerName[i].plan[j].pipeName);
													break;
												}
											}
											if(planFound){
												break;
											}
											for (var l=0; l<$scope.planList.headerName[i].subHeaderName.length; l++) {
												for (var m=0; m<$scope.planList.headerName[i].subHeaderName[l].plan.length; m++) {
													if($scope.planList.headerName[i].subHeaderName[l].plan[m].productCode){
														planFound = true;
														prefillPlanValue($scope.planList.headerName[i].subHeaderName[l].plan[m], $scope.planList.headerName[i].subHeaderName[l].plan[m].productCode+"_"+$scope.planList.headerName[i].subHeaderName[l].plan[m].pipeName);
														break;
													}
												}
												if(planFound){
													break;
												}
											}
										}

								}
								else{

										$state.go('contentPage',{page:'providerSearchPlanList',site_id:siteId,language:language});
								}

								NavSpinnerService.stop();
							},
							function error(response){
								console.log("Error in fetching Plans :  ");
								console.log(response);
								NavSpinnerService.stop();
								$scope.planCriteria.planArray = 'ERROR';
								$scope.planCriteria.planDebugInfo = [];
								$scope.criteria.planValFromURL = '';
								//$state.go('contentPage',{page:'providerSearchPlanList'});
								var siteId = $scope.criteria.siteId;
								var language = $scope.criteria.language;

								$state.go('contentPage',{page:'providerSearchPlanList',siteId:siteId,language:language});
							}
					);

			}
		};

		$(".focusForIE").hover(function(){
		    $(this).children(".search-block-description").css("background-color", "#eeeeee");
		    }, function(){
		    $(".search-block-description").css("background-color", "#ffffff");
		});

		

		this.updateMyView = function () {
			$scope.changeLocationPlanPageFlag=false;
			$scope.changeLocationFlag=false;

			if (window.location.href.indexOf("providerResults") != -1){
					// Code for reseting alphasort and filters <starts>
					$(".datGridSort").removeClass("dataGridSortOnReset");
					ProviderSearchCriteriaService.setFirstRecordOnPage('');
					ProviderSearchCriteriaService.setLastRecordOnPage('');
					$scope.criteria.page = 1;
					$scope.criteria.statusBeg = true;
					$scope.criteria.statusLast = false;
					$scope.criteria.isAlphaSort = false;
					$sessionStorage.criteria.isAlphaSort = false;
					var tempoArray = [];
					var listSelections=encodeURIComponent('['+tempoArray.join(',')+']');
					ProviderSearchCriteriaService.setListSelection(listSelections);
					$sessionStorage.criteria.listSelections = listSelections;
					// Code for reseting alphasort and filters <ends>
			}


			$('.filterOptions').hide();
			$sessionStorage.criteria  = $scope.criteria;
			this.acceptChangeLocation();
		};

		this.acceptChangeLocation = function(item)
		{
			ctrl.crossHide=false;
			ctrl.cancelHide=false;
			ctrl.showRestrictedMessage=false;
			$rootScope.$on('$destroy', 'openLocationPopUp');
			var obj1=$('#active').val();
			if(angular.isString(obj1)){
				obj1=JSON.parse(obj1);
			}
			if(obj1!='' && angular.isDefined(obj1)){
				$scope.setTypeAheadForLocation(obj1);
				this.updateLocation();
			}
			else{
				this.updateLocation();
			}

			//if($state.current.name == 'planSelect'){
			if($state.current.name == 'contentPage' && $state.params.page == 'providerSearchPlanList'){
				$rootScope.reloadFetchPlans();
			}
			angular.element("#changeLocation" ).hide();
			angular.element("#changeLocation" ).addClass("fade");
			angular.element("#changeLocation" ).removeClass("fadeIn");
			angular.element(".modal-backdrop" ).css("display","none");
		};

		this.updateLocation = function(){
			$scope.criteria.maskZip= false;
			ProviderSearchCriteriaService.acceptChangeLocation();
			ProviderSearchCriteriaService.setDistance($scope.slider.value);
			ctrl.isChangeLocation = false;
			$scope.criteria.isSliderEnable = $scope.slider.options.disabled;
			// $scope.slider.options.disabled = false;  // always disable slider for next search
			isLocationboxClicked = false;
			if (window.location.href.indexOf("providerResults") != -1)
			{
				ProviderResultsService.resultSearch  = ProviderResultsService.resultSearch + 1;
			}
			if (window.location.href.indexOf("providerDetails") != -1 || window.location.href.indexOf("providerHospDetails") != -1 || window.location.href.indexOf("providerOrgDetails") != -1)
			{

				$state.go('contentPage',{page:'providerResults',parameters:'',site_id:siteId,language:language});
				ProviderResultsService.resultSearch  = ProviderResultsService.resultSearch + 1;
			}

      var aZip = $scope.zipCode;
      var subcategory;
      var geo;
      if ($scope.criteria && $scope.criteria.typeAheadLocationResults)
      {
    	  if(  $scope.criteria.typeAheadLocationResults.zipcode != undefined)
    	  {
    		  aZip = $scope.criteria.typeAheadLocationResults.zipcode;
    	  }
    	  if(  $scope.criteria.typeAheadLocationResults.label  )
          {
    		  geo = $scope.criteria.typeAheadLocationResults.label;
          }
    	  subcategory = $scope.criteria.typeAheadLocationResults.subcategory;
      }

	  if(window.location.href.indexOf("page=providerResults&") > -1){
		  if($scope.criteria.typeahead !== null){
			$scope.criteria.typeahead.coordinates = $scope.criteria.typeaheadLocation.coordinates;
		  }
	  }

	    AnalyticsService.trackForm({
	        name: 'location change',
	        zip: aZip,
	        geography: geo,
	    	subcategory: subcategory,
	        distance: $scope.criteria.distance,
	        state: 'completed'
	    });

	    AnalyticsService.trackView('provider search', 2);
    };
		this.closeChangeLocation = function() {
			$scope.changeLocationPlanPageFlag=false;
			$scope.changeLocationFlag=false;
      AnalyticsService.trackView('provider search', 2);
			ProviderSearchCriteriaService.closeChangeLocation();
			ctrl.isChangeLocation = false;
			// $scope.slider.options.disabled = false;  // always disable slider for next search
			$scope.slider.options.disabled = $scope.criteria.isSliderEnable;  // always disable slider for next search
			$scope.criteria.typeaheadLocation = $scope.criteria.duplicatetypeAheadLocation;//change1
			isLocationboxClicked = false; //change1


			angular.element("#changeLocation" ).hide();
			angular.element("#changeLocation" ).addClass("fade");
			angular.element("#changeLocation" ).removeClass("fadeIn");
			angular.element(".modal-backdrop" ).css("display","none");
		};

		$scope.closeSearch = function() {
			$scope.criteria.typeAheadSearch = "";
			angular.element("#Doctors").blur();
		};

		$scope.getTypeAheadSearchInfo = function(val) {
			return ProviderSearchCriteriaService.getTypeAheadSearchInfo(val).then(function(resp){
				$scope.didYouMean = ProviderSearchCriteriaService.getisDidYouMean();
				if($scope.didYouMean){
			$scope.didYouMeanClass='didYouMeanClass';
			}
			else{
				$scope.didYouMeanClass='';
			}
			return resp;
			});
		};

		$scope.getTypeAheadLocationInfo = function(val) {
			 return ProviderSearchCriteriaService.getTypeAheadLocationInfo(val);
		};

		// This handles putting separators between the displayed type-ahead groups
		var groupCount = 0;
		$scope.initializeGroupCount = function() {
			groupCount = 0;
			return "";
		}

		$scope.incrementGroupCount = function(itemCount) {
			if (itemCount > 0) {
				groupCount++;
				return groupCount;
			} else {
				return 0;
			}
		}

		// return true if on new search screen and false if on results screen
		$scope.newSearch = function() {
			return window.location.href.indexOf("providerSearch") != -1;
		}

		$scope.locationDisplayed=function(){
			var locationDisplay="";
			if($scope.criteria.siteId=='medicare'){
				if($scope.criteria.typeAheadLocationResults.subcategory=='zipcode'){
					locationDisplay=$scope.criteria.typeAheadLocationResults.zipcode+" ("+toProperCase($scope.criteria.medicare.county)+" county"+")";
				}
				if($scope.criteria.typeAheadLocation.subcategory=='city'){
					locationDisplay=$scope.criteria.typeAheadLocationResults.label+" ("+toProperCase($scope.criteria.medicare.county)+" county"+")";
				}
				if($scope.criteria.typeAheadLocation.subcategory=='county'){
					var countyName = $scope.criteria.typeAheadLocationResults.label.split(',');
					locationDisplay=countyName[0]+" county"+", "+countyName[1];
				}
				if($scope.criteria.typeAheadLocation.subcategory=='state'){
					locationDisplay=$scope.criteria.typeAheadLocationResults.label+" ("+toProperCase($scope.criteria.medicare.county)+" county"+")";
				}
			}else{
				locationDisplay=$scope.criteria.typeAheadLocationResults.label;
			}
			return locationDisplay;
		};

		var toProperCase = function (str) {
			return str.replace(
			        /\w\S*/g,
			        function(txt) {
			            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
			        }
			    );
		};


		//This is a temporary fix for the text block height issue in Alternate Medicine 2nd level
		if (window.location.href.indexOf("page=providerAlternativeMedicine&") > -1){
			$('.search-block-description').addClass('textBlockHeight');
			$('.col-sm-6.col-md-2.tile_holder').addClass("padMargin");
			$('.col-sm-6.col-md-2.tile_holder').addClass("tileAdj");
			//var temp=$( "#provider-srch > .whiteBoxBlock ")
			/*if($("div.customLinkDiv").length){
					$( "#provider-srch" ).find( ".customLinkDiv" ).addClass('marT');
			}
			else{
					$( "#provider-srch" ).find( ".whiteBoxBlock" ).addClass('marT');
			}*/

			/*if (window.location.href.indexOf("site_id=dse") > -1){
				$( "#provider-srch" ).find( ".whiteBoxBlock" ).addClass('marT');
			}*/
			/*else{

				//var tempCheck=(($( "#provider-srch" ).find( ".customLinkDiv" )));
				if(!($( "#provider-srch" ).hasClass( ".customLinkDiv" ))){
					$( "#provider-srch" ).find( ".whiteBoxBlock" ).addClass('marT');
				}
				else{
					$( "#provider-srch" ).find( ".customLinkDiv" ).addClass('marT');
				}

			}*/


		}

	}

	/**
	 * Define directive to keep specified element in view.  It checks whenever
	 * a cursor up/down key is pressed and scrolls the element into view if
	 * it goes out of view.
	 *
	 * Specify attribute "scrollSelectedSelector" which is a JQuery selector
	 * that identifies the element to be checked.
	 *
	 * This directive would be used on an input field and the selector would
	 * indicate an element that gets highlighted as the cursor up/down is
	 * pressed
	 */



	angular.module('nav-ui')
    .directive('onScreen', function () {
    	// Determine if an element is in the visible viewport
			function isInViewport(element) {
	 		 var rect = element.getBoundingClientRect();
	 		 var html = document.documentElement;
	 		 return (
	 			 rect.top >= 0 &&
	 			 rect.left >= 0 &&
	 			 rect.bottom <= (window.innerHeight || html.clientHeight) &&
	 			 rect.right <= (window.innerWidth || html.clientWidth)
	 		 );
	 	 }
    	return {
            restrict: 'A',
            priority: 1000, // Let's ensure AngularUI Typeahead directive gets initialized first!
            link: function (scope, element, attrs) {
                // Bind keyboard events: arrows up(38) / down(40)
                element.bind('keyup', function (evt) {

                    if (evt.which !== 38 && evt.which !== 40) {  // not an up/down
                    	return;
                    }
										// evt.preventDefault();

                    // get the element just selectedvar
										var idInput=attrs.id;
                   	var scrollSelectedSelector = attrs.scrollSelectedSelector;
										var element=$('#'+idInput).next().find(scrollSelectedSelector)[0];
										element.scrollIntoView(false);
                   //	var element = $(scrollSelectedSelector)[0];
										// if(!isInViewport(element)){
	                  //   element.scrollIntoView(false);
										// }

                }); // event handler

            } // link function
        }; // return object
    });	// directive


})();

},{}],16:[function(require,module,exports){
angular.module('nav-ui').filter('toArray',toArray);

/** This is to convert any object to Array so that ng-repeat directive works fine.  **/
function toArray() {
	return  function(input) {
		if(input!= undefined){			
			if (angular.isArray(input)) {
				return input;
			} else {
				return [input];
			}
		}
	};
}


},{}],17:[function(require,module,exports){
angular.module('nav-ui').filter('trustHtml',trustHtml);

/** This is to convert any object to Array so that ng-repeat directive works fine.  **/
function trustHtml($sce) {
	return function(input){
        var html =  $sce.trustAsHtml(input);
        return html;
    }
}


},{}],18:[function(require,module,exports){
(function() {
    angular
        .module('nav-ui')
        .controller('TopchromeControllerNew', TopchromeControllerNew);
        TopchromeControllerNew.$inject = ['$scope', 'PageBuilderService', 'ContentResultsService', '$http', '$log', '$compile', '$rootScope','$sessionStorage', 'configuration','ProviderSearchCriteriaService','$state','BrandingLogoService','$window','CommonUtilsService','$location','$rootScope','LanguageDataService','NavSpinnerService'];
    function TopchromeControllerNew($scope, PageBuilderService, ContentResultsService, $http, $log, $compile, $rootScope,$sessionStorage, configuration,ProviderSearchCriteriaService,$state,BrandingLogoService,$window,CommonUtilsService,$location,$rootScope,LanguageDataService,NavSpinnerService) {
    	var brandingLogoSwitch;
    	var redirectToMyplanportalSwitch;
    	$scope.criteria = ProviderSearchCriteriaService.getCriteria();
    	$scope.languageData = LanguageDataService.getLanguageData();

 		var siteId = $state.params.site_id;
 		if (siteId == null || siteId == undefined) {
 			siteId = 'dse';
 		}
 		$scope.criteria.siteId = siteId;


 		var lang = $state.params.language;
 		if (lang == null || lang == undefined || lang!=="es") {
 			lang = 'en'; // blank defaults to English
 		}
    $scope.showSpanishLang=true;
 		$scope.criteria.language = lang;
 		loadDeveloperContent();

    	var ctrl = this;
        // ctrl.showTopChrome = showTopChrome;
        ctrl.message = {};
        ctrl.message.text = '';
        //Initialize node object to receive details from topChrome.json
        var allTopChromeNodes = {};
        //use topChrome.json to get base links
        var topChromeBaseLinksNodeBeanList = {};
        //use topChrome.json to get bottomchrome links
        var topChromeBottomChromeNodeBeanList = {};


        var arrSiteIds = configuration.customSiteIds;
        
        var iterIds;
        var idFound = false;
        for (iterIds = 0; iterIds < arrSiteIds.length; iterIds++) { 
            if(siteId === arrSiteIds[iterIds]){
                idFound = true;
            }
        }
        if(idFound === false){
            var leavingUrl;
            if(siteId !== undefined){
                leavingUrl = $state.href('leavingPage',{page:'leavingPage',language:'en',site_id:siteId});
            }else{						
                leavingUrl = $state.href('leavingPage',{page:'leavingPage',language:'en',site_id:'dse'});
            }
            window.open(leavingUrl,"_self");
            NavSpinnerService.stop();
        }else{
            if($state.params.page !== undefined){
                showTopChrome();
            }
        }


         function showTopChrome() {
             var contentId = 'topChrome';
             var contentType = 'biz';
             var contentLang = '';
             ContentResultsService.getContent(contentId, contentType, contentLang)
                 .then(
                     function success(result) {
                         // promise was fullfilled (regardless of outcome)
                         // checks for information will be peformed here
                         //$log.debug("heree...");
                         PageBuilderService.buildPage(result);
                         setTopChromePageHtmlElements(result);
                     },
                     function error(errorMsg) {
                         // handle errors here
                         $log.error(errorMsg.statusText);
                         ctrl.message.text = errorMsg.statusText
                     }
                 );

             function setTopChromePageHtmlElements(topChromeNodes) {
                  if(topChromeNodes.childNodeList != undefined){
                        //$log.debug("testing....1");
                        setTopChromeLeftJust(topChromeNodes.childNodeList);
                        //$log.debug("testing....2");
                        setTopChromeNavButton(topChromeNodes.childNodeList);
                        //$log.debug("testing....3");
                        setTopChromeRightJust(topChromeNodes.childNodeList);
                  }
                 //$log.debug("testing....4");
                 loadSideMenu();
             }

             function setTopChromeLeftJust(topChromeChildNodes) {
                    if(topChromeChildNodes != undefined){
                     var count = 0;
                     //$log.debug("topChromeChildNodes.length: " + topChromeChildNodes.length);
                     for (var i = 0; i < topChromeChildNodes.length; i++) {
                         //$log.debug("topChromeChildNodes[i].attributeMap: " + topChromeChildNodes[i].attributeMap);
                         if (topChromeChildNodes[i].attributeMap) {
                             //$log.debug("topChromeChildNodes[i].attributeMap.type: " + topChromeChildNodes[i].attributeMap.type);
                             if (topChromeChildNodes[i].attributeMap.type == 'leftjustified') {
                                 var aetLogoDiv = angular.element(document.getElementById('topChromeImage'));
                                 //$log.debug("topChromeChildNodes[i].childNodeList.length : " + topChromeChildNodes[i].childNodeList.length);
                                 for (var j = 0; j < topChromeChildNodes[i].childNodeList.length; j++) {
                                     //$log.debug("topChromeChildNodes[i].childNodeList[j].attributeMap.type :  " + topChromeChildNodes[i].childNodeList[j].attributeMap.type);
                                     var childChild = topChromeChildNodes[i].childNodeList[j];
                                     if (childChild.attributeMap.type == 'images') {
                                         //$log.debug("childChild length : " + childChild.childNodeList.length);
                                         for (var iCC = 0; iCC < childChild.childNodeList.length; iCC++) {
                                             if (childChild.childNodeList[iCC].childNodeList[0]) {
                                                 //var linkCC = PageBuilderService.processNode(childChild.childNodeList[iCC].nodeName, childChild.childNodeList[iCC]);
                                                 var vImage = '';
                                                 var vAltTex = '';
                                                 var vTitle = '';
                                                 for (var jCC = 0; jCC < childChild.childNodeList[iCC].childNodeList.length; jCC++) {
                                                     var vNodeName = childChild.childNodeList[iCC].childNodeList[jCC].nodeName;
                                                     //$log.debug("vNodeName : " + vNodeName);
                                                     if (vNodeName == 'url') {
                                                         vImage = childChild.childNodeList[iCC].childNodeList[jCC].nodeValue;
                                                         vTitle = 'Aetna Logo';
                                                     } else if (vNodeName == 'src') {
                                                         vImage = childChild.childNodeList[iCC].childNodeList[jCC].nodeValue;
                                                         vTitle = 'Plan Sponsor Logo';
                                                     }
                                                     //$log.debug("vImage : " + vImage);
                                                     if (vNodeName == 'alttext') {
                                                         vAltTex = childChild.childNodeList[iCC].childNodeList[jCC].nodeValue;
                                                         if (!vAltTex) {
                                                             vAltTex = '';
                                                         }
                                                         //$log.debug("vAltTex : " + vAltTex);
                                                     }
                                                 }
                                                 var linkCC = '<img src="' + vImage + '" alt="' + vAltTex + '" title="' + vTitle + '">';
                                                 //linkCC = linkCC[0].outerHTML;
                                                 var childAltTxt = childChild.childNodeList[iCC].childNodeList[1].nodeValue;
                                                 var htmlOutput = '<a href="javascript:void(0);" title="' + childAltTxt + '">' + linkCC + '</a>';
                                                 if (vTitle == 'Plan Sponsor Logo') {
                                                     htmlOutput = linkCC;
                                                 }
                                                 //$log.debug("...htmlOutput: " + htmlOutput);
                                                 htmlOutput = angular.element(htmlOutput);
                                                 aetLogoDiv.append(htmlOutput);
                                             }
                                         }
                                     } // if links
                                 } //for j
                             } // if rightjust
                         } // if attr map
                     } // for child
                   }
                 } // fn left just

             function setTopChromeNavButton(topChromeChildNodes) {
                     var count = 0;
                     //$log.debug("topChromeChildNodes.length: " + topChromeChildNodes.length);
                     for (var i = 0; i < topChromeChildNodes.length; i++) {
                         //$log.debug("topChromeChildNodes[i].attributeMap: " + topChromeChildNodes[i].attributeMap);
                         if (topChromeChildNodes[i].attributeMap) {
                             //$log.debug("topChromeChildNodes[i].attributeMap.type: " + topChromeChildNodes[i].attributeMap.type);
                             if (topChromeChildNodes[i].attributeMap.type == 'leftjustified') {
                                 //$log.debug("topChromeChildNodes[i].childNodeList.length : " + topChromeChildNodes[i].childNodeList.length);
                                 for (var j = 0; j < topChromeChildNodes[i].childNodeList.length; j++) {
                                     //$log.debug("topChromeChildNodes[i].childNodeList[j].attributeMap.type :  " + topChromeChildNodes[i].childNodeList[j].attributeMap.type);
                                     var childChild = topChromeChildNodes[i].childNodeList[j];
                                     if (childChild.attributeMap.type == 'appids') {
                                         var vFunction = '';
                                         var vLabel = '';
                                         var vUniqID = '';
                                         var appidsChildList = childChild.childNodeList;
                                         for (var iCC = 0; iCC < appidsChildList.length; iCC++) {
                                             var _appidChildList = appidsChildList[iCC];
                                             vFunction = _appidChildList.attributeMap['function'];
                                             //$log.debug("childChild.childNodeList[iCC].nodeName herere 1 : " + vFunction);
                                             for (var jCC = 0; jCC < _appidChildList.childNodeList.length; jCC++) {
                                                 //$log.debug(".nodeName herere 2 : " + _appidChildList.childNodeList[jCC].nodeName);
                                                 if (_appidChildList.childNodeList[jCC].nodeName == 'label') {
                                                     vLabel = _appidChildList.childNodeList[jCC].nodeValue;
                                                 }
                                                 if (_appidChildList.childNodeList[jCC].nodeName == 'uniqueidentifier') {
                                                     vUniqID = _appidChildList.childNodeList[jCC].nodeValue;
                                                 }
                                             }
                                         } //for loop
                                         //$log.debug("vFunction 1 : " + vFunction);
                                         //$log.debug("vuniqid 1 : " + vUniqID);
                                         //$log.debug("vlabel 1 : " + vLabel);
                                         var vSpan1 = '<span class="sr-only">' + vUniqID + '</span>';
                                         vSpan1 = angular.element(vSpan1);
                                         var vSpanBar = '<span class="icon-bar"></span>';
                                         vSpanBar = angular.element(vSpanBar);
                                         /* var vSpanBar2 = '<span class="icon-bar"></span>';
                                          vSpanBar2 = angular.element(vSpanBar2);
                                          var vSpanBar3 = '<span class="icon-bar"></span>';
                                          vSpanBar3 = angular.element(vSpanBar3);
                                          var vSpan3 = '<span class="Menu_txt show-mobile-only">' + vLabel + '</span>';
                                          vSpan3 = angular.element(vSpan3);*/
                                         var topChromeNavBtn = angular.element(document.getElementById('menu-toggle-btn'));
                                         topChromeNavBtn.append(vSpan1);
                                         topChromeNavBtn.append(vSpanBar);
                                         /*topChromeNavBtn.append(vSpanBar2);
                                         topChromeNavBtn.append(vSpanBar3);
                                         topChromeNavBtn.append(vSpan3);
                                         topChromeNavBtn.append(vSpan3);*/
                                         //topChromeNavBtn.addClass(vFunction);
                                     } // if appids
                                 } //for j
                             } // if rightjust
                         } // if attr map
                     } // for child
                 } // fn left just

             function setTopChromeRightJust(topChromeChildNodes) {
                     var count = 0;
                     //$log.debug("topChromeChildNodes.length: " + topChromeChildNodes.length);
                     for (var i = 0; i < topChromeChildNodes.length; i++) {
                         //$log.debug("topChromeChildNodes[i].attributeMap: " + topChromeChildNodes[i].attributeMap);
                         if (topChromeChildNodes[i].attributeMap) {
                             if (topChromeChildNodes[i].attributeMap.type == 'rightjustified') {
                                 //Set the UL html element for topChrome
                                 var ulId = 'links' + (count + 1);
                                 var eName = 'ul';
                                 var element = '<' + eName + ' id=' + ulId + ' class="nav navbar-nav"';
                                 element += '></' + eName + '>';
                                 element = angular.element(element);
                                 var topChromeMainDiv = angular.element(document.getElementById('topChromeRightContent'));
                                 topChromeMainDiv.append(element);
                                 //$log.debug("topChromeChildNodes[i].childNodeList.length : " + topChromeChildNodes[i].childNodeList.length);
                                 for (var j = 0; j < topChromeChildNodes[i].childNodeList.length; j++) {
                                     //$log.debug("topChromeChildNodes[i].childNodeList[j].attributeMap.type :" + topChromeChildNodes[i].childNodeList[j].attributeMap.type);
                                     var childChild = topChromeChildNodes[i].childNodeList[j];
                                     if (childChild.attributeMap.type == 'links') {
                                         //$log.debug("childChild.childNodeList.length : " + childChild.childNodeList.length);
                                         for (var iCC = 0; iCC < childChild.childNodeList.length; iCC++) {
                                             //var linkCC = PageBuilderService.processNode(childChild.childNodeList[iCC].nodeName, childChild.childNodeList[iCC]);
                                             /* NMD how can we get this <a>
                                             <a href="#" title="Find a Doctor">Find a Doctor |&nbsp; </a>
                                             */
                                             //linkCC = linkCC[0].outerHTML;
                                             //$log.debug("-----------------------linkCC : " + linkCC);
                                             var linkUl = angular.element(document.getElementById(ulId));
                                             //var htmlOutput = '<li>' + linkCC + '</li>';
                                             var aTxt = '';
                                             var aUrl = '';
                                             var node = childChild.childNodeList[iCC].childNodeList;
                                             //$log.debug("-----------------------childNode.length : " + childChild.childNodeList[iCC].childNodeList.length);
                                             for (var iNode = 0; iNode < node.length; iNode++) {
                                                 var childNode = node[iNode];
                                                 //$log.debug("-----------------------childNode : " + childNode);
                                                 if (childNode.nodeName == 'url') {
                                                     aUrl = childNode.nodeValue;
                                                 }
                                                 if (childNode.nodeName == 'label') {
                                                     aTxt = childNode.nodeValue;
                                                 }
                                             }
                                             var htmlOutput = '';
                                             if(aUrl != undefined && aUrl != '' && aTxt != undefined && aTxt != ''){
                                            	 if ((childChild.childNodeList.length - 1) == iCC) {
                                                     htmlOutput = '<li><a href="' + aUrl + '">' + aTxt + '</a></li>';
                                                 } else {
                                                     htmlOutput = '<li><a href="' + aUrl + '">' + aTxt + ' </a></li>';
                                                 }
                                                 htmlOutput = angular.element(htmlOutput);
                                                 linkUl.append(htmlOutput);
                                             }
                                         }
                                     } // if links
                                 } //for j
                             } // if rightjust
                         } // if attr map
                     } // for child
                 } // fn righ just



                 $scope.keyPressed=function(evt){
                   if(evt.charCode==13 || evt.charCode==32){
                     $scope.toggleCheckboxlang();
                   }
                 }
                 function loadSideMenu(){
                   var tempVar1=$('.nav.navbar-nav').find('li');
                   if(tempVar1.length==0){
                     $('.nav.navbar-nav').empty();
                     $('#menuButtonId').css('display','none ');
                     $('.fullWidthGrey').addClass('hideNoItem');
                   }
                   else{
                     var url = window.location.href;
                     var result = getLanguageParameter('language', url);
                     if(result=='es'){
                       $scope.langCurrent="En Espanol"
                       $scope.langCurrent1="English"
                     }else{ //if(result=='en'){
                       $scope.langCurrent="English";
                       $scope.langCurrent1="En Espanol"
                     }
                      $(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "<div id='mySidenav' class='sidenav'><ul role='menu' id='menuUlList'><li role='menuitem'><div ng-click='closeSideNav()' style='width:auto' class='text-right container'><a role='button' aria-label='Close Menu' href='' id='closeButtonId'><img src='images/close.png' alt='Close menu'></a></div></li><li role='menuitem' tabindex='0' class='langSwitch' ng-click='toggleCheckboxlang()' ng-keypress='keyPressed($event)'><span class='sr-only'>Selected Language is {{langCurrent}}, Press Enter or Space for {{langCurrent1}}</span><div aria-hidden='true' style='width:auto' class='container' ng-if='showSpanishLang' id='engEsp'><div class='row' aria-hidden='true'><div aria-hidden='true' class='col-md-12' style='padding:20px;'><div class='switch6' aria-hidden='true'><label aria-hidden='true' class='switch6-light'><input aria-hidden='true' tabindex='-1' id='messageCheckbox' type='checkbox' ng-model='languageCheck' ng-change='toggleCheckboxlang()' ng-keypress='keyPressed($event)'><span aria-hidden='true'><span aria-hidden='true' id='engText'>English</span><span aria-hidden='true' id='espText'>En Espa&ntilde;ol</span></span><a aria-hidden='true' class='btn btn-primary customClass'></a></label></div></div></div></div></li><li role='menuitem' class='lnkUnder'></div></li></ul></div>" ).insertAfter("#mainWrapper");
                    $('#engText').attr('ng-class',"(languageCheck)?'whiteColor':'violetColor'");
                    $('#espText').attr('ng-class',"(languageCheck)?'violetColor':'whiteColor'");
                     $('#menuButtonId').attr('ng-click','toggleSideMenu()');
                     $('#menuButtonId').attr('role','button');
                     $('#menuButtonId').attr('aria-controls','menuUlList');
                     $('#menuButtonId').attr('aria-haspopup','true');
                     $('#menuButtonId').attr('aria-expanded','false');
                     $('#mainWrapper').attr('aria-hidden','false');
                     if(document.getElementById("menuButtonId"))
                    	 document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
                     $compile($( "#aet-header" ))($scope);
                     $compile($( "#mySidenav" ))($scope);
                     if($('.navbar-nav').clone()[0] != undefined){
                       var newtemp=$('.navbar-nav').clone()[0].children;
                       var countTemp=0;
                       if(newtemp.length){
                         for (var i = 0; i < newtemp.length; i++) {
                           if(newtemp[i].innerText.indexOf('Espa')>=0 || newtemp[i].innerText.indexOf('English')>=0){
                             countTemp=countTemp+1;
                           }
                           else if(newtemp[i].innerText!=="" && newtemp[i].innerText!==null && newtemp[i].innerText!==undefined){
                             $('#menuUlList').append($('.navbar-nav').clone()[0].children[i]);
                           }
                         }
                         var children=$('#menuUlList').children();
                        for (var i = 3; i < children.length; i++) {
                            $(children[i]).attr('role','menuitem');
                            $(children[i]).addClass('lnkUnder');
                            $(children[i]).children("a").attr( "role", "link" );
                        }
                       }
                       if(countTemp==0){
                         $scope.showSpanishLang=false;
                       }
                       else{
                         $scope.showSpanishLang=true;
                       }
                 	   }
                   }
                   $compile($( "#menuUlList" ))($scope);
                   $scope.focusForMenu();
                   sideMenuDisable();
                 }

                  // $( window ).resize(function() {
                  //   if($( window ).width()<=991){
                  //     $scope.focusForMenu();
                  //   }
                  // });

                 $scope.focusForMenu=function(){
                 	 var inputs = $('#mySidenav').find('select, input, textarea, button, a, iframe').filter(':visible');
                   var firstInput = inputs.first();
                   var lastInput = inputs.last();
                   firstInput.focus();
                   lastInput.on('keydown', function (e) {
                       if ((e.which === 9 && !e.shiftKey) ) {
                           e.preventDefault();
                           firstInput.focus();
                       }

                   });
                   firstInput.on('keydown', function (e) {
                       if ((e.which === 9 && e.shiftKey) ) {
                           e.preventDefault();
                           lastInput.focus();
                       }

                   });
                 }
                 $scope.toggleLanguageFunction=function(){
                	   var breadCrums = [];
	                   CommonUtilsService.resetBreadcrumbVariables(breadCrums);
	                   $scope.breadCrums = [];
	                   var url = window.location.href;
	                   var result = getLanguageParameter('language', url);
	                   var langCode='es';
	                   if(result=='es'){
	                	   langCode='en';
	                   }else{// if(result=='en'){
	                     langCode='es';
	                   }
	                   window.open(CommonUtilsService.replaceParamValInStringFromUrl(url, 'language', langCode),"_self");
                 }
                 //added for medicare transformation project - Team A
                 $scope.startNewSearch=function(){
                	 $scope.criteria = ProviderSearchCriteriaService.getCriteria();
                	 if($scope.criteria != undefined)
                	 {
						 $scope.criteria.medicare.category = '';
						 clicked=false;
						 $scope.criteria = ProviderSearchCriteriaService.resetCriteria();
						 if(document.getElementsByClassName('columnOne') != undefined && document.getElementById('dynamicTemplate') != undefined && 
								 document.getElementsByClassName('columnOne').length>0)
						 {
							 document.getElementsByClassName('columnOne')[0].style.display = "block";
							 document.getElementById('dynamicTemplate').style.display = "none";
						 }
                		 $state.go('contentPage',{"page":'providerSearchLanding',site_id:siteId,language:lang,year:'',category:''});
                		 //window.open(url,"_self");
                	 }                		
                 }
                 
                 $scope.closeSideNav=function(){
                   $('#menuButtonId').focus();
                   document.getElementById("mySidenav").style.width = "0px";
                   document.getElementById("mainWrapper").style.marginLeft = "0px";
                   document.getElementById("mainWrapper").style.minWidth = "";
                   document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
                   document.getElementById("menuButtonId").firstChild.classList.remove("menu-rotate");
                   document.getElementById("menuButtonId").setAttribute("aria-expanded", "false");
                   document.getElementById("mainWrapper").setAttribute("aria-hidden", "false");
                   sideMenuDisable();
                 }
                 $scope.toggleCheckboxlang=function(){
                   var checkedValue = document.getElementById('messageCheckbox').checked;
                   if(checkedValue){
                     $('#menuButtonId').focus();
                     document.getElementById("mySidenav").style.width = "0px";
                     document.getElementById("mainWrapper").style.marginLeft = "0px";
                     document.getElementById("mainWrapper").style.minWidth = "";
                     document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
                     document.getElementById("menuButtonId").setAttribute("aria-expanded", "false");
                     document.getElementById("mainWrapper").setAttribute("aria-hidden", "false");
                     $scope.toggleLanguageFunction();
                     sideMenuDisable();
                   }else{
                     $('#menuButtonId').focus();
                     document.getElementById("mySidenav").style.width = "0px";
                     document.getElementById("mainWrapper").style.marginLeft = "0px";
                     document.getElementById("mainWrapper").style.minWidth = "";
                     document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
                     document.getElementById("menuButtonId").setAttribute("aria-expanded", "false");
                     document.getElementById("mainWrapper").setAttribute("aria-hidden", "false");
                     $scope.toggleLanguageFunction();
                     sideMenuDisable();
                    }
                 }
         }
         function loadDeveloperContent() { //load $sessionStorage.languageData
        	 var contentId = 'developer';
             var contentType = 'dev';
             var contentLang = '';

             $scope.languageData = {};
             // $sessionStorage.languageData = {};
             ContentResultsService.getContent(contentId, contentType, contentLang)
                 .then(
                     function success(result) {
                       // promise was fullfilled (regardless of outcome)
                       // checks for information will be peformed here
                       $sessionStorage.languageData = result;
                       $scope.languageData = result;
                       LanguageDataService.setLanguageData(result);

                       $scope.criteria.distance=$scope.languageData.DEFAULT_DISTANCE;
                       brandingLogoSwitch = $scope.languageData.SWITCH_BRANDING_LOGO;
                       redirectToMyplanportalSwitch = $scope.languageData.SWITCH_REDIRECT_TO_MYPLANPORTAL;
                       redirectiToMyPlanPortal(redirectToMyplanportalSwitch);
                       getLogoFromARMS();
                       var page = $state.params.page;
                       var devContent = $scope.languageData;

                       $sessionStorage.DisclaimerButtons = {};
                       $sessionStorage.DisclaimerButtons.continueTxt=devContent.CONTINUE_BUTTON;
                       $sessionStorage.DisclaimerButtons.cancelTxt=devContent.DP_CANCEL;


                       if(window.location.href.indexOf("redirect=true") > -1 ||
                    		   (devContent.SWITCH_REDIRECT_TO_OLD_DSE == "ON" && window.location.href.indexOf("redirect=false") == -1 )){
                           window.location.href = devContent.OLD_DSE_URL;
                        }


	       			   if(page =='providerSearchLanding' && devContent && devContent.SWITCH_LANDING_PAGE_MODAL == "ON"){
	       					displayLandingModalForCustom();
	       			   }
	       			   setPageTitle();

	       			   /*alert(  "Return value : loadDeveloperContent "+JSON.stringify(result));*/
                     },
                     function error(errorMsg) {
                         // handle errors here
                    	 /*alert(" External error  : loadDeveloperContent "+JSON.stringify(response));*/
                         $log.error(errorMsg.statusText);
                         ctrl.message.text = errorMsg.statusText
                     }
                 );
         }
         
         function redirectiToMyPlanPortal(redirectToMyplanportalSwitch){
				var currentHost = $location.host();
				if(redirectToMyplanportalSwitch != null && redirectToMyplanportalSwitch != undefined && redirectToMyplanportalSwitch != "" && 
						redirectToMyplanportalSwitch == "ON" && currentHost.indexOf("www.aetna.com") != -1){
					var currentUrl = window.location.href;
					var newUrl = currentUrl.replace("www.aetna.com","www.myplanportal.com");
					window.location.href = newUrl;
				}
		}
         
         function setPageTitle(){
        	 var contentPage = $location.search().page;
 			   if(!contentPage){
	       			  var urlLink = window.location.href.split("=");
	       			  contentPage = urlLink[urlLink.length-1];
 			   }
 			   $rootScope.pageTitle = "Directory of Health Care Professionals";
 			   if($scope.languageData){
 				   if($scope.languageData["HEADER_TITLE_"+contentPage]){
 					   $rootScope.pageTitle = $scope.languageData["HEADER_TITLE_"+contentPage];
 				   }
 				   else{
 					   $rootScope.pageTitle = $scope.languageData.HEADER_TITLE_DEFAULT;
 				   }
 			   }
         }
         function getLogoFromARMS(){
        	 /*check if branding logo switch is enabled then call service for logo based on domain and siteId*/
             if(brandingLogoSwitch == 'true'){
     	      BrandingLogoService.getBrandingLogo().then(
     	          function success(response){
     	            $scope.src=""
     	            $scope.logoSrc=response.data.correspondenceARMSRulesResponse.readCorrespondenceARMSRulesResponse.correspondenceARMSRulesCharacteristics;
     	            for (i = 0; i < $scope.logoSrc.length; i++) {
     	              // Commention below coz http images aer not working on safari browser. So we have to use https version of hte image.
     	              //if($scope.logoSrc[i].name=="Unsecure Logo Location"){
     	              if($scope.logoSrc[i].name=="Secure Logo Location"){
     	                $scope.src1=$scope.logoSrc[i].value;
     	              }
     	              if($scope.logoSrc[i].name=="LogoFileName"){
     	                $scope.src2=$scope.src+$scope.logoSrc[i].value;
     	              }
     	            }
     	            $scope.src=$scope.src1+$scope.src2;
     	            /*replace the aetna image with the corresponding logo recied from service and add some additional styling*/
     	            var logo=$('#brandingLogoId').find('img');
     	            $(logo).attr('src',$scope.src);
                  $(logo).css("padding-right","15px");
     	            $('.navbar.navbar-default').css( "padding", "0px" );
     	            $('.navigator-logos.pull-left').css( "margin", "0px" );
     	          },
     	          function error(response){
     	          }
     	      );
     	    }
     	    /*branding logo service call end*/
         }

         function getLanguageParameter( name, url ) {
            var defaultLang = 'en';
            if (!url) url = location.href;
            name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            var regexS = "[\\?&]"+name+"=([^&#]*)";
            var regex = new RegExp( regexS );
            var results = regex.exec( url );
            return results == null ? defaultLang : results[1];
        }
         $scope.toggleSideMenu=function(){
           var url = window.location.href;
           var result = getLanguageParameter('language', url);
           if(result=='en' && document.getElementById('messageCheckbox')!==null && document.getElementById('messageCheckbox')!==undefined){
             document.getElementById('messageCheckbox').checked = false;
             toggleLanguageButtonClass();
           }
           if(result=='es' && document.getElementById('messageCheckbox')!==null && document.getElementById('messageCheckbox')!==undefined){
             document.getElementById('messageCheckbox').checked = true;
             toggleLanguageButtonClass();
           }
           var sideMenu=document.getElementById("mySidenav");
           var menuButton=document.getElementsByClassName("menu-logo");
           if(sideMenu.offsetWidth!==0){
             /*$('#brandingLogoId').focus();
             document.getElementById("mySidenav").style.width = "0px";
             document.getElementById("mainWrapper").style.marginLeft = "0px";
             document.getElementById("mainWrapper").style.minWidth = "";
             document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
             document.getElementById("menuButtonId").firstChild.classList.remove("menu-rotate");*/
           }
           else{
             $('#closeButtonId').focus();
             document.getElementById("mySidenav").style.width = "250px";
             document.getElementById("mainWrapper").style.marginLeft = "250px";
             document.getElementById("mainWrapper").style.minWidth = "400px";
             document.getElementById("menuButtonId").firstChild.setAttribute("src", "images/homeicons/ham_menu.png");
             document.getElementById("menuButtonId").firstChild.classList.add("menu-rotate");
             document.getElementById("menuButtonId").setAttribute("aria-expanded", "true");
             document.getElementById("mainWrapper").setAttribute("aria-hidden", "true");
             sideMenuEnable();
           }

         }

         function toggleLanguageButtonClass(){
           $scope.languageCheck=document.getElementById('messageCheckbox').checked;
           $('#engText').attr('ng-class',"(languageCheck)?'whiteColor':'violetColor'");
           $('#espText').attr('ng-class',"(languageCheck)?'violetColor':'whiteColor'");
         }

         function displayLandingModalForCustom(){
				angular.element("#landingPageModal" ).show();
				angular.element("#landingPageModal" ).css("display","block");
				angular.element("#landingPageModal" ).addClass("fadeIn");
				angular.element("#landingPageModal" ).removeClass("fade");
				angular.element("body" ).append("<div class='modal-backdrop fade in'></div>");
		 }

     function sideMenuDisable(){
       var inputs = $('#mySidenav').find('input, button, a, .langSwitch');
       for (var i = 0; i < inputs.length; i++) {
         $(inputs[i]).attr('tabindex','-1');
       }
     }

     function sideMenuEnable(){
       var inputs = $('#mySidenav').find('input, button, a, .langSwitch');
       for (var i = 0; i < inputs.length; i++) {
         $(inputs[i]).removeAttr('tabindex');
       }
       $('.langSwitch').attr('tabindex','0');
       $('#messageCheckbox').attr('tabindex','-1');
     }

         $scope.ok = function() {
				angular.element("#landingPageModal" ).hide();
				angular.element("#landingPageModal" ).addClass("fade");
				angular.element("#landingPageModal" ).removeClass("fadeIn");
				angular.element(".modal-backdrop" ).css("display","none");
		 }
    }
})();

},{}],19:[function(require,module,exports){
(function() {

  window.jQuery = window.$ = require('jquery');

//   --------------  Externalising code for config.json <Start> -------------------------------
            var navUIApp = angular
                .module('nav-ui', ['ui.router','ui.bootstrap','ngAnimate','rzModule','angularSpinner','ngStorage',
                'deploy','pascalprecht.translate','ngSanitize', 'angular.filter', 'ui.bootstrap.datetimepicker',
            'ngCookies'
            ]);
            /* this is to use config file either from outside location(appConfig) or the constant.js
            Initially we use the $http service of angular to fetch the config.json from appConfig*/
            var initInjector = angular.injector(["ng"]);
            var $http = initInjector.get("$http");
            var tempHost = window.location.host;
            
            var hostArr = tempHost.split("www");
            var finalHost = '';
            switch (hostArr[0]) {
                    case 'localhost:8080':
                        finalHost = hostArr[0] ;
                        break;
                    case 'qa':
                    case 'qa2':
                    case 'qa3': 
                    case 'dev':
                    case 'dev2':
                    case 'dev3': 
                    case 'str':
                        finalHost = hostArr[0] + 'www'+ hostArr[1];
                        break;
                    default:
                        finalHost = tempHost;
            }
            $http({
                    method: 'GET',
                    url: "https://" + finalHost + "/dsepublicContent/assets/json/config.json",
                    headers: {
                        'accept': 'application/json'
                    }
            }).then(function(data) {
                        /* we check the switch  for config file and then based on that we load either the constant.js or the response from ajax call*/
                        if (data.data !== "" && data.data !== undefined && data.data !== null && data.data.configSwitch) {
                                    var tempHost = window.location.host;
                                    if (tempHost.indexOf('qa3') > -1) {
                                        navUIApp.constant("configuration", data.data.qa3.configuration);
                                    } else if (tempHost.indexOf('qa2') > -1) {
                                        navUIApp.constant("configuration", data.data.qa2.configuration);
                                    } else if (tempHost.indexOf('qa') > -1) {
                                        navUIApp.constant("configuration", data.data.qa.configuration);
                                    } else if (tempHost.indexOf('dev3') > -1) {
                                        navUIApp.constant("configuration", data.data.dev3.configuration);
                                    } else if (tempHost.indexOf('dev2') > -1) {
                                        navUIApp.constant("configuration", data.data.dev2.configuration);
                                    } else if (tempHost.indexOf('dev') > -1) {
                                        navUIApp.constant("configuration", data.data.dev.configuration);
                                    } else if (tempHost.indexOf('str') > -1) {
                                        navUIApp.constant("configuration", data.data.stress.configuration);
                                    } else if (tempHost.indexOf('local') > -1) {
                                        navUIApp.constant("configuration", data.data.local.configuration);
                                    } else {
                                        navUIApp.constant("configuration", data.data.prod.configuration);
                                    }
                                    requireMainFiles();
                                    requireOtherFiles();
                                    angular.element(document).ready(function() {
                                        try {
                                            angular.bootstrap(document, ['nav-ui']);
                                        } catch (e) {
                                            document.write('Failed to load Application.<br/><b>Error :</b>');
                                            document.write('<br/>' + e);
                                        }
                                    });
                        } else {
                                // we cannot use constant.js if switch is off
                                require('./constants.js');
                                // we dynamically load the deploy module based on our requirement
                                navUIApp.requires.push('deploy');
                                // all the files which have to be imnported are now in a function which are called before manual bootstrapping
                                requireMainFiles();
                                requireOtherFiles();
                                // manual bootrapping angular after config load
                                angular.element(document).ready(function() {
                                        try {
                                            angular.bootstrap(document, ['nav-ui']);
                                        } catch (e) {
                                            document.write('Failed to load Application.<br/><b>Error :</b>');
                                            document.write('<br/>' + e);
                                        }
                                });
                        }
            }, function(response) {
                    // if ajax call fails then we use constant.js
                    require('./constants.js');
                    navUIApp.requires.push('deploy');
                    requireMainFiles();
                    requireOtherFiles();
                    angular.element(document).ready(function() {
                            try {
                                angular.bootstrap(document, ['nav-ui']);
                            } catch (e) {
                                document.write('Failed to load Application.<br/><b>Error :</b>');
                                document.write('<br/>' + e.stack);
                            }
                    });
            });
//   --------------  Externalising code for config.json <Ends> -------------------------------

            navUIApp.config(['$httpProvider', '$compileProvider', '$locationProvider','$sceDelegateProvider', function ($httpProvider, $compileProvider, $locationProvider,$sceDelegateProvider) {

            /*
                Performance hacks. 
            */
            try{
                $httpProvider.useApplyAsync(true);
                $compileProvider.debugInfoEnabled(false);
                //Disable comment and css directives
                $compileProvider.commentDirectivesEnabled(false);
                $compileProvider.cssClassDirectivesEnabled(false);
                //Remove ! from the url to continue with #. 
                $locationProvider.hashPrefix('');
				$sceDelegateProvider.resourceUrlWhitelist(['**']);
            }
            catch(exp)
            {
                
            }

    	  //Reset headers to avoid OPTIONS request (aka preflight)
    	  $httpProvider.defaults.headers.common = {};
    	  $httpProvider.defaults.headers.post = {};
    	  $httpProvider.defaults.headers.get = {};
    	  $httpProvider.defaults.headers.put = {};
    	  $httpProvider.defaults.headers.patch = {};
    	  $httpProvider.defaults.useXDomain = true;
    	  $httpProvider.defaults.withCredentials = false;

    	  $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|javascript):/);
    	// enable caching for scripts imported via xhr calls,
    		//as we have versioning, we dont't need it to load everytime from server
    		 /* $.ajaxPrefilter( "script", function( s ) {
    		  	s.cache = true;
    		  	if ( s.crossDomain ) {
    		  		s.type = "GET";
    		  	}
    		  });*/
    }]);
    

    // angular.element(document).ready(function () {  
    //     angular.bootstrap(document, ['nav-ui']);
    // });

    function requireMainFiles() {
            //** Needs to be loaded before app.route
            require('./logging.provider.js');

            require('./app.route.js');
            require('./app.run.js');

            require('./constants.js');
            require('./i18n.js');
    }

  /*Added below code to avoid caching of html templates in browser*/
  /*function configureTemplateFactory($provide) {
        var cacheBust = Date.now().toString();
        function templateFactoryDecorator($delegate) {
              var fromUrl = angular.bind($delegate, $delegate.fromUrl);
              $delegate.fromUrl = function (url, params) {
                    if (url !== null && angular.isDefined(url) && angular.isString(url)) {
                        url += (url.indexOf("?") === -1 ? "?" : "&");
                        url += "v=" + cacheBust;
                    }
                    return fromUrl(url, params);
              };
              return $delegate;
        }
        $provide.decorator('$templateFactory', ['$delegate', templateFactoryDecorator]);
 }*/

  /*Added below code to avoid caching of html templates in browser*/
  function configureTemplateFactory($provide) {

    var cacheBust = getParameterByName('v',$('script[src*="?v="]')[0].src);

    function templateFactoryDecorator($delegate) {
        var fromUrl = angular.bind($delegate, $delegate.fromUrl);
        $delegate.fromUrl = function (url, params) {
            if (url !== null && angular.isDefined(url) && angular.isString(url)) {
                url += (url.indexOf("?") === -1 ? "?" : "&");
                url += "v=" + cacheBust;
            }

            return fromUrl(url, params);
        };

        return $delegate;
    }

    $provide.decorator('$templateFactory', ['$delegate', templateFactoryDecorator]);
 }

  function getParameterByName(name, url) {
	    if (!url) url = window.location.href;
	    name = name.replace(/[\[\]]/g, "\\$&");
	    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
	        results = regex.exec(url);
	    if (!results) return null;
	    if (!results[2]) return '';
	    return decodeURIComponent(results[2].replace(/\+/g, " "));
	}

 angular.module('nav-ui').config(['$provide', configureTemplateFactory]);

 function requireOtherFiles() {            
            require('../services/page_builder.service.js');
            require('../components/disclaimer/disclaimer.controller.js');
            require('../services/common.directive.js');
            require('../components/menu/newMenu.controller.js');
            require('../components/content/content.controller.js');
            require('../components/topchrome/topchromeNew.controller.js');
            require('../components/footer/footer.controller.js');
            require('../services/searchCritera.service.js');
            require('../services/languageData.service.js');
            require('../services/content.service.js');
            require('../services/contentIdList.service.js');
            //added for ProviderResults module
            require('../components/publicProvider/planSelection.controller.js');
            require('../components/publicProvider/providerSearch.controller.js');
            require('../components/publicProvider/providerResults.controller.js');
            require('../components/publicProvider/compareController.controller.js');
            require('../components/medicare/medicareCountySelection.controller.js');
            require('../components/medicare/plansList.Controller.js');
            require('../components/publicProvider/providerDetails.controller.js');
            /*require('../components/publicProvider/providerPageTitle.controller.js');*/

            require('../components/publicProvider/toArray.filter.js');
            require('../components/publicProvider/customPlanFilter.filter.js');
            require('../components/publicProvider/unicodeEscape.filter.js');
            require('../components/publicProvider/directoryLastupdated.controller.js');
            require('../components/debug/debugController.controller.js');
            require('../services/results.service.js');
            require('../services/format.filter.js');
            require('../services/ratings.service.js');
            require('../services/reviews.service.js');
            require('../services/navSpinner.service.js');
            require('../services/commonUtils.service.js');
            require('../services/analytics.service.js');
            require('../services/planList.service.js');
            require('../services/pdf.service.js');
            require('../services/brandingLogo.service.js');
            require('../services/googleMaps.service.js');
            require('../services/compareProviders.service.js');

            //Navigator page directives
            require('../nav/application/nav_application.controller.js');
            require('../nav/application/nav_application.directive.js');

            require('../nav/box_header/nav_box_header.controller.js');
            require('../nav/box_header/nav_box_header.directive.js');

            require('../nav/group/nav_group.controller.js');
            require('../nav/group/nav_group.directive.js');
            require('../nav/group/subHelper.service.js');

            require('../nav/image/nav_image.controller.js');
            require('../nav/image/nav_image.directive.js');

            require('../nav/text/nav_text.controller.js');
            require('../nav/text/nav_text.directive.js');

            require('../nav/title/nav_title.controller.js');
            require('../nav/title/nav_title.directive.js');

            require('../nav/link/nav_link.controller.js');
            require('../nav/link/nav_link.directive.js');

            require('../nav/appid/nav_appid.controller.js');
            require('../nav/appid/nav_appid.directive.js');
            require('../nav/unordered_list/nav_unordered_list.controller.js');
            require('../nav/unordered_list/nav_unordered_list.directive.js');


            require('../nav/column/nav_column.controller.js');
            require('../nav/column/nav_column.directive.js');
            //added for pdf to display in new tab
            // require('../services/documentDetail.service.js');
            // require('../components/pdf/pdfService.service.js');
            require('../components/pdf/pdfController.controller.js');

            // require('../components/pdf/planDocPdf.controller.js');
 }
 
})();

},{"../components/content/content.controller.js":1,"../components/debug/debugController.controller.js":2,"../components/disclaimer/disclaimer.controller.js":3,"../components/footer/footer.controller.js":4,"../components/medicare/medicareCountySelection.controller.js":5,"../components/medicare/plansList.Controller.js":6,"../components/menu/newMenu.controller.js":7,"../components/pdf/pdfController.controller.js":8,"../components/publicProvider/compareController.controller.js":9,"../components/publicProvider/customPlanFilter.filter.js":10,"../components/publicProvider/directoryLastupdated.controller.js":11,"../components/publicProvider/planSelection.controller.js":12,"../components/publicProvider/providerDetails.controller.js":13,"../components/publicProvider/providerResults.controller.js":14,"../components/publicProvider/providerSearch.controller.js":15,"../components/publicProvider/toArray.filter.js":16,"../components/publicProvider/unicodeEscape.filter.js":17,"../components/topchrome/topchromeNew.controller.js":18,"../nav/appid/nav_appid.controller.js":25,"../nav/appid/nav_appid.directive.js":26,"../nav/application/nav_application.controller.js":27,"../nav/application/nav_application.directive.js":28,"../nav/box_header/nav_box_header.controller.js":29,"../nav/box_header/nav_box_header.directive.js":30,"../nav/column/nav_column.controller.js":31,"../nav/column/nav_column.directive.js":32,"../nav/group/nav_group.controller.js":33,"../nav/group/nav_group.directive.js":34,"../nav/group/subHelper.service.js":35,"../nav/image/nav_image.controller.js":36,"../nav/image/nav_image.directive.js":37,"../nav/link/nav_link.controller.js":38,"../nav/link/nav_link.directive.js":39,"../nav/text/nav_text.controller.js":40,"../nav/text/nav_text.directive.js":41,"../nav/title/nav_title.controller.js":42,"../nav/title/nav_title.directive.js":43,"../nav/unordered_list/nav_unordered_list.controller.js":44,"../nav/unordered_list/nav_unordered_list.directive.js":45,"../services/analytics.service.js":46,"../services/brandingLogo.service.js":47,"../services/common.directive.js":48,"../services/commonUtils.service.js":49,"../services/compareProviders.service.js":50,"../services/content.service.js":51,"../services/contentIdList.service.js":52,"../services/format.filter.js":53,"../services/googleMaps.service.js":54,"../services/languageData.service.js":55,"../services/navSpinner.service.js":56,"../services/page_builder.service.js":57,"../services/pdf.service.js":58,"../services/planList.service.js":59,"../services/ratings.service.js":60,"../services/results.service.js":61,"../services/reviews.service.js":62,"../services/searchCritera.service.js":63,"./app.route.js":20,"./app.run.js":21,"./constants.js":22,"./i18n.js":23,"./logging.provider.js":24,"jquery":64}],20:[function(require,module,exports){
(function() {

	angular.module('nav-ui').config(configRoutes)
	// This will load the service right at the beginning.
	// No controller needs to inject this service as its already loaded at the
	// beggining.
	// .run(function ($rootScope,logoutService,commonJsFunctionService){
	// $rootScope.logoutService = logoutService;
	// $rootScope.commonJsFunctionService = commonJsFunctionService;
	// });

	angular
			.module('nav-ui')
			.config(
					[
							'$httpProvider',
							function($httpProvider) {

									    // var interceptor = [function() {
									    //     return {
									    //         'request': function(config) {
									    //             if (config.url.indexOf('ApiHandler') > -1 || config.url.indexOf('json') > -1) {
									    //                 config.headers['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';
									    //                 config.headers['Cache-Control'] = 'no-cache';
									    //                 config.headers['Pragma'] = 'no-cache';
									    //             }
									    //             return config;
									    //         }
									    //     };
									    // }];
											//
									    // $httpProvider.interceptors.push(interceptor);

								// initialize get if not there
								if (!$httpProvider.defaults.headers.get) {
									$httpProvider.defaults.headers.get = {};
								}
								// disable IE ajax request caching
								$httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';
								// extra
								$httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';
								$httpProvider.defaults.headers.get['Pragma'] = 'no-cache';
							} ]);

	configRoutes.$inject = [ '$stateProvider', '$urlRouterProvider',
			'configuration', '$localStorageProvider', '$sessionStorageProvider' ];
	function configRoutes($stateProvider, $urlRouterProvider, configuration,
			$localStorageProvider, $sessionStorageProvider) {

		/** Ngstorage - Setting up local storage & sessionStorage prefix */
		$localStorageProvider.setKeyPrefix('nav');
		$sessionStorageProvider.setKeyPrefix('nav');

		/** initialize logging* */
		// LoggingServiceProvider.init(configuration);


		$urlRouterProvider.otherwise(function($injector, $location){
			var state = $injector.get('$state');
			var path = $location.path();
			path = path.slice(1,path.length);
				if(path != "contentPage" && path != "disclaimerPage"){
					if(state.params.site_id !== undefined){
						state.go('leavingPage',{page:'leavingPage',language:'en',site_id:state.params.site_id});
					}else{						
						state.go('leavingPage',{page:'leavingPage',language:'en',site_id:'dse'});
					}
				} else {		
					// alert("Please ignore this alert. Debug for $urlRouterProvider.otherwise");		
					state.go('contentPage',{page:'providerSearchLanding',site_id:'dse',language:'en'});
				}
				return $location.path();
		 });

	
		//For short custom URLs
		var customSiteIdList= configuration.customSiteIds;
		$urlRouterProvider.rule(function ($injector, $location) {
				var isSiteId = false;
				var path = $location.path();
				path = path.slice(1,path.length);
				for(var index in customSiteIdList){
					if (path == customSiteIdList[index]) {
						// alert("Please ignore this alert. Debug for short URL");
						return "/contentPage?page=providerSearchLanding&site_id="+path+"&language=en";
					}
				}
	    });

		// $locationProvider.hashPrefix(''); // Added while upgrading

		 $stateProvider
		    .state('mainlayoutWithHC', {
		   	abstract : true,
		     parent : 'root',
		     views: {
		       '' : {
		       	templateUrl: 'components/layout/layoutHeaderContent.html'
		     	},
		     	'topchromeNew@mainlayoutWithHC' : {
		     		templateUrl: 'components/disclaimer/disclaimer_header.html'
		     	},

		     	'content@mainlayoutWithHC' : {
		     		templateUrl: 'components/content/content.html'
		     	}
		   	}
		   });

		$stateProvider
				.state('root', {
					abstract : true,
					template : '<div ui-view></div>'
				})
				.state(
						'mainlayoutWC',
						{
							abstract : true,
							parent : 'root',
							views : {
								'' : {
									templateUrl : 'components/layout/layoutWithChrome.html'
								},
								'topchromeNew@mainlayoutWC' : {
									//templateUrl : 'components/topchrome/topchromeNew.html'
									templateUrl : 'components/topchrome/topchromeNewPage.html',
									controller : 'TopchromeControllerNew',
									controllerAs : 'topchromeCtrlNew'
								},
								'newMenu@mainlayoutWC' : {
									//templateUrl : 'components/menu/newMenu.html'
									templateUrl : 'components/menu/newMenuPage.html',
									controller : 'newMenuController',
									controllerAs : 'newMenuCtrl'
								},
								'content@mainlayoutWC' : {
									templateUrl : 'components/content/content.html'
								},
								'footer@mainlayoutWC' : {
									//templateUrl : 'components/footer/footer.html'
									templateUrl : 'components/footer/footerPage.html',
									controller : 'FooterController',
									controllerAs : 'footerCtrl'
								}
							}
						})
				.state(
						'contentPage',
						{
							url : '/contentPage?page&parameters&searchTerm&providerF&providerL&facilityInd&site_id&language&proId&locId&distance&pType&hosId&hosName'+
								'&proOrgName&proOrgDispName&poin&groupProId&id&planValue&year&category&RETURN_URL&debug&assocProvSrchGrp&ZipCode&useNewBypassMethod',
							parent : 'mainlayoutWC',
							views : {
								'centercontent' : {
									templateUrl : 'components/content/contentPage.html',
									controller : 'ContentController',
									controllerAs : 'contentCtrl'
								}/*,
								'topChromeContent' : {
									templateUrl : 'components/topchrome/topchromeNewPage.html',
									controller : 'TopchromeControllerNew',
									controllerAs : 'topchromeCtrlNew'
								},
								'newMenuContent' : {
									templateUrl : 'components/menu/newMenuPage.html',
									controller : 'newMenuController',
									controllerAs : 'newMenuCtrl'
								},
								'footerChromeContent' : {
									templateUrl : 'components/footer/footerPage.html',
									controller : 'FooterController',
									controllerAs : 'footerCtrl'
								}*/
							}
						})
		$stateProvider
				.state(
					'disclaimerPage',
					{
						url : '/disclaimerPage?page&parameters&language&storeURL&site_id',
						parent : 'mainlayoutWithHC',
						views : {
							'centercontent' : {
								templateUrl : 'components/content/contentPage.html',
								controller : 'ContentController',
								controllerAs : 'contentCtrl'
							}
						}
					})
				.state(
						'leavingPage',
						{
							url : '/leavingPage?page&language&site_id',
							parent : 'mainlayoutWithHC',
							views : {
								'centercontent' : {
									templateUrl : 'components/content/contentPage.html',
									controller : 'ContentController',
									controllerAs : 'contentCtrl'
								}
							}
						})
				.state('openPDF', {
					      	url: '/openPDF?code',
					      parent : 'mainlayoutWithHC',
						  views: {
					     		'centercontent': {
					          	templateUrl: 'components/pdf/openPdf.html',
					          	controller: 'PDFController',
					          	controllerAs: 'pdfCtrl'
					          }
					        }
					      })
					      .state('debugAPI', {
					    	  url: '/debugAPI',
					    	  parent : 'mainlayoutWithHC',
					    	  views: {
					    		  'centercontent': {
					    			  templateUrl: 'components/debug/providerDebug.html',
					    			  controller: 'DebugController',
					    			  controllerAs: 'debugCtrl'
					    		  }
					    	  }
					      }).state('ocr', {
					    	  url: '/ocr',
					    	  parent : 'mainlayoutWithHC',
					    	  views: {
					    		  'centercontent': {
					    			  templateUrl: 'components/ocr/ocr.html',
					    			  controller: 'OCRController',
					    			  controllerAs: 'OCRController'
					    		  }
					    	  }
					      });;

	}
})();

},{}],21:[function(require,module,exports){
(function() {

    angular
  	.module('nav-ui')
  	.run(function($rootScope, AnalyticsService) {
  	//.run(function() {
        $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams, options) {
            $rootScope.$broadcast("destroyScope");
        });
        var history=[];
        $rootScope.$on('$locationChangeSuccess', function(event, newUrl, oldUrl) {
            history.push(oldUrl);
            AnalyticsService.trackLocation(event, newUrl);
            $rootScope.prevUrl=history.length>1? history.splice(-1)[0]:"/";
        });
  	});

})();

},{}],22:[function(require,module,exports){
angular.module("deploy", [])

.constant("configuration", {
	"debugEnabled": "true",
	"debugPlanInfo": "false",
	"currentEnvironment": "http://www.aetna.com/dsepublic/",
	"didYouMeanUrl": "https://api2.talix.com/api/service/2.0/docfind?partnerId=bf78eecc-f663-4eaa-bb1e-7992e8510c8a",
	"enrollmentLinkPlanPage": "https://member.aetna.com/MbrLanding/RoutingServlet?createSession=true&serviceName=home&navDeepLink=BENEFITSUMMARYLNK",
	"idLinkPlanPage": "https://member.aetna.com/MbrLanding/RoutingServlet?createSession=true&serviceName=home&navDeepLink=IDCARDLNK",
	"printDirectoryURL": "http://www.aetna.com/docfind/home.do?site_id=docfind&langpref=en&tabKey=tab5&fromDse=fromDse",
	"loggingDecorator": "info:false,debug:true,warn:true,error:true",
	"pageDataUrl": "http://www.aetna.com/PublicPageContent/provider/v1/publicdse_pagecontent",
	"publicPageContentAPIURL": "http://www.aetna.com/PublicPageContent/provider/v1/publicdse_pagecontent?",
	"publicPageContentHTTPSAPIURL": "https://www.aetna.com/PublicPageContent/provider/v1/publicdse_pagecontent?",
	"publicPageContentAPICURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_pagecontent?",
	"publicPageContentClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalPublicPageContentAPICURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_pagecontent?",
	"externalPublicPageContenCliendId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"planListAPIURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_productcodes?",
	"planListAPIURLClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalPlanListAPIURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_productcodes?",
	"externalClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"providerSearch": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_providersearch?",
	"providerSearchClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalProviderSearch": "https://api2.aetna.com/healthcare/prod/v3/publicdse_providersearch?",
	"ProviderDetailsIndividualURL": "https://api2.aetna.com/healthcare/prodint/navigator/v3/publicdse_providerdetails/publicdse_individualproviderdetails?",
	"ProviderDetailsHospitalURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_hospitalproviderdetails?",
	"ProviderDetailsOrganizationURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_organizationalproviderdetails?",
	"providerDetailsClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalProviderDetailsIndividualURL": "https://api2.aetna.com/healthcare/prod/navigator/v3/publicdse_providerdetails/publicdse_individualproviderdetails?",
	"externalProviderDetailsHospitalURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_hospitalproviderdetails?",
	"externalProviderDetailsOrganizationURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_organizationalproviderdetails?",
	"publicPlanDetailsPleatAPIURL": "https://api2.aetna.com/healthcare/prodint/v3/providers/PROIDTempToBeFilled/providerplanandnetworkdetails/",
	"publicPlanDetailsPleatClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"publicPlanDetailsPleatSecretKey": "S2fP8lR1kN4uR5eV0gT3eV0fE7qS1xT4wT7bU5xY6vV3vD7oF8",
	"externalPublicPlanDetailsPleatAPIURL": "https://api2.aetna.com/healthcare/prod/v3/providers/PROIDTempToBeFilled/providerplanandnetworkdetails/",
	"externalPublicPlanDetailsPleatClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalPublicPlanDetailsPleatSecretKey": "S2fP8lR1kN4uR5eV0gT3eV0fE7qS1xT4wT7bU5xY6vV3vD7oF8",
	"ProviderRatingsServiceURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_providerratings?systemID=0615DSEpublic&",
	"ProviderRatingsServiceClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalProviderRatingsServiceURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_providerratings?systemID=0615DSEpublic&",
	"externalProviderRatingsServiceClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"providerReviewsServiceURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_providers/{id}/reviews?systemID=0615DSEpublic&maxNumReviewsRequested={maxNoOfReviewsExpected}",
	"providerReviewsServiceURLClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalProviderReviewsServiceURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_providers/{id}/reviews?systemID=0615DSEpublic&maxNumReviewsRequested={maxNoOfReviewsExpected}",
	"externalProviderReviewsServiceURLClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"acoPdfAPIURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_networkinfolink?category=",
	"acoPdfAPIClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalACOPdfAPIURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_networkinfolink?category=",
	"externalACOpdfClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"brandingLogoSwitch": true,
	"brandingLogoURL": "https://api2.aetna.com/healthcare/prodint/publicdse_brandings?",
	"externalBrandingLogoURL": "https://api2.aetna.com/healthcare/prod/publicdse_brandings?",
	"brandingLogoClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"reportIncorrectInfo": "https://www.aetna.com/dsepublicContent/assets/html/data_correction.html",
	"typeAheadUrl": "https://api2.talix.com/api/service/2.0/docfindtypeahead?partnerId=bf78eecc-f663-4eaa-bb1e-7992e8510c8a",
	"PublicCountiesServiceURL": "https://api2.aetna.com/healthcare/prodint/v3/publicdse_counties?",
	"PublicCountiesServiceClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"externalPublicCountiesServiceURL": "https://api2.aetna.com/healthcare/prod/v3/publicdse_counties?",
	"externalPublicCountiesServiceClientId": "92e66fe9-52de-4cf3-8966-5860450c4f56",
	"perfectoSwitch": true,
	"debugPNIPleatInfo": false,
	"ignoredSymbolsPlanPage": [
		"(",
		")",
		"\\",
		"/",
		",",
		"#"
	],
	"backURLResults": "/dsepublic/#/contentPage?page=providerResults",
	"customSiteIds": [
		"1199seiu",
		"aahc",
		"aahe",
		"accenture",
		"aetnadentalaccess",
		"aetnainc",
		"ahs",
		"alaskacare",
		"aldinebenefits",
		"alegentcreighton",
		"allinahealthaetna",
		"allinahealthaetna1",
		"allinahealthaetna2",
		"allinahealthaetnamdcr",
		"allstate",
		"amex",
		"amgen",
		"apcnplusplans",
		"arhs",
		"asa",
		"asaapn",
		"avp",
		"awca",
		"bankofamerica",
		"banneraetna",
		"banneraetna1",
		"banneraetna2",
		"banneraetna4",
		"baptistmemorial",
		"bechtel",
		"bmcs",
		"bn",
		"boeing",
		"bombardier",
		"bp",
		"brodart",
		"bronzeplan",
		"bshsi",
		"bSwift",
		"carilion",
		"chooseandsaveoe",
		"chop",
		"cityofsanangelo",
		"cityofseattle",
		"compassgroup",
		"conocophillips",
		"cookeville",
		"cornell",
		"costco",
		"costcoprogram",
		"covahealthaware",
		"cox",
		"customdirectlink",
		"dc",
		"delhaize",
		"DirectLink",
		"directlinklogo",
		"DirectLinkDental",
		"DirectLinkIH",
		"directlinknologin",
		"docfind",
		"dse",
		"dsemarriott",
		"dukeuniversity",
		"dummy",
		"echn",
		"emory",
		"emorycore",
		"erika",
		"es",
		"example",
		"exelon",
		"exelon1",
		"exelon2",
		"fairfaxcountyps",
		"farmersagents",
		"fehbp",
		"firstam",
		"foxentertainment",
		"fsbp",
		"grainger",
		"gsk",
		"hca",
		"hermanmiller",
		"hisdbenefits",
		"holyname",
		"homedepot",
		"hospira",
		"icahnmedicalschool",
		"ilcommunitynetwork",
		"ingalls",
		"innovationhealth",
		"innovationhealthmdcr",
		"inova",
		"ivl",
		"jax",
		"jnj",
		"katybenefits",
		"lmc",
		"lrh",
		"lubbockcounty",
		"LUH",
		"marriott",
		"mars",
		"medicare",
		"medmutual",
		"MedrxDirectLink",
		"meritus",
		"mhbp",
		"mmc",
		"mymeritain",
		"narrowdirectlink",
		"nmhc",
		"nordstrom",
		"northshore",
		"nrg",
		"nvenergy",
		"nxp",
		"nyl",
		"pasadenaisd",
		"passport",
		"passportapn",
		"pebtf",
		"portauth",
		"princeton",
		"progressive",
		"provider",
		"providerexchange",
		"rcbp",
		"rei",
		"rhagroup",
		"ruralppomp",
		"saintpeters",
		"samba",
		"shc",
		"sjhs",
		"sony",
		"soundhealth",
		"statede",
		"statenj",
		"stateofkansas",
		"stateofmaine",
		"studenthealth",
		"sutterexclude",
		"sutterhealthaetna",
		"sutterhealthaetna1",
		"sw",
		"tdbank",
		"texashealth2",
		"texashealthaetna",
		"texashealthaetna1",
		"thecheesecakefactory",
		"thedowchemicalcompany",
		"trinity",
		"trp",
		"trsactivecare",
		"trscare",
		"tyco",
		"ubsfinancial",
		"uchp",
		"united",
		"universityofmiami",
		"universityofrochester",
		"uva",
		"ValleyHealth",
		"valleyhealthsystem",
		"vanderbilt",
		"vanguard",
		"virtua",
		"walmart",
		"walmart1",
		"walmart2",
		"wcmc",
		"wellstar",
		"yaleuniversity"
	],
	"dseWSUrlPlanList": "http://www30.aetna.com/dseWS/search/service/listOfPlans/v1p?debug=true&",
	"externalReportIncorrectAPIURL": "https://apih1.aetna.com/healthcare/prod/v3/salesforcecase",
	"internalReportIncorrectAPIURL": "https://apih1.int.aetna.com/healthcare/prod/v3/salesforcecase",
	"externalTokenAPIURL": "https://apih1.aetna.com/healthcare/prod/v5/privapp/auth/oauth2/token",
	"internalTokenAPIURL": "https://apih1.int.aetna.com/healthcare/prod/v5/privapp/auth/oauth2/token",
	"tokenAPIClientID": "e8f22adb-7047-439b-866a-3d1513a2e753",
	"tokenAPISecretKey": "hE7pB6mW0tI0fB1rW3qH5hJ7sT7gF3wU5bN4xI3vU3xK1eK6nU",
	"tokenAPIScope": "APPPII APPPHI",
	"tokenAPIGrantType": "client_credentials"
})

;
},{}],23:[function(require,module,exports){
(function() {

var app = angular.module('nav-ui');

app.config(['$translateProvider', function ($translateProvider) {
	// languages are located on web server as JSON files
	$translateProvider.useStaticFilesLoader({
		prefix: 'locale_',
		suffix: '.json',
		$http: {
			method: 'GET'
		}
	});
	
	// site always defaults to English and must be changed by user
	$translateProvider.preferredLanguage('en');

	// If an item hasn't been translated into a different language, the English version will be used
	$translateProvider.fallbackLanguage('en');

	// handle special Spanish characters via html entities
	// currently, sanitize causes problems with special characters when
	// using the translate filter.
	//$translateProvider.useSanitizeValueStrategy('sanitize');
	 
	//it will work for special character also
	///Java source code use Java source code
	$translateProvider.useSanitizeValueStrategy(null);

}]);

})();

},{}],24:[function(require,module,exports){
(function(){
	angular
	.module('nav-ui')
	.provider('LoggingService', LoggingService);


	LoggingService.$inject = ['$provide','$logProvider'];

	this.$get = function () {  

		return {} ;

	}; 


	function LoggingService($provide,$logProvider){

		function init(configuration){

			//Configure Logging based on a config parameter. 
			if(configuration !=null && configuration.debugEnabled =="true")
				$logProvider.debugEnabled(true);
			else 
				$logProvider.debugEnabled(false);


			//** DEcorator for Logging **//
			$provide.decorator('$log', ['$delegate', function ($delegate) {

				var originals = {};
				var methodsArgs = configuration.loggingDecorator.split(",");
				
				angular.forEach(methodsArgs , function(methodArg)
						{
					var ag = methodArg.split(":");
					var method = ag[0];
					var enabled = ag[1];
					originals[method] = $delegate[method];
					$delegate[method] = function()
					{
						if ('true' == enabled) {
							var args = [].slice.call(arguments);
							var timestamp = new Date().toString();
							args[0] = [timestamp.substring(4 , 24), ': ', args[0]].join('');
							originals[method].apply(null , args);
						}
					};
						});

				return $delegate;
			}]);
		}
		return {
			init: init,
			$get :$get
		};	
	}
})();
},{}],25:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavAppidController', NavAppidController);

  NavAppidController.$inject = ['$scope', '$element', '$attrs', '$compile', '$rootScope', 'PageBuilderService','$sce'];

  function NavAppidController($scope, $element, $attrs, $compile, $rootScope, PageBuilderService,$sce) {
  	var node = PageBuilderService.getNodeInfo($attrs.id);
  	var parent = PageBuilderService.getNodeInfo($attrs.parent);
    
    //NMD added
    var ESAPI = require('node-esapi');
    var showPaypremiumPopup='false';
  	var hasLinkLabel = 'false';
  	if(node.attributeMap && node.attributeMap['function']){
  		var callingFunction = node.attributeMap['function'];
		$element[0].href = 'javascript:' + callingFunction + '();';
	}
  	
  	if (node.childNodeList) {
		for (var i = 0; i < node.childNodeList.length; i++) {		
			var childNode = node.childNodeList[i];
			switch (childNode.nodeName) {
  			case 'label':
  				if(childNode.nodeValue){
					hasLinkLabel = 'true';
					if(node.attributeMap && node.attributeMap['function'] == 'prvTitleBarMenu')
					{
						var htmlForProvider = '<a href="#" id="usrIcon" class="aet-cont-hdrtxt">'+childNode.nodeValue + '<span class="user-iconInactive"></span></a>';
						$element.html(htmlForProvider);
					}
					else if(node.attributeMap && node.attributeMap['function'] == 'popupBrowserWindow')
					{
	  					//$element[0].childNodes[0].innerHTML = ESAPI.encoder().encodeForHTML( childNode.nodeValue );
	  					$element.append(childNode.nodeValue);
	  				
					}
					else if(node.attributeMap && node.attributeMap['function'] == 'webApplicationContent')
					{
					//	Do not add any label for 'appID function=webApplicationContent'
					}
					/*else if(node.attributeMap && node.attributeMap['function'] == 'homePopupBrowserWindow')
					{
						var $parent1	=	angular.element($element.parent());
						var $parent2	=	angular.element($parent1.parent());
						$parent1.addClass('sponsor_links');
						$parent2.addClass('col-md-3 col-xs-12 pad0');
						$element.html(childNode.nodeValue);
					}*/
					else if(node.attributeMap && node.attributeMap['function'] == 'pharmacyTab')
					{
						var temp = $element[0].id.split("_"); 
						var pharmacyCounter = "appid_"+(temp[1]-4);
						var idForPharmacy = childNode.nodeValue.split(" ");
						if($('#'+pharmacyCounter).length != 1) {
							$element[0].className = 'col-md-3 col-xs-3 phar-tab-block active';
						}
						else {
							$element[0].className = 'col-md-3 col-xs-3 phar-tab-block';
						}
						var anchorTag = document.createElement("A");
						var spanTag = document.createElement("SPAN");
						anchorTag.className = "";
						anchorTag.id = "ctab_"+temp[1];
						anchorTag.href = "javascript:onClickRedirect($element[0].id, idForPharmacy[0])";
						anchorTag.setAttribute("data-toggle", "tab");
						anchorTag.onclick = function() {onClickRedirect($element[0].id, childNode.nodeValue)};
						spanTag.className = "mail-tab-txt mail-order-txt";
						spanTag.id = "ctext_"+temp[1];
						spanTag.textContent = childNode.nodeValue;
						anchorTag.appendChild(spanTag);
						$element.html(anchorTag);
						if(idForPharmacy[0] == "Overview") {
							$("#Overview").addClass("active in");
						}
						else if(idForPharmacy[0] == "Mail-Order") {
							spanTag.className += " mail-order-phar";
						}
						else if(idForPharmacy[0] == "Specialty") {
							spanTag.className += " specialty-txt";
						}
					}
					else
					{
						$element.html(childNode.nodeValue);
						
					}
					
				}	
  				break;
  			case 'url':  	
  				if(node.attributeMap['function'] == 'popupBrowserWindow')
				{
  					//$element[0].childNodes[0].href = childNode.nodeValue;
  					//$element[0].childNodes[0].target = '_blank';
	 					$element[0].href = childNode.nodeValue;
  					if (childNode.nodeValue.indexOf("showDisclaimer") < 0 && childNode.nodeValue.indexOf("getFeatureURL") < 0) {
	 						$element[0].target = '_blank';
  					}
  					if(window.location.href.indexOf("directoryAndResources") !== -1 || window.location.href.indexOf("qualityAndCostInfo") !== -1 ||
  					      window.location.href.indexOf("savingsAndDiscounts") !== -1 || window.location.href.indexOf("importantInfo") !== -1){
  							$element.attr('class', 'normalFont');
  					        $element.parent().attr('class','marB10');
  					        $element.attr('target', '_blank');
  				}
				}
				else if(node.attributeMap && node.attributeMap['function'] == 'pharmacyTab')
				{
					$element[0].childNodes[0].href = childNode.nodeValue;
  					$element[0].childNodes[0].target = '_self';
				}
				break;
  			case 'title':  	
  				if(node.attributeMap['function'] == 'popupBrowserWindow')
				{
  					//$element[0].childNodes[0].title = childNode.nodeValue;
  					$element[0].title = childNode.nodeValue;
				}
					
				break;
			
  			case 'image':  	
  				if(node.attributeMap['function'] == 'popupBrowserWindow')
					{
						if(node.attributeMap.style=='planSponserAppid'){
							//do code for style planSponserAppid only
						}
						else{
							$element.append(PageBuilderService.processNodeIndividually(childNode.nodeName, childNode));
						}	
					}
					
				break;

  			default:
  					break;
			}
			/*if(childNode.nodeName == 'label'){
				if(childNode.nodeValue){
					hasLinkLabel = 'true';
					if(node.attributeMap['function'] == 'prvTitleBarMenu')
					{
						var htmlForProvider = '<a href="#" id="usrIcon" class="aet-cont-hdrtxt">'+childNode.nodeValue + '<span class="user-iconInactive"></span></a>';
						$element.html(htmlForProvider);
					}					
					else
					{
						$element.html(childNode.nodeValue);
					}
					
				}	
				
			}*/
		}
	}
  	
  	if (node) {
		  switch (node.attributeMap && node.attributeMap['function']) {
			  case 'prvTitleBarMenu':
				  $element.addClass('pull-right');				
				  $element.wrap("<div id='aet-content-hdrtxttwo' class='openchangeplan aet-content-hdrtxt'>");
				  break;
			  case 'webApplicationContent':
				  processWebApplicationContent(node,$sce);
				  break;
			  case 'autoCopyright':
				  autoCopyright();
				  break;  
			  default:
				  break;
		  }
		
		switch(node.attributeMap && node.attributeMap.style){
			case 'planSponserAppid':
				var $parent1	=	angular.element($element.parent());
				var $parent2	=	angular.element($parent1.parent());
				$parent1.addClass('sponsor_links');
				$parent2.addClass('col-md-3 col-xs-12 pad0 marT10 setHeight40');				
			break;
		};
		
		  if(parent && parent.nodeName.indexOf("column") > -1 )
		  {
		  		var $parentDiv = angular.element(document.getElementById($attrs.parent));
		  	  	var $secondChild = angular.element($parentDiv.children()[1]);
		  	  	$secondChild.append($element);
		  	  	$compile($secondChild)($rootScope);
		  		
		  }
	  }

    function processWebApplicationContent(node,$sce){
      /*if(parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == "tab"){
    	  if(parent.attributeMap.name){
    		  switch (parent.attributeMap.name) {
				case 'medicals':
					$element.addClass('coverage-result-div');
					$element.find('.controller').addClass('aet-content-fluid');
					break;
				case 'dentals':					
					$element.addClass('coverage-result-div bottom-top');
					$element.find('.controller').addClass('aet-content-fluid');
					break;
				case 'behavioral':					
					$element.addClass('coverage-result-div bottom-top');
					$element.find('.controller').addClass('aet-content-fluid');
					break;
				case 'pharmacy':					
					$element.addClass('coverage-result-div bottom-top');
					$element.find('.controller').addClass('aet-content-fluid');
					break;
				case 'additional_coverage':					
					$element.find('.controller').addClass('aet-content-fluid');
					break;	
				default:
					break;	
			}
    	 }
      }*/
     
      if (node.childNodeList) {
      var cacheBuster=Date.now().toString();
  	    for (var i = 0; i < node.childNodeList.length; i++) {
  		    var childNode = node.childNodeList[i];
  		  
 				  switch (childNode.nodeName) {
 					  case 'uniqueidentifier':
 					    //$element.find('.controller').attr('ng-controller', childNode.nodeValue);
 					    break;
 					  case 'url':
 						var cacheBuster=getParameterByName('v',$('script[src*="?v="]')[0].src);
 						var finalUrl= childNode.nodeValue;
 						if(finalUrl && finalUrl.indexOf("?")==-1){
 							finalUrl=finalUrl+"?v="+cacheBuster;
 						}  
 					    var pageInclude = "'" + finalUrl +"" + "'";
 					    $element.find('.controller').attr('src', pageInclude);
 					    $element.find('.controller').attr('ng-include',"");
 					    
 					    if(node.attributeMap.parameters!=null)
 					    {
 					      var params = decodeURIComponent(node.attributeMap.parameters);
						  try{
							  params = $sce.getTrustedResourceUrl(params);
							  if(params.indexOf("<")!= -1)
							  {
								   var doc = new DOMParser().parseFromString(params, 'text/html');
									params =  doc.body.textContent || "";
							  }
								  
						  }
						  catch(e)
						  {
							  //error occured. Try removin all html characters
							  var doc = new DOMParser().parseFromString(params, 'text/html');
							  params =  doc.body.textContent || "";
						  }
 					      $element.find('.controller').attr('ng-init',params);
 					    }
 					    
 					    break;
          }
  		  }
  		  
  		  $compile($element)($scope);
      }
    }
    
    //Appid related functions.
    function autoCopyright() {
	  	var currentDate = new Date();
	  	var fullYear = currentDate.getFullYear();
	  	var hostNameString = location.href;
	  	
	  	var copyrightText = 'Copyright &copy; 2001-' + fullYear + ' Aetna Inc.';
  
  		if(hostNameString.indexOf("site_id=innovationhealthmdcr") > -1){
          copyrightText = 'Copyright &copy; ' + fullYear + ' Innovation Health Insurance Company and Innovation Health Plan, Inc.';
		}
		else if(hostNameString.indexOf("site_id=texashealthaetna") > -1){
          copyrightText = 'Copyright &copy; 2001-' + fullYear + ' Aetna Inc.';
		}
		else if(hostNameString.indexOf("site_id=banneraetna") > -1){
          copyrightText = 'Copyright &copy; 2001-' + fullYear + ' Aetna Inc.';
		}
		else if(hostNameString.indexOf("site_id=allinahealthaetnamdcr") > -1){
          copyrightText = 'Copyright &copy; ' + fullYear + ' Allina Health and Aetna Insurance Company';
		}
		else if(hostNameString.indexOf("site_id=sutterhealthaetna") > -1){
          copyrightText = 'Copyright &copy; 2001-' + fullYear + ' Aetna Inc.';
		}
		else{
          copyrightText = 'Copyright &copy; 2001-' + fullYear + ' Aetna Inc.';
		}
  
         $element.html(copyrightText);
         $element.addClass('aet-copyrights');
}
    
    function getParameterByName(name, url) {
	    if (!url) url = window.location.href;
	    name = name.replace(/[\[\]]/g, "\\$&");
	    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
	        results = regex.exec(url);
	    if (!results) return null;
	    if (!results[2]) return '';
	    return decodeURIComponent(results[2].replace(/\+/g, " "));
	}

  }
  
})();
function onClickRedirect (idClicked, idReq) {
	var temp = idClicked.split("_");
	var elem = $('#'+idClicked);
	if($('.phar-tab-block').hasClass("active")) {
		$('.phar-tab-block').removeClass("active");
	}
	elem.addClass("active");
	if($('.phar-tab-elem').hasClass("active in")) {
		$('.phar-tab-elem').removeClass("active in");
	}
	var spanTag = $('#ctext_'+temp[1]);
	//anchorTag.className += " active";
	//anchorTag.href = '#Specialty';
	if(idReq == "Overview") {
		$("#Overview").addClass("active in");
		spanTag.className += " ";
	}
	else if(idReq == "Prescriptions") {
		$("#Prescription").addClass("active in");
		spanTag.className += " ";
	}
	else if(idReq == "Orders") {
		$("#Orders").addClass("active in");
		spanTag.className += " specialty-txt";
	}
	else if(idReq == "Account Info") {
		$("#AccountInfo").addClass("active in");
	}
}
},{"node-esapi":65}],26:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navAppid', navAppid);
    navAppid.$inject = [ '$compile'];
  	function navAppid($compile) {
  		
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: function(element, attrs){
    	  	var template = '';
    	  	var template1 = '<a></a>';
    	  	var template2 = '<div></div>';
    	  	var template3 = '<button class="primaryBtn"></button>';
    	  	var template4 = '<li><a></a></li>';
    	  	var template5 = '<div><div class="controller" src=""></div></div>';
	    	  switch(attrs.functionname){
	    	  case 'prvTitleBarMenu':
	            template = template2;
	            break;
	    	  case 'autoCopyright':
		        template = template2;
		        break;  
	          case 'myHealthCare':
	            template = template3;
	            break;	    
		        case 'popupBrowserWindow':
	            template = template1;
	            break;
		      case 'pharmacyTab':
		            template = template4;
		            break;  
	          case 'webApplicationContent':
	            template = template5;
	            break;	    
	          default:
	            template = template1;
	            break;
	    		  };
 	        return template;
 	      },
    	    
    	  controller: 'NavAppidController'
      };  		
  	};
})();
},{}],27:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.controller('NavApplicationController', NavApplicationController);

	NavApplicationController.$inject = ['$scope', '$element', '$attrs', 'PageBuilderService', '$rootScope', '$sessionStorage', '$location', '$window','$state', 'CommonUtilsService'];

	function NavApplicationController($scope, $element, $attrs, PageBuilderService, $rootScope, $sessionStorage, $location, $window, $state, CommonUtilsService) {
		var node = PageBuilderService.getNodeInfo($attrs.id);
		//setting Application title
		$rootScope.appTitle="";
		var planValue = '';
		var nodeArray = [];
		//to detect completion of async call of newNavigation.xml and contentpageAPI(used for $watch).
		$scope.newNavBuildflg = false;
		// session storage breadcrumb Array.
		$sessionStorage.breadCrumArray = [];
		/*$scope.$back = function() {
		    window.history.back();
		 };*/

		 $scope.setDeviceType =function(){
				var w = $window.innerWidth;
				var h = $window.innerHeight;
				if (w > 992) {
					$scope.deviceType = "desktop";
				} else {
					$scope.deviceType = "mobile";
				}
		 }

		// function to get NodeDetails.
		getNodeDetails = function(nodeObject) {
			nodeObjectDtl = {
					label: '',
					url: '',
					navKey: '',
					group: '',
					displayUrl: 'false'
			};

			for (var y = 0; y < nodeObject.length; y++) {

				if (nodeObject[y].nodeName == 'label') {
					nodeObjectDtl.label = nodeObject[y].nodeValue;
				}
				if (nodeObject[y].nodeName == 'url') {
					nodeObjectDtl.url = nodeObject[y].nodeValue;
				}
				if (nodeObject[y].nodeName == 'navkey') {
					nodeObjectDtl.navKey = nodeObject[y].nodeValue;
				}
				if (nodeObject[y].nodeName == 'visiblity') {
					nodeObjectDtl.visiblity = nodeObject[y].nodeValue;
				}
			}
			return nodeObjectDtl;
		}
		// End of function to getDetails.

		// recursive function to travers Tree to get the node details of all child.
		var traversData = function(dataNode, parentNavkey) {

			var temp = dataNode.childNodeList;

			for (var j = 0; j < temp.length; j++) {
				var nodeObject = getNodeDetails(temp);
				nodeArray.push(nodeObject);

				if (temp[j].nodeName == "group") {
					nodeObject.group = temp[j].attributeMap.type;
					for (var k = 0; k < temp[j].childNodeList.length; k++) {
						// recursive function call - by passing child  node as parent
						traversData(temp[j].childNodeList[k], nodeObject.navKey);
						//get Child node details- title, url, parentNavKey  etc
						var childDetails = getNodeDetails(temp[j].childNodeList[k].childNodeList);
						childDetails.parentNavKey = nodeObject.navKey;
						//Storing node details inside array ( key as child node Nav key) and value as child node details with ParentNavKey
						navKeysArray[childDetails.navKey] = childDetails;
					}
				}
			}

		};
		// End function to travers Tree to get the node details of all child.

		// code to reach out to secondaryTab Menu
		if (node.attributeMap && node.attributeMap.type == 'navigation') {
			var navKeysArray = {};
			if (node.childNodeList != undefined) {
				//Check primaryMenu node
				if (node.childNodeList[1].nodeName == "group" && node.childNodeList[1].attributeMap.type == "primaryMenu") {
					if (node.childNodeList[1].childNodeList) {

						for (var l = 0; l < node.childNodeList[1].childNodeList.length; l++) {
							for (var x = 0; x < node.childNodeList[1].childNodeList[l].childNodeList.length; x++) {
								//Check secondaryTabMenu node
								if (node.childNodeList[1].childNodeList[l].childNodeList[x].nodeName == "group" && node.childNodeList[1].childNodeList[l].childNodeList[x].attributeMap.type == "secondaryTabMenu") {
									//Loop to traverse all secondaryTabMenus
									for (var subSecInd = 0; subSecInd < node.childNodeList[1].childNodeList[l].childNodeList[x].childNodeList.length; subSecInd++) {
										// To populate secondary menu details.
										var sunMenuDetails = getNodeDetails(node.childNodeList[1].childNodeList[l].childNodeList[x].childNodeList[subSecInd].childNodeList);
										sunMenuDetails.parentNavKey = "";
										navKeysArray[sunMenuDetails.navKey] = sunMenuDetails;
										// To populate child node details below secondaryTabMenu.By default parentNavKey will be 0 for secodaryTabMenu
										traversData(node.childNodeList[1].childNodeList[l].childNodeList[x].childNodeList[subSecInd], 0);
									}
								}
							}

						}
					}

				}

			}

			//console.log("local scoped-> collection of all nav keys from newNavigation.xml");
			// If navKeys array is not created then to store it in session storage.
			if (typeof $sessionStorage.navkeysArraySession == 'undefined' || !Object.keys($sessionStorage.navkeysArraySession).length) {
				$sessionStorage.navkeysArraySession = navKeysArray;
				//console.log("-------------------");
				//console.log($sessionStorage.navkeysArraySession);

				//Change the newNavBuildFlg to true as recoversive call completion of traverData
				$scope.newNavBuildflg = true;
			}

			// In case when language is changed replace only breadcrumb labels.
			if (typeof $sessionStorage.navkeysArraySession != 'undefined' && Object.keys($sessionStorage.navkeysArraySession).length &&
					navKeysArray != undefined && navKeysArray != 'undefined' && Object.keys(navKeysArray).length) {
				var sessionLabel = $sessionStorage.navkeysArraySession['P1W1'].label;
				var navKeysArrayLabel = navKeysArray['P1W1'].label;
				if(sessionLabel != '' && navKeysArrayLabel != '' && sessionLabel != navKeysArrayLabel){
					for(var i = 0; i <= Object.keys($sessionStorage.navkeysArraySession).length; i++){
						var navKey = Object.keys($sessionStorage.navkeysArraySession)[i];
						if(navKeysArray[navKey] != undefined)
							$sessionStorage.navkeysArraySession[navKey].label = navKeysArray[navKey].label;
					}
					$scope.newNavBuildflg = true;
				}
			}
		}

		// add class for attribute type footer and navigation
		if (node & node.attributeMap) {
			switch (node.attributeMap.type) {
			case 'footer':
				$element.addClass('aet-content-fluid');
				break;
			case 'navigation':
				$element.addClass('menu');
				break;
			default:
				break;
			}

		}

		//$sessionStorage.breadcrumbArray = [];
		if (node) {

			// Watch -To recall below code on change newNavBuildflg (mainly used for asyc call completion newNavigation and contentPageAPI)
			$scope.$watch('newNavBuildflg', function() {
				$sessionStorage.breadCrumArray = [];
				$sessionStorage.breadcrumbArray = [];
				//console.log("************************************************************************");
				if (node.attributeMap && (node.attributeMap.type == 'page' || node.attributeMap.type == 'boxpage')) {
					var navKey = node.attributeMap.navkey;
					//get Page navkey and store it in session storage
					$sessionStorage.navkey = angular.copy(navKey);

					//setting Application title

					if( navKey!="" && typeof navKey!="undefined" && $sessionStorage.navkeysArraySession != undefined && typeof $sessionStorage.navkeysArraySession[navKey]!= "undefined" && typeof $sessionStorage.navkeysArraySession[navKey].label!="undefined" ){
						$rootScope.appTitle1 = $sessionStorage.navkeysArraySession[navKey].label;

					}
					$scope.setDeviceType();

					/* To populate bread crum array for current page navKey - from child to parent.*/
					if ($sessionStorage.navkeysArraySession !== undefined && $sessionStorage.navkeysArraySession[navKey]) {
						//console.log($sessionStorage.navkeysArraySession[navKey]);

						while ($sessionStorage.navkeysArraySession[navKey]) {
							if($scope.deviceType != undefined && $scope.deviceType == "mobile" && (navKey == "P1S1G1" || navKey == "P1S1G1L2")){
								$sessionStorage.breadCrumArray.push($sessionStorage.navkeysArraySession[navKey]);
								navKey = $sessionStorage.navkeysArraySession[navKey].parentNavKey;
							}else if($scope.deviceType != undefined && $scope.deviceType == "desktop" && (navKey == "P1S1G1" || navKey == "P1S1G1L2")){
								//$sessionStorage.breadCrumArray.push($sessionStorage.navkeysArraySession[navKey]);
								navKey = $sessionStorage.navkeysArraySession[navKey].parentNavKey;
							}
							else if(navKey != "P1S1G1" && navKey != "P1S1G1L2"){
								$sessionStorage.breadCrumArray.push($sessionStorage.navkeysArraySession[navKey]);
								navKey = $sessionStorage.navkeysArraySession[navKey].parentNavKey;
							}
						}
					}
					// reverse the breadcrum  array - to get breadcrums from parent to child
					$sessionStorage.breadcrumbArray = $sessionStorage.breadCrumArray.reverse();
					//To update current page url inside breadcrum array
					for (var ind = 0; ind < $sessionStorage.breadcrumbArray.length; ind++) {
						var siteIdInUrl = $state.params.site_id;
						var langInUrl = $state.params.language;
						
						if (langInUrl == null || langInUrl == undefined || langInUrl !== "es") {
							lang = ""; // blank defaults to English
						}
						// if ($sessionStorage.breadcrumbArray[ind].navKey == $sessionStorage.navkey) {
						// 	var url = "#" + $location.url();
						// 	// If site id is not present in the breadcrumb url or site id in breadcrumb url is different than site id in the browser url
						// 	url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'site_id', siteIdInUrl);
						// 	// If language is not present in the breadcrumb url or language in breadcrumb url is different than language in the browser url
						// 	url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'language', langInUrl);
						// 	$sessionStorage.breadcrumbArray[ind].url = url;
						// }
						if ($sessionStorage.breadcrumbArray[ind].navKey == "P1R1") {
							var url = "#" + $location.url();
							if (url.indexOf("providerResults") != -1) {
							// If site id is not present in the breadcrumb url or site id in breadcrumb url is different than site id in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'site_id', siteIdInUrl);
							// If language is not present in the breadcrumb url or language in breadcrumb url is different than language in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'language', langInUrl);
							$sessionStorage.breadcrumbArray[ind].url = url;
							}
							// $sessionStorage.navKeyFlag = false;
						}else if ($sessionStorage.breadcrumbArray[ind].navKey == "P1D1") {
							var url = "#" + $location.url();
							if (url.indexOf("providerDetails") != -1) {
							// If site id is not present in the breadcrumb url or site id in breadcrumb url is different than site id in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'site_id', siteIdInUrl);
							// If language is not present in the breadcrumb url or language in breadcrumb url is different than language in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'language', langInUrl);
							$sessionStorage.breadcrumbArray[ind].url = url;
							}
						}else if($sessionStorage.breadcrumbArray[ind].navKey == "P1W1"){
							var url = $sessionStorage.breadcrumbArray[ind].url;
							// If site id is not present in the breadcrumb url or site id in breadcrumb url is different than site id in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'site_id', siteIdInUrl);
							// If language is not present in the breadcrumb url or language in breadcrumb url is different than language in the browser url
							url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'language', langInUrl);
							planValue = $scope.criteria.planValue;
							if(planValue != ''){
								url = CommonUtilsService.replaceParamValInStringFromUrl(url, 'planValue', planValue);
							}
							$sessionStorage.breadcrumbArray[ind].url = url;
						}
					}
					var breadcrumbLength = $sessionStorage.breadcrumbArray.length;
					if(($sessionStorage.navkey == "P1S1G1L2" || $sessionStorage.navkey == "P1S1G1") && $sessionStorage.breadcrumbArray[breadcrumbLength - 1] != undefined){
						$sessionStorage.breadcrumbArray[breadcrumbLength - 1].displayUrl = 'true';
					}else if($sessionStorage.breadcrumbArray[breadcrumbLength - 1] != undefined){
						$sessionStorage.breadcrumbArray[breadcrumbLength - 1].displayUrl = 'false';
					}
					/* Do menu change when state change starts */
					$rootScope.$emit("CallParentMethod", {});
					/* Do menu change when state change end */
				}
			});

		}
	}
})();

},{}],28:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navApplication', navApplication);

  	function navApplication() {
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: function(element, attrs){
    		  var applicationTemplate = '';
    		  var applicationTemplate1 = '<div></div>';
    		  var applicationTemplate2 = '<div><div class="breadcrumb_block hidden-xs"><div class="container"><ol id="breadCrumbOL" class="breadcrumb hidden-xs"><li><a class="bread_home_link hidden-xs" href="#/home"><img alt="home image" src="images/blue_home.png"></img></a></li></ol></div></div></div>';
    		  if(attrs.navkey){
    			  applicationTemplate = applicationTemplate1;
    		  }else{
    			  applicationTemplate = applicationTemplate1;
    			  
    		  }
    		  	return applicationTemplate;
    	  },
        controller: 'NavApplicationController'
      };  		
  	}
})();
},{}],29:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavBoxHeaderController', NavBoxHeaderController);

  NavBoxHeaderController.$inject = ['$scope', '$element', '$attrs', 'PageBuilderService'];

  function NavBoxHeaderController($scope, $element, $attrs, PageBuilderService) {
  	var node = PageBuilderService.getNodeInfo($attrs.parent);
  	if (node) {
  		$element.html(node.attributeMap.header);
  	}
  }
})();

},{}],30:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navBoxHeader', navBoxHeader);

  	function navBoxHeader() {
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: '<div style="background: #4e7d2a; color: #FFFFFF; font-weight: bold; font-size: 80%; width: 98%; height: 18px; padding: 1px;"></div>',
        controller: 'NavBoxHeaderController'
      };  		
  	}
})();
},{}],31:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavColumnController', NavColumnController);

  NavColumnController.$inject = ['$scope', '$rootScope', '$compile', '$element', '$attrs', 'PageBuilderService'];

  function NavColumnController($scope, $rootScope, $compile, $element, $attrs, PageBuilderService) {
  	var node = PageBuilderService.getNodeInfo($attrs.id);
  	var parent = PageBuilderService.getNodeInfo($attrs.parent);
  	if (node) {  		
  		
  		
  		if (node.childNodeList) {
  			for (var i = 0; i < node.childNodeList.length; i++) {		
  				var childNode = node.childNodeList[i];
  				
  				switch (childNode.nodeName) {
  				case 'header':
  					var html = '<a class="second-level-head plus">'+childNode.nodeValue + '<span class="menu_icon pull-right"></span></a><ul class="third-level"></ul>';
					$element.html(html);
					$compile($element)($rootScope);
  					break;
  				default:
  					break;
  		  		}
  				
  			}
  		}
  		
  		if(parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == 'secondary')
  		{
  			var $parentDiv = angular.element(document.getElementById($attrs.parent));
  	  		var $firstChild = angular.element($parentDiv.children()[0]);
  	  		var $firstGrandChild = angular.element($firstChild.children()[0]);
  	  		$firstGrandChild.append($element);
  	  		$compile($firstGrandChild)($rootScope);
  		}
  		
  	}
  }
})();

},{}],32:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navColumn', navColumn);

  	function navColumn() {
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: '<li></li>',
        controller: 'NavColumnController'
      };  		
  	}
})();
},{}],33:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.controller('NavGroupController', NavGroupController);

	NavGroupController.$inject = ['$scope', '$compile', '$rootScope','$element', '$attrs', 'PageBuilderService',
	                              'SubHelperService','$document', 'NavSpinnerService', '$sessionStorage', '$timeout', '$window','$location','ProviderSearchCriteriaService','LanguageDataService'];

	function NavGroupController($scope, $compile, $rootScope, $element, $attrs, PageBuilderService,
			SubHelperService, $document, NavSpinnerService, $sessionStorage, $timeout, $window, $location, ProviderSearchCriteriaService,LanguageDataService) {
		var node = PageBuilderService.getNodeInfo($attrs.id);
		var parent = PageBuilderService.getNodeInfo($attrs.parent);
		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.languageData = LanguageDataService.getLanguageData();
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		if (node) {
			switch (node.attributeMap.type) {
			case 'greyBarHeading':
					$element.wrap('<div class="aet-nav-header grey-bg-header"><div class="container clearfix">');
					$element.after('</div></div>');
				break;
			case 'table':
				$element.wrap('<div class="clear col-xs-12 col-md-12 mrgnT20 padL0">');
				break;
			case 'textParagraph':
				if (window.location.href.indexOf("providerSearchGeo") > -1){
					if(node.attributeMap.style=="separatorBor"){
						$element.addClass('borSepartor');
					}else{
						$element.addClass('padB20');
					}
				}
				break;
			case 'categoryBoxes':
				$element.wrap('<div class="col-md-12 col-xs-12 bg-white clearfix">');//col-md-6
				$element.wrap('<div class="col-sm-12 col-xs-12 fullrow clearfix border-bottom border-top-green services-list">');
				break;

			case 'boxes':
				if(window.location.href.indexOf("providerSearchHome") > -1){
					$element.addClass("col-xs-12 pad15");
				}
				else if(window.location.href.indexOf("providerSearchGeo") > -1){
					$element.addClass("adjustMarGeo");
				}

				break;

			case 'headerBlock':
				if($sessionStorage.loggedinUserName!=null && $sessionStorage.loggedinUserName!=undefined){
					var username=$sessionStorage.loggedinUserName;
					$scope.userNameFirst=$sessionStorage.loggedinUserName;
				}
				else{
					var username="User";
					$scope.userNameFirst="User";
				}
				$element.wrap('<li><span class="top_welcome_link"><img src="images/utility/user_black_icon.png" alt="">Welcome '+username+',</span></li>');
				break;
			case 'columns':
				$element.wrap('<div id="c-main-content-Home" tabindex="0"><div class="container  pharmacy-top-links stay-health-top-links">');
				break;
			case 'nursline':
				$element.addClass('infogramHead white-bg pad15 col-xs-12');
				break;
			case 'list':
				if (window.location.href.indexOf("pharmacy") > -1){
					$element.addClass('content-pharmacy');
				}
				switch (node.attributeMap.bulletType) {
				case 'disc':
					$element.addClass('bulletType_disc');
					break;
				case 'decimal':
					$element.addClass('bulletType_decimal');
					break;
				}
				switch (node.attributeMap.style) {
				case 'disc':
					$element.addClass('orientation_vertical');
					$element.addClass('bulletType_disc');

					break;
				case 'decimal':
					$element.addClass('orientation_vertical');
					$element.addClass('bulletType_decimal');
					break;
				case 'category':
					$element.addClass('content-pharmacy');
					break;
				case 'planListPageUnordered':
					$element.addClass('sideContent-planList');
					$element.addClass('bulletType_disc');
					$element.addClass('planListPad40');
					break;
				}
				switch (node.attributeMap.orientation) {
				case 'vertical':
					$element.addClass('orientation_vertical');
					break;
				case 'horizonal':
					break;
				}
				if((window.location.href.indexOf("providerSearchLanding") > -1)  && (node.attributeMap.style == 'greenTick')){
					$element.addClass("greenTickLan");
				}else if(node.attributeMap.style == 'greenTick'){
					$element.addClass("greenTick");
				}
				break;

			case 'container':
				$element.addClass('container');
				break;
			case 'header':
				if(window.location.href.indexOf("accessibilityServices") > -1){
					$element.addClass('header-content-padding');
				}
				break;
			case 'box':
				if(window.location.href.indexOf("providerSearchHome") > -1){
					$element.addClass("row pad15");
				}
				else if((window.location.href.indexOf("providerSearchPlanList") > -1)
 						 || (window.location.href.indexOf("providerSearchGeo") > -1) || (window.location.href.indexOf("providerSearchLanding") > -1)){
					$element.addClass('aet-bg-white');
				}
				else{
					$element.addClass('aet-bg-white container');
				}
				break;
			case 'twoColumn':
				//provSearchHome Alignment
				if (window.location.href.indexOf("providerSearchHome") > -1)
				{
					$element.addClass("col-xs-12 pad0");
					$element.wrap('<div class="container pad0">');
					$element.wrap('<div class="aco-footer-contant clearfix">');
				}
				else if(window.location.href.indexOf("providerSearchPlanList") > -1){
					$element.addClass('col-md-12 col-xs-12');
					var temp=$element.parent().children('#skipPlan');
					$compile(temp)($scope);
				}
				break;
			case 'homeIconLinkBlock':
				var linkUrlArray    =  {'canbPink':'#/contentPage?page=providerSearch','pearlBlue':'#/contentPage?page=claimListing','purpuleShade':'#/contentPage?page=coverageOverview','green':'#/contentPage?page=pharmacy_stayHealthyHome','teal':'#/contentPage?page=pharmacy_mailOrder'};
				var $liTag  =  angular.element('.nav-tabs').children('li').last();
				$liTag.addClass(node.attributeMap.style);
				$liTag.append($element);
				break;
			case 'mobileMenuList':
				angular.element('.menu-list').append($element);
				break;
			case 'primaryMenu':
				break;
			case 'secendryMenu':
				$element.addClass('container clearfix');
				angular.element('.second-navigation').append($element);
				break;
				//For Top Chrome  XML changes -Start vv
			case 'links' :
				switch (node.attributeMap.style) {
				case 'headerMenu':
					var navbarHeader   = angular.element('.navbar-header');
					navbarHeader.append($element);
					$(".menu-button").on('click', function() {
						var pageHeight = $(document).height();
						$(".menu-list, .menu-overlay").fadeIn();
						$(".menu-overlay").css('height', pageHeight);
						$(".menu-txt").focus();
					});
					$(".close-menu").on('click', function() {
						$(".menu-list, .menu-overlay").fadeOut();
					});
					break;
				case 'headerLinks':
					$element.wrap("<div class='fullWidthGrey visible-lg visible-md hidden-xs hidden-sm'>");
					var $parent =   angular.element($element.parent());
					var navbarHeader   = angular.element('.navbar-default');
					navbarHeader.append($parent);
					break;
				case 'headerLink':
					var $parent =   angular.element($element.parent());
					$parent.addClass('navbar-collapse collapse col-sm-9 pad0');
					var navbarHeader   = angular.element('.navbar-default');
					navbarHeader.append($parent);
					break;
				}
				break;
				//For Top Chrome  XML changes-End
			case 'columnOne':
				if(window.location.href.indexOf("providerSearchHome") > -1){
					$element.addClass("col-xs-6 pad0 loginCntnr");
				}else if(window.location.href.indexOf("providerSearchLanding") > -1){
						$element.addClass("col-md-6 col-xs-12 padLand purplePleat columnTabletWidth columnOne");
				}
				else{
					$element.addClass('col-md-6 col-xs-12 col-sm-12 col-md-push-6 id-step2 padPlan width100');
				}
				break;
			case 'navText':
				$element.addClass('col-md-5 col-xs-9 aet-content-hdrtxt pad0');
				$element.append('<div class="line-seperator"></div>');
				$element.append('<h1 class="aet-cont-hdrtxt commonMarker ng-scope" style="display: block;">&nbsp;<span class="sr-only">Common Header</span></h1>');
				break;
			case 'frame':
				break;
			case 'columnTwo':
				if(window.location.href.indexOf("providerSearchHome") > -1 || window.location.href.indexOf("providerSearchGeo") > -1){
					$element.addClass("col-xs-6 rightContnr");
				}else if(window.location.href.indexOf("providerSearchPlanList") > -1 && siteId != 'medicare'){
					$element.append("<div class='caliDiv' ng-if='languageData.SWITCH_CALI_DIV == \"OFF\"'><span class='califorHead' ng-bind-html='languageData.CALI_HEAD|trustHtml'></span>&nbsp;&nbsp;<a target='_blank' ng-href='{{languageData.CALI_PDF_LINK}}' ng-bind-html='languageData.CALI_TEXT|trustHtml'></a></div>");
					$element.addClass("col-md-6 col-sm-12 col-md-pull-6 col-xs-12 pad0 marT36 width100");
					$compile($element)($scope);
				}else if(window.location.href.indexOf("providerSearchLanding") > -1){
					$element.addClass("col-md-6 col-xs-12 padLand purplePleat");
				}
				else{
					$element.addClass('col-md-5 col-xs-12 id-step2');
				}
				break;
			case 'listitem' :
				if(window.location.href.indexOf("providerSearchHome") > -1){
					if(parent.attributeMap.style == 'greenTick'){
						$element.wrap('<div class="greenTickList">');
					}
				}else if((window.location.href.indexOf("providerSearchLanding") > -1) && (parent.attributeMap.style != 'greenTick')){
					$element.addClass("buttLanBBor pull-right");
				}
				break;
			case 'iconLinkBlock':
				$element.addClass('center-block clearfix pointer');
				for (var i = 0; i < node.childNodeList.length; i++) {
					var childNode = node.childNodeList[i];

					switch (childNode.nodeName) {
					case 'url':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.attr('href',childNode.nodeValue);
						}
						break;
					case 'label':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.append(childNode.nodeValue);
						}
						break;
					case 'title':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.attr('title',childNode.nodeValue);
						}
						break;
					default:
						break;
					}

				}
				break;
			case 'tabMenu':
				var $parentDiv = angular.element(document.getElementById($attrs.parent));
				var $Child = angular.element($parentDiv.parent());
				$Child.append($element);
				$compile($Child)($rootScope);
				break;
			case 'secondaryTabMenu':
				var $parentDiv = angular.element(document.getElementById($attrs.parent));
				//logic for swapping element in a.mobileClick
				var mobileClickInnerDiv1   =   angular.copy(angular.element($parentDiv.children()[0]));
				var mobileClickInnerDiv2    =   angular.copy(angular.element($parentDiv.children()[1]));
				angular.element($parentDiv).html('');
				$parentDiv.append(mobileClickInnerDiv2);
				$parentDiv.append(mobileClickInnerDiv1);
				var $Child = angular.element($parentDiv.parent());
				$Child.append($element);
				$Child.children('a').append('<span class="home-mobile-list home-down-arrow"></span>');
				$compile($Child)($rootScope);
				break;
			case 'seperatorLine':
					$element.wrap('<div class="tile_seperator">');
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						switch (childNode.nodeName) {
						case 'label':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
								$compile($element)($rootScope);
							}
							break;
						case 'text':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								var $dotListSpan = angular.element("<span></span>");
								$dotListSpan.addClass("dot-list");
								$element.append($dotListSpan);
								$compile($element)($rootScope);
							}
							break;
						default:
							break;
						}
					}

				break;
			case 'reference':
				$element.addClass('whiteProBg');
				break;
			case 'paragraph':
				if(parent.attributeMap && parent.attributeMap.style){
					switch (parent.attributeMap.style) {
					case 'categoryBoxesHelpBlock':
						$element.addClass('col-xs-10');
						break;
					}
				}
				if (node.attributeMap.style == 'homePgExtraLinks') {
					$element.addClass('col-xs-12 col-md-12 pad0');
				}
				if (node.attributeMap.style == 'usefulResourcesContent') {
					$element.addClass('col-xs-12 col-md-12 pad0');
				}
				if (node.attributeMap && node.attributeMap.border == 'true') {
					$element.css('border','2px solid lightgray');
				}
				if (window.location.href.indexOf("medicalRoutineCare") != -1) {
					$element.addClass('centerContentBorder');
				}
				if (window.location.href.indexOf("standardDisclaimer&") != -1) {
					$element.wrap('<div class="col-xs-12 whiteBoxBlock">');
				}
				break;
			case 'pageTitle':
				if(node && node.childNodeList){
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						switch (childNode.nodeName) {
						case 'title':
							$element.find('.aet-cont-hdrtxt').html(childNode.nodeValue);
							$sessionStorage.pageTitle=childNode.nodeValue;
							/* Do menu change when state change starts */
							$rootScope.$emit("CallParentMethod", {});
							/* Do menu change when state change end */
							break;
						default:
							break;
						}

					}
				}
				$element.addClass('aet-content-header');
				$element.addClass('clearfix');

				if(window.location.href.indexOf("Disclaimer&storeURL") != -1 || window.location.href.indexOf("californiaDisclaimer") != -1 || window.location.href.indexOf("mpeDisclaimer") != -1){

					$element.wrap('<div class="container">');
					if(node && node.childNodeList){
						for (var i = 0; i < node.childNodeList.length; i++) {
							var childNode = node.childNodeList[i];
							switch (childNode.nodeName) {
							case 'title':
								$element.find('.aet-cont-hdrtxt').html(childNode.nodeValue);
								break;
							default:
								break;
							}

						}
					}
					$element.addClass('aet-content-header');
					$element.addClass('clearfix');
				}

				break;
			case 'footerbottomchrome':
				$element.addClass('aet-footer-logo clearfix');
				break;
			case 'leftjustified':
				$element.addClass('pull-left');
				break;
			case 'rightjustified':
				$element.addClass('pull-right');
				if(node.childNodeList[0].url=="images/digicert.png")
				{
					$element.addClass('noPull');
				}
				break;
			case 'linkblock':
				processLinkBlock(node);
				break;
			case 'note':
				if(window.location.href.indexOf("Disclaimer&storeURL") != -1 || window.location.href.indexOf("californiaDisclaimer") != -1 || window.location.href.indexOf("mpeDisclaimer_Page") != -1)
				{
					$element.wrap('<section class="aet-main-container less-content">');
				}
				else{
					$element.wrap('<div class="aet-bg-strp clearfix">');
					$element.addClass('container');
				}
				break;
			case 'contentRow':

				if(parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == "rows"){

					switch (node.attributeMap.style) {
					case 'topBorder':
						processTopBorderGroup();
						break;
					case 'top_Border':
						processTopBorderGroup();
						break;
					case 'contentLink':
						processContentLinkGroup(parent);
						break;
					case 'bottomBorder':
						processBottomBorderGroup();
						break;
					case 'discountPageContent':
						$element.addClass('row well-section');
						break;
					case 'discountPageTitle':
						processDiscountPageTitle();
						break;
					case 'discountPageReadMoreSection':
						processReadMore();
						break;
					case 'discountPageSeperator':
						$element.addClass('well-separator');
						break;
					case 'imageTitle':
						$element.addClass('row levelTwoPage-imageTitleRow');
						break;
					case 'oneColumnCenterContent':
						$element.addClass('row well-section');
						break;
					default:
						break;
					}

				}
				else if (node.childNodeList) {
					SubHelperService.resetSubHelpers();
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						if (childNode.attributeMap && childNode.attributeMap.type && childNode.attributeMap.type == 'linkblock') {
							$element.addClass('row alignAdj widthCustomizeTab dynamicHeight');
							if(window.location.href.indexOf("providerSearch")== -1 || window.location.href.indexOf("providerSearchDentalCare")!= -1){
								$element.addClass('marginCenterContent');
							}
							//break;
						}
						if(childNode.attributeMap && childNode.attributeMap.subHelper && childNode.attributeMap.subHelper!= '') {
							SubHelperService.addSubHelpers(childNode.attributeMap.subHelper);
							//break;
						}
						else{
							//nothing.
						}
					}
				}
				switch (node.attributeMap.style) {
				case 'intakeFormPageTitle':
					$element.addClass('heads padT15');
					break;
				case 'intakeFormCenterContent':
					$element.addClass('program-content');
					break;
				default:
					break;
				}
				break;
			case 'content':
				if(window.location.href.indexOf("standardDisclaimer") > -1){
					$element.addClass('padL0 aet-content-fluid linkBlockStyle container discclaimerShortCont DisclaimerIncMar discButtonMar');
				}else{
					var contentPage = $location.search().page;
					if(contentPage=="providerResults"){
						$element.addClass('aet-content-fluid linkBlockStyle container pad0');
					}else{
						$element.addClass('aet-content-fluid linkBlockStyle container padAdj');
					}
				}

				if (node.childNodeList ) {
					var childNode = node.childNodeList[0];
					if(childNode.attributeMap && childNode.attributeMap.type && childNode.attributeMap.type == "tabContainer"){
						if(window.location.href.indexOf("ahfNew") > -1 || window.location.href.indexOf("adfNew") > -1){
							$element.removeClass('aet-content-fluid');
							$element.removeClass('linkBlockStyle');
						}
						else{
							$element.addClass('tab-content'); // to set message and contact us
							$element.removeClass('aet-content-fluid');
						}
					}
				}
				var contentPage = $location.search().page;
				if(!contentPage){
					var a=window.location.href.split("=");
					contentPage = a[a.length-1];
				}
				if((contentPage=="directoryAndResources") || (contentPage=="qualityAndCostInfo") || (contentPage=="savingsAndDiscounts")
						|| (contentPage=="importantInfo")){
					$element.wrap("<div class='container pad0'>");
				}

				if(contentPage=="providerSearchHome"){
					$element.after("<br/>");
					$element.wrap("<div class='aet-main-container'>");
					$element.wrap("<div class='container planSelectionContent widthFix'>");
				}
				else if(contentPage=="providerSearchGeo"){
					$element.after("<br/>");
					$element.wrap("<div class='aet-main-container bgWhite'>");
					$element.wrap("<div class='container widthFix'>");
				}
				else if(contentPage=="providerSearchPlanList"){
					$element.wrap("<div id='provider-srch' class='aet-provsearch-sl'>");
									}
				else if(contentPage=="providerSearch"){
					$element.removeClass('aet-content-fluid');
					$element.addClass('aet-content-fluid-searchBranding marImp0');
					$element.removeClass('container');
					$element.after("<br/>");
					$element.wrap("<div class='container pad0'><div class='col-xs-12 linkBlockSection pad0'><div id='provider-srch' class='aet-provsearch-content aet-provsearch-content-borderstyle mobileBckGndColor padImp0'>");				}
				else if(contentPage=="providerResults"){
					$element.after("<br/>");
					$element.wrap("<div id='provider-Results-id' class=''>");
					$element.wrap("<div class='container pad0'>");
				}else if(contentPage=="providerSearchLanding"){
					$element.after("<br/>");
					$element.wrap("<div class='container planSelectionContent widthFix alignFix'>");
				}
				else{
					$element.wrap("<div id='provider-srch' class='aet-provsearch-content aet-provsearch-sl'>");
				}
				break;
			case 'primary':
				$element.addClass('navigation1-inside clearfix');
				break;
			case 'tabContent':
				if (parent.attributeMap.name) {

					switch (parent.attributeMap.name) {
					case 'medicals':
						$element.addClass('aet-content-fluid');
						$element.wrap("<div id='medicals' class='arrow-up active in tab-pane fade bottom-top1 clearfix medical-coverage-border'><div class='coverage-result-div'><div class='container'>");
						$rootScope.medicalCoverageSection = true;
						$rootScope.medicalHelpSection = true;
						break;
					case 'dentals':
						$element.addClass('aet-content-fluid');
						$element.wrap("<div id='dentals' class='arrow-up1 tab-pane fade bottom-top1 dental-coverage-border'><div class='coverage-result-div'><div class='container'>");

						$rootScope.dentalCoverageSection = true;
						$rootScope.dentalHelpSection = true;
						break;
					case 'behavioral':
						$element.addClass('aet-content-fluid');
						$element.wrap("<div id='behavioral' class='arrow-up2 behav-health tab-pane fade clearfix bottom-top1 health-coverage-border'><div class='coverage-result-div'><div class='container'>");

						$rootScope.behavioralCoverageSection = true;
						$rootScope.behavioralHelpSection = true;
						break;
					case 'vision':
						$element.addClass('aet-content-fluid');
						$element.wrap("<div id='vision' class='arrow-up3 tab-pane fade bottom-top1 vision-coverage-border'><div class='coverage-result-div'><div class='container'>");
						$rootScope.visionCoverageSection = true;
						$rootScope.visionHelpSection = true;
						break;
					case 'pharmacy':
						$element.addClass('aet-content-fluid');
						$element.wrap("<div id='pharmacy' class='arrow-up4 tab-pane fade clearfix bottom-top1 pharmacy-coverage-border'><div class='coverage-result-div'><div class='container'>");
						$rootScope.pharmacyCoverageSection = true;
						$rootScope.pharmacyHelpSection = true;
						break;
					case 'additional_coverage':
						$element.addClass('aet-content-fluid additional');
						$element.wrap("<div id='additional_coverage' class='arrow-up5 bottom-top1 tab-pane fade additional-coverage-border'><div class='coverage-result-div'><div class='container'>");
						$rootScope.additionalCoverageSection = true;
						$rootScope.additionalHelpSection = true;
						break;
					default:
						break;
					}

				}
				break;

			default:
				break;
			}

			if(parent.attributeMap && parent.attributeMap.type)
			{
				switch (parent.attributeMap.type) {
				case 'accordion':
					$element.wrap('<div id="readLess" class="readMoreParagraph collapse">');
					var $accordionContainer = angular.element('.well-coupon-section');
					$accordionContainer.append('<a id="readLessLink" href="javascript:void(0);" ng-click="discountReadLess()" class="readLessLink lessTrigger collapse"><b> Read Less</b></a>');
					$compile($accordionContainer)($scope);
					break;
				}
			}

			if(node.attributeMap && node.attributeMap.style){
				switch(node.attributeMap.style){
				case 'categoryBoxesHelpBlock':
					$element.addClass('infogramHead white-bg pad15 col-xs-12');
					break;
				case 'categoryBoxesLinkBlock':
					$element.addClass('infogramHead white-bg pad15');
					break;
				case 'homeIconLinkBlockColumn':
					angular.element('.nav-tabs').append($element);
					break;
				case 'homeIconLinkBlockColumns':
					angular.element($element.siblings('section')).append($element);
					//Homepage middle align tiles start
					var screenWidth1 = $(window).width();
					$('body, html').css('overflow', 'visible');
					var screenWidth2 = $(window).width();
					$('body, html').removeAttr('style');
					var scrollbarWd = screenWidth1 - screenWidth2;

					function homeTilesAlign(){
						if($(window).width() >= 992 - scrollbarWd){
							setTimeout(function(){
								if(node.childNodeList.length == 4){
									$("#home_tab_accordion").css("margin-left", "10%");
									// $("#home_tab_accordion li").css("width", "22%");
									$(".bottom-border").css("width", "22%");
								}
								if(node.childNodeList.length == 3){
									$("#home_tab_accordion").css("margin-left", "20%");
									//$("#home_tab_accordion li").css("width", "25%");
									$(".bottom-border").css("width", "25%");
								}
								if(node.childNodeList.length == 2){
									//Changed margin for home_tab_accordion to align it right for 2 children
									$("#home_tab_accordion").css("margin-left", "33%");
									//$("#home_tab_accordion li").css("width", "30%");
									$(".bottom-border").css("width", "30%");
								}
								if(node.childNodeList.length == 1){
									$("#home_tab_accordion").css("margin-left", "35%");
									//$("#home_tab_accordion li").css("width", "35%");
									$(".bottom-border").css("width", "35%");
								}
							}, 50);
						}
					}
					homeTilesAlign();
					$(window).resize(function() {
						if($(window).width() < 992 - scrollbarWd){
							if(node.childNodeList.length == 4 || node.childNodeList.length == 3 || node.childNodeList.length == 2 || node.childNodeList.length == 1){
								$("#home_tab_accordion").css("margin-left", "0%");
								$(".bottom-border").css("width", "100%");
							}
						}else{
							homeTilesAlign();
						}
					});
//					Homepage middle align tiles end
					break;
				case 'homePageUnordered':
					angular.element('.tile_seperator').last().append($element);
					$sessionStorage.homePageUnorderedLength  =  node.childNodeList.length;
					if(window.location.href.indexOf("providerSearchHome") > -1){
						$element.addClass('marT20');
					}
					if(window.location.href.indexOf("providerSearchLanding") > -1){
						$element.addClass('customFltLft');
					}
					break;
				case 'separatorLineHomePage':
					angular.element('.left-block').last().append($element);
					break;
				case 'fullWidthRowHomePageMultiPS':
				case 'planSponserLinks':
					var $parentDiv  =  angular.element('.home_master_tab_group').parent();
					$parentDiv.append($element);
					break;
				case 'planSponserHorizontalBoxList':
					/*$element.addClass('horizontalBoxStyle');*/
					break;
				case 'planSponserBanner':
					var $child1  =  angular.element(angular.element('.sponserBlockOverall').children()[0]);
					$child1.append($element);
					break;
				case 'planSponserBannerBoxes':
					var $parentDiv  =  angular.element('.home_master_tab_group').parent();
					$parentDiv.append($element);
					break;
				case 'planSponserBannerBox':
					$element.siblings().append($element);
					break;
				case 'imageList':
					$element.wrap('<section>');
					break;
				}
			}
		}

		function processTopBorderGroup(){

			if (node.childNodeList) {

				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {

					case 'image':
						if (childNode.childNodeList) {
							for (var j = 0; j < childNode.childNodeList.length; j++) {
								var imageChildNode = childNode.childNodeList[j];
								if(imageChildNode.nodeName == 'url'){
									if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
										$element.find('.second-level-result-image').attr('src',imageChildNode.nodeValue);
									}
								}
								if(imageChildNode.nodeName == 'alttext'){
									if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
										$element.find('.second-level-result-image').attr('alt',imageChildNode.nodeValue);
									}
									else
									{
										$element.find('.second-level-result-image').attr('alt',"");
									}
								}
							}
						}
						break;
					case 'text':
						if(childNode.attributeMap && childNode.attributeMap.type){

							var $nodeText = $.parseHTML(childNode.nodeValue);
							var textContent = $nodeText[0].textContent;

							if(childNode.attributeMap.type == 'texth3'){
								$element.find('.h3Text').html(textContent);
							}

							if(childNode.attributeMap.type == 'textParagraph'){
								$element.find('.paragraphText').html(textContent);
							}
						}
						break;
					}
				}
			}
		}

		function processDiscountPageTitle(){
			if (node.childNodeList) {

				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {

					case 'image':
						if (childNode.childNodeList) {
							for (var j = 0; j < childNode.childNodeList.length; j++) {
								var imageChildNode = childNode.childNodeList[j];
								if(imageChildNode.nodeName == 'url'){
									if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
										$element.find('.discountTitleImage').attr('src',imageChildNode.nodeValue);
									}
								}
								// Commmneted code to fix accessibility issue

								/*if(imageChildNode.nodeName == 'alttext'){
                  if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
                    $element.find('.discountTitleImage').attr('alt',imageChildNode.nodeValue);
                  }
                }*/
							}
						}
						break;
					case 'text':
						if(childNode.attributeMap && childNode.attributeMap.type){
							if(childNode.attributeMap.type == 'texth2'){
								$element.find('.h2Text').append(childNode.nodeValue);
							}

						}
						break;
					}
				}
			}
		}

		function processReadMore(){
			if (node.childNodeList) {

				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {

					case 'text':
						if(childNode.attributeMap && childNode.attributeMap.type){

							if(childNode.attributeMap.type == 'textSpan'){
								if(i==0){
									$element.find('.defaultParagraph').append(childNode.nodeValue);
								}else{
									$element.find('.readMoreParagraph').append(childNode.nodeValue);

								}
							}

						}
						break;
					}
				}
			}
		}

		$scope.discountReadMore = function(){

			var $readLessLink = angular.element(document.getElementById('readLessLink'));
			var $readLess = angular.element(document.getElementById('readLess'));
			var $readMoreLink = angular.element(document.getElementById('readMoreLink'));
			$readLessLink.addClass('collapse in');
			$readLessLink.removeClass('collapse');
			$readLess.addClass('collapse in');
			$readLess.removeClass('collapse');
			$readMoreLink.removeClass('collapse in');
			$readMoreLink.addClass('collapse');

		}

		$scope.discountReadLess = function(){

			var $readLessLink = angular.element(document.getElementById('readLessLink'));
			var $readLess = angular.element(document.getElementById('readLess'));
			var $readMoreLink = angular.element(document.getElementById('readMoreLink'));
			$readLessLink.removeClass('collapse in');
			$readLessLink.addClass('collapse');
			$readLess.removeClass('collapse in');
			$readLess.addClass('collapse');
			$readMoreLink.removeClass('collapse');
			$readMoreLink.addClass('collapse in');

		};


		function processBottomBorderGroup(){

			if (node.childNodeList) {

				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {

					case 'link':
						if (childNode.childNodeList) {
							for (var j = 0; j < childNode.childNodeList.length; j++) {
								var linkChildNode = childNode.childNodeList[j];
								if(linkChildNode.nodeName == 'url'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										var linkhref = linkChildNode.nodeValue;
										if(linkhref && linkhref.indexOf("?page=")!= -1){
											linkhref = linkhref+'&site_id='+siteId+'&language='+language;
										}
										$element.find('.new-search-click').attr('href',linkhref);
									}
								}
								if(linkChildNode.nodeName == 'label'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										$element.find('.new-search-click').append(linkChildNode.nodeValue);
									}
								}
								if(linkChildNode.nodeName == 'title'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										$element.find('.new-search-click').attr('title',linkChildNode.nodeValue);
									}
								}
								if(linkChildNode.nodeName == 'image'){
									if (linkChildNode.childNodeList) {
										for (var k = 0; k < linkChildNode.childNodeList.length; k++) {
											var imgChildNode = linkChildNode.childNodeList[k];
											if(imgChildNode.nodeName == 'url'){
												if(imgChildNode.nodeValue!=undefined && imgChildNode.nodeValue!=""){
													$element.find('.search-icon').attr('src',imgChildNode.nodeValue);
												}
											}
											/**Fix to add alttext for images **/
											else if(imgChildNode.nodeName == 'alttext'){
												if(imgChildNode.nodeValue!=undefined && imgChildNode.nodeValue!=""){
													$element.find('img').attr('alt',imgChildNode.nodeValue);
												}
												else
												{
													$element.find('img').attr('alt',imgChildNode.nodeValue);
												}
											}
										}
									}
								}
							}
						}
						break;
					case 'text':
						if(childNode.attributeMap && childNode.attributeMap.type){

							if(childNode.attributeMap.type == 'textSpan'){
								$element.find('.specialist_start_txt').html(childNode.nodeValue);
							}

						}
						break;
					}
				}
			}
			var temp1=$('.searchTextClass').attr('ng-controller','ProviderSearchController');
			$compile(temp1)($scope);
		}

		function processContentLinkGroup(parentNode){
			var lenChildNode = parentNode.childNodeList.length;
			$("[nvstyle='contentLink']:nth-child(" + lenChildNode + ")").addClass('bottom-border');
			if (node.childNodeList) {
				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {

					case 'link':


						if (childNode.childNodeList) {
							if (childNode.attributeMap.style == 'newTabLink') {
								$element.find('.contentLink').attr('target',"_blank");
							}
							for (var j = 0; j < childNode.childNodeList.length; j++) {
								var linkChildNode = childNode.childNodeList[j];
								if(linkChildNode.nodeName == 'url'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										var linkhref =   linkChildNode.nodeValue;
										if(linkhref && linkhref.indexOf("?page=")!= -1){
											linkhref = linkhref+'&site_id='+siteId+'&language='+language;
										}
										//Adding this if block to take care of URL's like "javascript:". This is not supported in Mozialla/IE and causes the exisiting page to //break. Thus gettign the actual URL and using target to open it in new window.
										if(linkhref && linkhref.indexOf('_blank')!= -1 && linkhref.indexOf("'")!= -1)
										{
											linkhref = linkhref.substring(linkhref.indexOf("'") +1,linkhref.indexOf("_blank"));
											linkhref = linkhref.substring(0,linkhref.indexOf("'"));
											$element.find('.contentLink').attr('href', linkhref);
											$element.find('.contentLink').attr('target',"_blank");
										}
										else
											$element.find('.contentLink').attr('href',linkhref);
									}
								}
								if(linkChildNode.nodeName == 'label'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										$element.find('.dummyLinkLabel').html(linkChildNode.nodeValue+"<img class='padL5 previous marTopImg' src='images/blue_arrow.png' alt=''>");
									}
								}
								if(linkChildNode.nodeName == 'title'){
									if(linkChildNode.nodeValue!=undefined && linkChildNode.nodeValue!=""){
										$element.find('.contentLink').attr('title',linkChildNode.nodeValue);
									}
								}
							}
						}
						break;
					case 'text':
						if(childNode.attributeMap && childNode.attributeMap.type){

							var $nodeText = $.parseHTML(childNode.nodeValue);
							var textContent = $nodeText[0].textContent;

							if(childNode.attributeMap.type == 'texth3'){
								$element.find('.h3Text').html(textContent);
							}

							if(childNode.attributeMap.type == 'textParagraph'){
								$element.find('.paragraphText').html(textContent);
							}
						}
						break;
					}
				}
			}
		}

		//Skip to main content animation
		$(document).ready(function() {
			$('#skip-anchor').click(function() {
				if(window.location.href.indexOf("homePageNew") > -1)
				{
					$('body,html').animate({
						scrollTop: $("#c-main-content-Home").offset().top
					}, 1000);
					$("#c-main-content-Home").focus();
					$('body,html').clearQueue()
				}
				else{
					$('body,html').animate({
						scrollTop: $("#c-main-content").offset().top
					}, 1000);
					$("#c-main-content").focus();
					$('body,html').clearQueue()
				}

			});

		});
		// New Skip to main content function 
		$(document).ready(function() {
			$('#skip-anchor-main').click(function() {
				if(window.location.href.indexOf("providerSearchLanding") > -1 )
				{
					$('body,html').animate({
						scrollTop: $("#mainWhiteBlockOne").offset().top
					}, 1000);
					$("#mainWhiteBlockOne").focus();
					$("#zip1").focus();
					$('body,html').clearQueue()
				}
				else{
					$('body,html').animate({
						scrollTop: $("#main-div").offset().top
					}, 1000);
					$("#main-div").focus();
					$('body,html').clearQueue()
				}

			});

		});

		function getLanguageParameter( name, url ) {
			 if (!url) url = location.href;
			 name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
			 var regexS = "[\\?&]"+name+"=([^&#]*)";
			 var regex = new RegExp( regexS );
			 var results = regex.exec( url );
			 return results == null ? null : results[1];
	 	}
		function processLinkBlock(node){

			var url = window.location.href;
			var lang = getLanguageParameter('language', url);
			if(lang == 'es'){
				$element.find('.search-block').addClass('customSearch-block');
				$element.find('.tile_holder').addClass( 'customTile_holder' );
			}
			$element.find('.image-block').addClass('image-block ' + node.attributeMap.style);
			if(node.attributeMap.subHelper)
			{
				$element.addClass(node.attributeMap.subHelper);
				$element.addClass(node.attributeMap.subHelper + "Helper");
			}
			if (node.childNodeList) {

				for (var i = 0; i < node.childNodeList.length; i++) {

					var childNode = node.childNodeList[i];
					switch (childNode.nodeName) {
					case 'header':
						var parentHref = $element.find('.imagr-caption.clearfix').attr('href');
						var tempNormal = $('<p class="dummyAnchor"><a tabindex=-1 class="mobileMarAdj anchorTagGuided" style="color:white !important;margin-right: -15px;overflow: hidden;">'+childNode.nodeValue+'&nbsp;&nbsp;<img class="adjustImg" alt="" src="images/next.png"></a><p>');
						$element.find('.search-block-text').append(tempNormal);
						$element.find('.anchorTagGuided').attr('href',parentHref);
						if(parentHref!=null && parentHref!=undefined && parentHref.indexOf("#/") == -1)
						{
							$element.find('.anchorTagGuided').attr('target','_blank');
						}
						break;

					case 'text':
						$element.find('.search-block-description span').html(childNode.nodeValue);
						break;

					case 'url':
						var guidedFlowUrl = childNode.nodeValue;
						if(guidedFlowUrl && guidedFlowUrl.indexOf("?page=")!= -1){
							guidedFlowUrl = guidedFlowUrl+'&site_id='+siteId+'&language='+language;
						}
						//Adding this if block to take care of URL's like "javascript:". This is not supported in Mozialla/IE and causes the exisiting page to //break. Thus gettign the actual URL and using target to open it in new window.
						if(guidedFlowUrl && guidedFlowUrl.indexOf('_blank')!= -1 && guidedFlowUrl.indexOf("'")!= -1)
						{
							guidedFlowUrl = guidedFlowUrl.substring(guidedFlowUrl.indexOf("'") +1,guidedFlowUrl.indexOf("_blank"));
							guidedFlowUrl = guidedFlowUrl.substring(0,guidedFlowUrl.indexOf("'"));
							$element.find('.imagr-caption').attr('href', guidedFlowUrl);
							$element.find('.imagr-caption').attr('target','_blank');
						}else
							$element.find('.imagr-caption').attr('href',guidedFlowUrl);
						if(childNode.nodeValue!=null && childNode.nodeValue!=undefined && childNode.nodeValue.indexOf("#/") == -1)
						{
							$element.find('.imagr-caption').attr('target','_blank');
						}
						break;

					case 'title':

						$element.find('.imagr-caption').attr('title',childNode.nodeValue);
						break;

					case 'image':
						if (childNode.childNodeList) {
							for (var j = 0; j < childNode.childNodeList.length; j++) {
								var imageChildNode = childNode.childNodeList[j];
								if(imageChildNode.nodeName == 'url'){
									if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
										$element.find('.tile-icon').attr('src',imageChildNode.nodeValue);
									}
								}
								if(imageChildNode.nodeName == 'alttext'){
									if(imageChildNode.nodeValue!=undefined && imageChildNode.nodeValue!=""){
										$element.find('.tile-icon').attr('alt',imageChildNode.nodeValue);
									}
									else 
									{
										$element.find('.tile-icon').attr('alt',"");
									}
								}
							}
						}
						break;
					case 'appid':
						if(childNode.attributeMap && childNode.attributeMap['function']){
							var callingFunction = childNode.attributeMap['function'];
							var htmlElement = $element[0].childNodes[0].childNodes[0];
							for (var j = 0; j < htmlElement.attributes.length; j++) {
								if(htmlElement.attributes[j].name == "ng-click"){
									htmlElement.attributes[j].nodeValue = callingFunction + '()';
								}
							}
						}
						break;
					}
				}
			}
		}

	}
})();

},{}],34:[function(require,module,exports){
(function () {

	angular
	.module('nav-ui')
	.directive('navGroup', navGroup);

	function navGroup() {
		return {
			restrict: 'E',
			replace: true,
			template: function (element, attrs) {
				var template = '';
				var groupTemplate1 = '<div></div>';
//				var groupTemplate2 = '<div class="linkblock"><div class="col-sm-6 col-md-2 tile_holder"><div class="hoverClass thumbnail newDiscountThumb"><a ng-click="" class="imagr-caption clearfix classForTab" href=""><span class="image-block"><img class="tile-icon"></span><span class="classForTarget caption paddingLinkBlocks"><span class="cap-hdr-txt txtAlignmentLeft"></span><span class="cap-content-txt txtAlignmentLeft"></span></span><span class="arr-icon-black pull-right"></span></a></div></div></div>';
				// var groupTemplate2 = '<div class="linkblock"><div class="col-sm-6 col-md-2 tile_holder"><div class="hoverClass thumbnail newDiscountThumb"><a ng-click="" class="imagr-caption clearfix" href=""><div class="search-block image-block-purple"><div class="search-block-image"><img class="tile-icon"></div><div class="search-block-text"></div></div><div class="search-block-description"><span></span></div></a></div></div></div>';
				var groupTemplate2 = '<div class="linkblock"><div class="col-sm-6 col-md-2 tile_holder"><div class="hoverClass thumbnail newDiscountThumb"><a class="imagr-caption clearfix" href=""><div class="focusForIE"><div class="search-block image-block-purple"><div class="search-block-image"><img class="tile-icon"></div><div class="search-block-text"></div></div><div class="search-block-description"><span></span></div></div></a></div></div></div>';
				var groupTemplate3 = '<div><div class="aet-content-fluid pageTitleDiv" style="display:none"> <div class="pull-left"><h1 class="aet-cont-hdrtxt"><span class="sr-only">Content Title</span></h1><span class="aet-whitesld-arr"></span></div></div></div>';
				var groupTemplate4 = '<div class="second-level-content description-ps container-fluid top-border"><div class="second-level-result"><div class="result-content"><div class="row"><div class="col-xs-12 padleft0px result-content-col"><div class="nSlevelPhysician"><img class="second-level-result-image pull-left"></img></div><div class="second-level-result-text pull-left"><h3 class="h3Text" id="h3TextThirdLevel"></h3><p class="paragraphText"></p></div></div></div></div></div></div>';
				var groupTemplate5 = '<div class="second-level-content description-ps container-fluid"><div class="second-level-result-description"><a class="contentLink txtDecNone"><div class="result-description focusForIE"><h3 class="dummyLinkLabel"></h3><p class="paragraphText"></p></div></a></div></div>';
				var groupTemplate6 = '<div class=""><div class="padT10"><div class="result-description clearfix"><div class="padT10 clearfix"><div class=""><span class="specialist_start_txt normalFtWt"></span></div><div class="searchTextClass"><a class="pad5" ng-click="startanewSearch()"><button class="primaryPurple buttonpad buttHeight BtnWidth buttLan pad5"><img class="search-icon" src="images/search.png" alt=""><span style="color:#FFFFFF" ng-bind-html="languageData.START_NEW_SRCH|trustHtml"></span></button></a></div></div></div></div></div>';
				var groupTemplate7 = '<ul></ul>';
				var groupTemplate8 = '<div class="menuOf" menufor=""><div class="aet-content-fluid"><ul class="second-level"></ul></div></div>';
				var groupTemplate9 = '<div class="col-md-12 pharmacy-row"></div>';
				var groupTemplate0 = '<div class="aet-bg-white pharmacy-block"></div>';
				var groupTemplate10 = '<div class="col-md-6 pharmacy-main"></div>';
				var groupTemplate11 = '<a href="#" class="center-block i-need-scroll clearfix"></a>';
				// var groupTemplate12 = '<ul class="nav nav-tabs"></ul>';
				var groupTemplate13 = '<p class="minH90 marT10"></p>';
				var groupTemplate14 = '<div class="left-block"><p class="marT10"></p></div>';
				var groupTemplate15 = '<div class="bannerImg"></div>';
				var groupTemplate16 = '<div class="container clearfix"><div class="col-md-1 aet-content-hdrtxt pad0" id="aet-content-hdrtxtone"><button type="button" class="menu-button"><img src="images/menu_icon_desktop_transparent.png" alt=""></button><ul class="col-xs-12 menu-list pad0" style="display: none;"><li class="inactive clearfix"><p class="col-xs-8 menu-txt">Menu</p><a class="close-menu col-xs-4"></a><a href="#/logout" class="logout-menu col-xs-4"></a></li></ul></div></div>';
				var groupTemplate17 = '<a></a>';
				var groupContentTop = '<div></div>';
				var groupTemplateCoverageOuterBox = '<div class="col-md-12 col-xs-12 bg-white left pad0 marB15"></div>';
				var groupTemplateCoverageInnerBox = '<div class="col-xs-12 borderall"></div>';
				var groupTemplateCoverageCostImage = '<div class="pull-right marT8"></div>';
				var groupTemplateAetMainContainer = '<div class="coverage-page-bg"></div>';
				var groupTemplateCoverageMainContainer='<div class="My_Coverage"></div>';
				var groupTemplateCoverageContainer='<div class="container pad0"></div>';
				var groupTemplateCoverageSubLinks = '<div class="col-xs-12 col-md-4"></div>';
				var groupTemplateHealthFundsContent = '<div class="aet-provsearch-content aet-provsearch-sl container clearfix" id="healthfund-section"></div>';
				var groupTemplateHealthFundsType = '<div class="container backSection"></div>';
				var groupTemplateDisclaimerFooter = '<div class="container"><footer id="aet-footer" class="aet-footer clearfix"><div class="container footer-container-sm"><div class="aet-footer-logo clearfix"><div class="aet-copyrights"></div></div></div></footer><div>';
				var groupTemplateDisclaimerPage = '<section class="aet-main-container less-content"></section>';
				var groupTemplateDisclaimerHeader = '<div class="aet-header"><div class="container"><div class="navbar navbar-default"><div class="navbar-header col-xs-12 col-sm-6 pad0 pull-left"><div class="navigator-logos"><a href="#" title="Aetna Logo" class="aet-logo" id="brandingLogoId"></a></div></div></div></div></div>';
				var groupTemplateDisclaimerInfo = '<div class="col-xs-12 user-agreement container"></div>';

				var groupTemplateUrgentCareBox = '<div class="col-md-12 col-xs-12 pad0 home-hdr-value-new clearfix"></div>';
				var groupTemplateUrgentCareColumn = '<div class="col-md-6 col-xs-12 pad0 clearfix"></div>';
				var groupTemplateUrgentCareImage = '<div class="col-md-2 col-xs-2 pad0"></div>';
				var groupTemplateUrgentCareText = '<div class="col-md-10 col-xs-10 pad0"></div>';
				var groupTemplateUrgentCareContainer = '<div class="ineed-body-new clearfix"></div>';

				//var groupTemplateHeaderImage    =   '<div class="container topChromeLogo padLeftClear padRightClear"><div id="skip-to-content"><a title="Skip to main content" href="#c-main-content">Skip to main content</a></div><div class="navbar navbar-default"><div class="navbar-header col-xs-12 col-sm-3 pad0 pull-left" id="adjustPSLogo"><div class="navigator-logos pull-left"></div></div></div></div>';
				// var groupTemplateHeaderImage    =   '<div class="container topChromeLogo padLeftClear padRightClear"><div class="navbar navbar-nav"><div id="adjustPSLogo"><div class="navigator-logos"></div></div></div></div>';
				var groupTemplateHeaderImage    =   '<div class=""></div>';
				var groupTemplateHeaderImageWithSkipLink    =   '<div class="container topChromeLogo padLeftClear padRightClear"><div id="toFocus"><a id="toHoldFocus"></a></div><div id="skip-to-content"><a id="skip-anchor-main" href="">Skip to main content</a></div></div>';
				var groupTemplateHeaderHeaderMenu   =   '<ul class="nav-mobile-list pull-right"></ul>';
				var groupTemplateHeaderLinks    =   '<ul class="nav navbar-nav"></ul>';
				var groupTemplateMobileMenuList     =   '<li class="col-xs-12 pad0 home-mobile-list"><ul class="mobile-list-new"></ul></li>';
				var groupTemplateHomeMobileMenu     =   '<div class="home-mobile-menu"><ul class="home-mobile-list"></ul></div>';
				var groupTemplateUrgentCareMainContainer = '<div class="container coverage-page-bg"></div>';
				var groupTemplateUrgentCareMyIneed = '<div class="my-ineed-care"></div>';
				var groupTemplateDiscountPageTitle = '<div class="row levelTwoPage-imageTitleRow"><div class="col-xs-2 col-sm-1"><img class="discountTitleImage"></img></div><div class="col-xs-10 col-sm-8 levelTwoPage-titleText"><h2 class="h2Text"></h2></div></div>';
				var groupTemplateReadMore = '<div class="row well-coupon-section"><span class="defaultParagraph"></span><a id="readMoreLink" href="javascript:void(0);" ng-click="discountReadMore()" class="readMoreLink lessTrigger">Read More</a><span id="readLess" class="readMoreParagraph collapse"></span><a id="readLessLink" href="javascript:void(0);" ng-click="discountReadLess()" class="readLessLink lessTrigger collapse"><b> Read Less</b></a></div>';
				var groupTemplateOverviewMainContainer='<section class="aet-main-container" role="main"></section>';
				var groupTemplateAetTemplate='<div class="aet-template"></div>';
				var groupTemplateOverviewTopLinks='<div class="pharmacy-top-links clearfix padT10 stay-health-top-links"></div>';
				var groupTemplateOverviewContainer='<div class="container"></div>';
				var groupTemplateOverviewList1='<ul class="col-xs-12 col-md-12 clearfix"></ul>';
				var groupTemplateOverviewList2='<li class="col-md-4 col-xs-12 pad0 text-center"></li>';
				var groupTemplateOverviewPremiumBlock='<div class="down-block"></div>';
				var groupTemplateListItem='<li></li>';
				var groupTemplateColumns='<div class="row"><div class="col-xs-12 home_master_tab_group" id="home_master_tab_group"><div class="container pad0"><ul class="nav nav-tabs" id="home_tab_accordion"></ul></div></div></div>';
				var groupTemplateColumn='<li class="col-xs-12 width20 bottom-border home_group " data-colorshade="canbPink"></li>';
				var groupTemplateUnordered	=	'<p class=" marT10"></p>';
				var groupTemplateFullWidthRowHomePageMultiPS	=	'<div class="col-md-12 col-xs-12 grey-box2"><div class="container"><div class="col-md-12 col-xs-12 pad0 multiPSLink"></div></div></div>';
				var groupTemplatePlanSponserLinks	=	'<div class="col-md-12 col-xs-12 sponsor-block sponserBlockOverall"><div class="container"></div></div>';
				var groupTemplatePlanSponserHorizontalBoxList	=	'<div class="col-md-12 col-xs-12 pad0 mrgnT10 mrgnB20"></div>';
				var groupTemplateplanSponserListItem	=	'<div class="col-md-3 col-xs-12 pad0 marT10 setHeight40"><div class="sponsor_links"></div></div>';
				var groupTemplateplanSponserBanner	=	'<div class="col-md-12 col-xs-12 pad0 sponserBlockBanner"></div>';
				var groupTemplateplanSponserBannerBoxes	=	'<div class="col-md-12 col-xs-12 pad0 sponsor-block"><div class="col-md-12 col-xs-12 pad0 mrgnT10 mrgnB20"></div></div>';
				var groupTemplateplanSponserBannerBox	=	'<div class="col-md-3 col-xs-12 pad0 psImageWidth"><div class="sponsor_details"><div class="top_block"></div></div></div>';
				var groupTemplateseparatorLineHomePage	=	'<div class="tile_seperator"></div>';
				var groupTemplateMedicalBalances ='<div class="col-md-6 col-md-12 col-xs-12 bg-white clearfix">';
				var groupTemplatColumns = '<ul class="col-xs-12 col-md-12 clearfix"></ul>';
				var groupTemplatColumn = '<li class="col-md-3 col-xs-12 pad0 text-center"></li>';
				var groupTemplateIconLinkBlock = '<div class="center-block clearfix"></div>';
				var groupTemplateTwoColumn = '<div class="My_Coverage stayHealthy col-md-12 col-xs-12 pad0 home-blocks "></div>';
				var groupTemplateMedicareTwoColumn = '<div class="My_Coverage dynamicTxt stayHealthy col-md-12 col-xs-12 pad0 home-blocks "></div>';
				//var groupTemplateColumnOne = '<div class="col-md-6 col-md-12 col-xs-12 bg-white clearfix "></div>';
				var groupTemplateCategoryBoxes = '<div class="col-sm-12 col-xs-12 "></div>';
				var groupTemplateOtherUseFulResources= '<div class="other_useful_resources"></div>';

				template = groupTemplate1;

				switch (attrs.type) {
				case 'columns':
					template = groupTemplatColumns;
					break;
				case 'column':
					template = groupTemplatColumn;
					break;
				case 'twoColumn':
					if(window.location.href.indexOf("providerSearchHome") > -1){
						template = groupTemplate1;
					}else if(window.location.href.indexOf("medicare") > -1){
						template = groupTemplateMedicareTwoColumn;
					}else {
						template = groupTemplateTwoColumn;
						
					}
					break;
				case 'columnTwo':
				case 'columnOne':
					template = groupTemplate1;
					break;
				case 'categoryBoxes':
					template = groupTemplateCategoryBoxes;
					break;
				case 'list':
					template = groupTemplate7;
					break;
				case 'boxes':
					template = groupTemplate1;
					break;
				case 'listitem':
					template = groupTemplateListItem;
					break;
				case 'category':
					template = groupTemplate7;
					break;
				case 'links':
						template = groupTemplateHeaderLinks;
					break;
				case 'box':
					template = groupTemplate1;
					break;
				case 'bsframe':
					template = groupTemplate0;
					break;
				case 'bscontainer':
					template = groupTemplate9;
					break;
				case 'bsbox':
					template = groupTemplate10;
					break;
				case 'linkblock':
					template = groupTemplate2;
					break;
				case 'pageTitle':
					template = groupTemplate3;
					break;
				case 'primary':
					template = groupTemplate7;
					break;
					//case 'homePrimary':
				case 'homeIconLinkBlock':
					//template = groupTemplate11;
					template = groupTemplate11;
					break;
				case 'secondary':
					template = groupTemplate8;
					break;
					/*case 'homePageGrouplinks':
                		template =groupTemplate12;
                		break;*/
				case 'sepratorLine':
					template =groupTemplate13;
					break;
				case 'imgText':
					template =groupTemplate14;
					break;
					//case 'homeBannerImg':
					/*case 'imageList':
	                		template =groupTemplate15;
	                		break;  */
				case 'primaryMenu':
					template =groupTemplate16;
					break;
				case 'contentTop':
					template = groupContentTop;
					break;
				case 'healthFundsContent':
					template = groupTemplateHealthFundsContent;
					break;
				case 'healthFundsType':
					template = groupTemplateHealthFundsType;
					break;
				case 'disclaimerInfo':
					template = groupTemplateDisclaimerInfo;
					break;
				case 'coverageOuterBox':
					template = groupTemplateCoverageOuterBox;
					break;
				case 'coverageInnerBox':
					template = groupTemplateCoverageInnerBox;
					break;
				case 'coverageCostImage':
					template = groupTemplateCoverageCostImage;
					break;
				case 'aetMainContainer':
					template = groupTemplateAetMainContainer;
					break;
				case 'coverageMainContainer':
					template = groupTemplateCoverageMainContainer;
					break;
				case 'coverageContainer':
					template = groupTemplateCoverageContainer;
					break;
				case 'coverageSubLinks':
					template = groupTemplateCoverageSubLinks;
					break;

				case 'disclaimerPage':
					template = groupTemplateDisclaimerPage;
					break;
				case 'disclaimerFooter':
					template = groupTemplateDisclaimerFooter;
					break;
				case 'urgentCareBox':
					template = groupTemplateUrgentCareBox;
					break;
				case 'urgentCareColumn':
					template = groupTemplateUrgentCareColumn;
					break;
				case 'urgentCareImage':
					template = groupTemplateUrgentCareImage;
					break;
				case 'urgentCareText':
					template = groupTemplateUrgentCareText;
					break;
				case 'urgentCareContainer':
					template = groupTemplateUrgentCareContainer;
					break;
				case 'images':
					if( attrs.parenttype == 'leftjustified' )
						template = groupTemplateHeaderImageWithSkipLink;
					else
						template = groupTemplateHeaderImage;
					break;
				case 'headerMenu':
					template = groupTemplateHeaderHeaderMenu;
					break;
				case 'headerLinks':
					template = groupTemplateHeaderLinks;
					break;
				case 'mobileMenuList':
					template = groupTemplateMobileMenuList;
					break;
				case 'homeMobileMenu':
					template = groupTemplateHomeMobileMenu;
					break;
				case 'alignAllIcons':
					template = groupTemplate7;
					break;
				case 'iconLinkBlock':
					template = groupTemplateIconLinkBlock;
					break;
				case 'iconLinkBlockPharmacy':
					template = groupTemplate17;
					break;

				case 'iconLinkBlockWellness':
					template = groupTemplate1;
					break;

				case 'urgentCareMainContainer':
					template = groupTemplateUrgentCareMainContainer;
					break;
				case 'urgentCareMyIneed':
					template = groupTemplateUrgentCareMyIneed;
					break;



				case 'overviewMainContainer':
					template = groupTemplateOverviewMainContainer;
					break;
				case 'aetTemplate':
					template = groupTemplateAetTemplate;
					break;
				case 'overviewTopLinks':
					template = groupTemplateOverviewTopLinks;
					break;
				case 'overviewContainer':
					template = groupTemplateOverviewContainer;
					break;
				case 'overviewList1':
					template = groupTemplateOverviewList1;
					break;
				case 'overviewList2':
					template = groupTemplateOverviewList2;
					break;
				case 'allignHomeBlocks':
					template = groupTemplate1;
					break;
				case 'fundBalanceBox':
					template = groupTemplate1;
					break;
				case 'medicalBox':
					template = groupTemplateMedicalBalances;
					break;
				};

				switch (attrs.nvstyle) {
				case 'topBorder':
					template = groupTemplate4;
					break;
				case 'top_Border':
					template = groupTemplate4;
					break;
				case 'contentLink':
					template = groupTemplate5;
					break;
				case 'bottomBorder':
					template = groupTemplate6;
					break;
				case 'discountPageTitle':
					template = groupTemplateDiscountPageTitle;
					break;
				case 'discountPageReadMoreSection':
					template = groupTemplateReadMore;
					break;
				case 'discountPageSeperator':
					template = groupTemplate1;
					break;
				case 'homePageUnordered':
					template = groupTemplate7; //groupTemplateUnordered;
					break;
				case 'homeIconLinkBlockColumns':
					template = groupTemplateColumns;
					break;
				case 'homeIconLinkBlockColumn':
					template = groupTemplateColumn;
					break;
				case 'fullWidthRowHomePageMultiPS':
					template = groupTemplateFullWidthRowHomePageMultiPS;
					break;
				case 'planSponserLinks':
					template = groupTemplatePlanSponserLinks;
					break;
				case 'planSponserHorizontalBoxList':
					template = groupTemplatePlanSponserHorizontalBoxList;
					break;
				case 'planSponserListItem':
					template = groupTemplateplanSponserListItem;
					break;
				case 'planSponserBanner':
					template = groupTemplateplanSponserBanner;
					break;
				case 'planSponserBannerBoxes':
					template = groupTemplateplanSponserBannerBoxes;
					break;
				case 'planSponserBannerBox':
					template = groupTemplateplanSponserBannerBox;
					break;
				case 'separatorLineHomePage':
					template = groupTemplateseparatorLineHomePage;
					break;
				case 'imageList':
					template =groupTemplate15;
					break;
				case 'usefulResourcesContent':
					// earlier "groupTemplateOtherUseFulResources" this template was used.
					template =groupTemplate1;
					break;
				case 'planListPageUnordered':
					template = groupTemplate7; //groupTemplateUnordered;
					break;
				};

				//Return Template.
				return template;
			},
			controller: 'NavGroupController'

		};
	}
})();

},{}],35:[function(require,module,exports){
(function() 		
{
	angular.module('nav-ui').service('SubHelperService', SubHelperService);
	SubHelperService.$inject = ['$http','$log','$document'];
	
	function SubHelperService($http,$log,$document) 
		{
			        var subHelpers = [];
					var addSubHelpers = function(subHelper){
						if(subHelper != '' && subHelper != undefined)
						{
							length = subHelpers.length;
							subHelpers[length] = subHelper;
						}
					};
					var getSubHelpers = function(){
						return subHelpers;
					};
					var showLinkBlocks = function (selectedMember){
						var helpers= "";
						if(subHelpers.length <= 0)
							return;
						for(i=0;i<subHelpers.length;i++)
						{
							if(i==0)
								helpers = helpers + subHelpers[i];
							else
								helpers = helpers + "," + subHelpers[i];
						}
					};
					var resetSubHelpers = function(){
						subHelpers = [];
					};
					
			return {
				addSubHelpers:addSubHelpers,
				getSubHelpers:getSubHelpers,
				resetSubHelpers:resetSubHelpers,
				showLinkBlocks:showLinkBlocks
			}
		}
})();
	
},{}],36:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.controller('NavImageController', NavImageController);

	NavImageController.$inject = ['$scope', '$element', '$attrs', '$compile', '$rootScope', 'PageBuilderService','$sessionStorage', '$location','$state','LanguageDataService'];

	function NavImageController($scope, $element, $attrs, $compile, $rootScope, PageBuilderService,$sessionStorage, $location, $state, LanguageDataService) {
		var node = PageBuilderService.getNodeInfo($attrs.id);
		var parent = PageBuilderService.getNodeInfo($attrs.parent);

		//This will help uncaching of images
		function getSource(src) {
			try{
				if(src == null || src == undefined)
					return;
				var name = 'v';
				var url = $('script[src*="?v="]')[0].src;
				if (!url)
					url = window.location.href;
				name = name.replace(/[\[\]]/g, "\\$&");
				var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
				results = regex.exec(url);
				if (!results)
					return src;
				if (!results[2])
					return src;
				cacheParam =  decodeURIComponent(results[2].replace(/\+/g, " "));
				if(src && src.indexOf("?")==-1){
					src=src+"?v="+cacheParam;
				}
				return src;
			}
			catch(er)
			{
				return src;
			}
		}

		$scope.brandingCharsArray=[];
		if (node) {
			//$attrs.ngSrc = node.url;
			$element[0].src = getSource(node.url);

			if(node.attributeMap && node.attributeMap.type)
			{
				switch (node.attributeMap.type) {
				case 'urgentCareIcons':
					$element.addClass('left-icon');
					break;
				case 'urgentCareBlueArrow':
					$element.addClass('arr-icon-blue');
					break;
				case 'menuCollapse':
					$element.wrap('<button type="button" class="menu-button">');
					var $parent    =   angular.element($element.parent());
					$parent.wrap('<li>');
					$element.addClass('menu-mobile-icon');
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						switch (childNode.nodeName) {
						case 'label':
							$parent.append('<span class="nav-list-blk">'+childNode.nodeValue+'</span>');
							break;
						}
					}

					break;

				case 'overviewImage':
					$element.addClass('padL5');
					break;

				case 'psLogo':
					$element.addClass('aet-sponser-logo');
					$element.attr("title","Sponsor Logo");
					break;



				}
			}


			if(parent && parent.attributeMap && parent.attributeMap.type)
			{
				switch (parent.attributeMap.type) {

				case 'pageTitle':
					$element.addClass('aet-cont-hdrtxt pull-right');

					$element.wrap("<div id='aet-content-hdrtxttwo' class='aet-content-hdrtxt'>");
					break;
					// case 'homePageLinks':
					/*for (var i = 0; i < node.childNodeList.length; i++) {
                        var $parentDiv = angular.element(document.getElementById($attrs.parent));
                        var $secondChild = angular.element($parentDiv.children()[i]);
                        $secondChild.append($element);
                        $compile($secondChild)($rootScope);
                         $element.wrap("<li class='col-xs-12 width20 bottom-border home_group "+parent.attributeMap.style+"' data-colorshade='canbPink'><a href='"+linkUrlArray[parent.attributeMap.style]+"' class='center-block i-need-scroll clearfix'><div class='widthImg40'>");
                     }*/

					//break;
				case 'imgText':
					$element.addClass('down-arrow');

					break;

				case 'nursline':
					$element.wrap("<div class='col-xs-2'>");

					break;
				case 'iconLinkBlock':
					$element.wrap("<div class='image-block'>");
					break;
				case 'iconLinkBlockWellness':
					if (window.location.href.indexOf("mpeLandingPage") > -1){
						$element.wrap("<div class='image-block'>");
					}
					break;
				case 'iconLinkBlockPharmacy':
					if (window.location.href.indexOf("pharmacy") > -1){
						$element.wrap("<div class='image-block'>");
						// $element.wrap("<div class='blue-bg'>");
					}
					break;

				case 'note':
					if(window.location.href.indexOf("mpechooseMemebr") != -1){

						$element.wrap('<span class="icon-block icon-block-purple">');
					}else{


						var $parentDiv = angular.element(document.getElementById($attrs.parent));
						var $firstChild = angular.element($parentDiv.children()[0]);
						var $secondChild = angular.element($parentDiv.children()[1]);
						var $thirdChild = angular.element($parentDiv.children()[2]);
						var $forthChild = angular.element($parentDiv.children()[3]);
						$firstChild.addClass('padR5');
						$forthChild.addClass('padL5');
						var text   =  $secondChild.html();
						$secondChild.html('');
						$secondChild.append($firstChild);
						$secondChild.append(text);
						$thirdChild.append($forthChild);
						$secondChild.append($thirdChild);
					}

					break;
				case 'seperatorLine':
					if (window.location.href.indexOf("pharmacy") > -1){
						//if(parent.attributeMap.background=='Pharmacy'){
						var $parentDiv = angular.element(document.getElementById($attrs.parent));
						var $firstChild = angular.element($parentDiv.children()[0]);
						$firstChild.append($element);
					}

					break;
				case 'navText':
					//$rootScope.displayh1    =   'display:none';
					$element.wrap('<h1 class="aet-cont-hdrtxt" style="display:none">');

					var childNode = node.childNodeList[1];
					switch (childNode.nodeName) {
					case 'label':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							var $parent = angular.element($element.parent());
							//$parent.attr('nvstyle',$element.attr('nvstyle'));
							$parent.addClass($element.attr('nvstyle')+'Marker');
							$parent.append(childNode.nodeValue);
							$compile($parent)($rootScope);
						}
						break;
					default:
						break;
					}

					break;
					//case 'homeBannerImg':
					/*case 'imageList':
                    $element.addClass('hidden-xs hidden-sm');

                  break;*/
				case 'images':
					var $parentDiv  =   angular.element('.navigator-logos');
					angular.element($parentDiv.append($element));
					var vImage = '';
					var imageUrlPart1='';
					var imageUrlPart2='';
					var wrapperUrl='';
					var wrapperTitle='';
					if($sessionStorage!=null && ($sessionStorage.brandingCharacteristicsResponse=="" || $sessionStorage.brandingCharacteristicsResponse==undefined)){
						vImage = "images/aetna-logo.png";
						wrapperUrl="#/contentPage?page=providerSearchLanding";
						wrapperTitle="Aetna Logo";

						if($state.params.site_id){
							wrapperUrl = wrapperUrl + "&site_id="+$state.params.site_id;
							}
						else{
							wrapperUrl = wrapperUrl + "&site_id=dse";
						}
						var langInUrl = $state.params.language;
						
						if (langInUrl == null || langInUrl == undefined || langInUrl !== "es") {
							wrapperUrl = wrapperUrl + "&language=en";
						}else{
							wrapperUrl = wrapperUrl + "&language="+$state.params.language;
						}					

						if($location.search().planValue){
							wrapperUrl = wrapperUrl + "&planValue="+$location.search().planValue;
						}
					}
					else{
						$scope.brandingCharsArray= $sessionStorage.brandingCharacteristicsResponse.readCorrespondenceARMSRulesResponse.correspondenceARMSRulesCharacteristics;
						for(var counter = 0; counter < $scope.brandingCharsArray.length; counter++){
							if($scope.brandingCharsArray[counter].name=="Secure Logo Location"){
								imageUrlPart1=$scope.brandingCharsArray[counter].value;
							}
							if($scope.brandingCharsArray[counter].name=="LogoFileName"){
								imageUrlPart2=$scope.brandingCharsArray[counter].value;
							}


						}
						vImage=imageUrlPart1+imageUrlPart2;
						if((imageUrlPart1.indexOf("Aetna_Blue") > -1)){
							wrapperTitle="Aetna Logo";
							wrapperUrl="#/contentPage?page=providerSearchHome";
						}
						else if((imageUrlPart1.indexOf("Innovation_Health_Blue") > -1)){
							wrapperTitle="Innovation Health Logo";
							wrapperUrl="http://www.innovation-health.com/";
						}
						else{
							wrapperTitle="";
							wrapperUrl="";
						}
					}
					wrapperUrl = wrapperUrl + '&openPleats';
					var tempElement=$('.txtAlgCntrHeader');
					var langData = LanguageDataService.getLanguageData();
					if(langData.JV_LOGO_REDIRECT == 'ON'){
						wrapperUrl = langData.JV_LOGO_URL;
					}
					if(tempElement.length==0){
						$element.attr( "src",getSource(vImage));
						//$element.wrap('<div class="txtAlgCntr pad10" style="min-height:71px">');
						// Removing pad10 class from Aetna logo coz ARMS is sending logo with white background where we dont need padding
						$element.wrap('<div class="txtAlgCntrHeader" style="min-height:71px">');
						$element.wrap('<button class="menu-logo" id="menuButtonId">');
					}
					else{
						if($element.attr('nvstyle') === 'hidePSinMobile'){
								$element.wrap('<a href="'+wrapperUrl+'" title="'+wrapperTitle+'" class="pad5Imp aet-logo hidden-xs" id="brandingLogoId">');
						}else{
								$element.wrap('<a href="'+wrapperUrl+'" title="'+wrapperTitle+'" class="pad5Imp aet-logo" id="brandingLogoId">');
						}
						var $parent = angular.element($element.parent());
						$('.txtAlgCntrHeader').append(angular.element($element.parent()));
					}

					//angular.element('.navbar-header').html($parentDiv);
					break;

				case 'headerMenuImage':
					var $parent = angular.element($element.parent());
					var image  =   angular.element($parent.children('img')).remove();
					var $parentHtml = $parent.html();
					$parent.html('');
					$parent.append($element);
					$parent.append($parentHtml);
					break;

				}


			}
			if(parent && parent.attributeMap && parent.attributeMap.style){
				switch (parent.attributeMap.style) {

				//console.log(parent.parent.attributeMap.style);
				case 'canbPink':
				case 'pearlBlue':
				case 'purpuleShade':
				case 'green':
				case 'teal':
					var $liTag	=	angular.element('.nav-tabs').children('li').last();
					var $aTag	=	angular.element($liTag.children('a'));
					$aTag.append($element);
					$element.wrap("<div class='widthImg40'>");
					break;
				case 'homeIconLinkBlock':
					$element.addClass('down-arrow');
					angular.element('.left-block').last().parent().append($element);
					break;
				case 'linkHomePageMultiPS':
				case 'planSponserLink':
				case 'newTabLink':
				case 'planSponserBannerLink':
				case 'planSponserAppid':
					break;
				case 'planSponserBannerBox':
					angular.element('.top_block').last().append($element);
					break;

				case 'imageList':
					$element.addClass('hidden-xs hidden-sm');
					break;

				default:
					if(node.attributeMap && node.attributeMap.type)
					{
						switch (node.attributeMap.type) {
						case 'nextImgBtn':
							$element.addClass('show-mobile');
							break;
						}
					}
					else{
						/*The below line was commented as it was affecting the links on provSearch Page
                 $element.wrap("<div class='col-xs-2 pad0'>");
                 $element.addClass('left-img');*/
						$element.addClass('padL5');
					}
				break;
				}
			}
			if(node.attributeMap && node.attributeMap.style)
			{
				switch (node.attributeMap.style) {

				case 'digicertLink':
					var hostNameString = $location.host();
					if(hostNameString.indexOf("aetna.com") > -1){
						$element.wrap('<a href="https://seal.digicert.com/seals/popup/?tag=Mkbhx6Gg&url=qamember.aetna.com&cbr=1484319282915">');
					}
					else if(hostNameString.indexOf("innovationhealth.myplanportal.com") > -1){
						$element.wrap('<a href="https://seal.digicert.com/seals/popup/?tag=gybJaR-k&url=qamember.innovationhealth.myplanportal.com&cbr=1490685206765">');
					}
					else if(hostNameString.indexOf("texashealthaetna.myplanportal.com") > -1){
						$element.wrap('<a href="https://seal.digicert.com/seals/popup/?tag=gybJaR-k&url=qamember.texashealthaetna.myplanportal.com&cbr=1490685206765">');
					}
					else{
						$element.wrap('<a href="https://seal.digicert.com/seals/popup/?tag=Mkbhx6Gg&url=qamember.aetna.com&cbr=1484319282915">');
					}

					break;
				case 'externalLink':
					$element.addClass('mrgnB0 padL5');
					break;
				case 'customCenterImg':

				$element.parent().addClass('row');
				$element.parent().addClass('customLinkDiv');
				if(window.location.href.indexOf("providerSearchLanding") == -1
				&& window.location.href.indexOf("providerSearchPlanList") == -1
				&& window.location.href.indexOf("providerResults") == -1
				&& window.location.href.indexOf("providerDetails") == -1
				&& window.location.href.indexOf("providerHospDetails") == -1
				&& window.location.href.indexOf("providerHospDetails") == -1){
										$element.parent().addClass('customSecMar');
				}
				if(window.location.href.indexOf("providerAlternativeMedicine") > -1){
							$element.parent().addClass('customSecMarT')
				}
				if(parent.childNodeList.length == 1){
						$element.addClass('visible-xs');
				}
				if(window.location.href.indexOf("providerDetails") > -1 || window.location.href.indexOf("providerHospDetails") > -1 || window.location.href.indexOf("providerDetails") > -1){
					$element.addClass('marginTop');
				}
				var langData = LanguageDataService.getLanguageData();
				if(langData.SWITCH_HIDE_PSLOGO_BOTTOM == 'ON'){
					$element.addClass('hidden-sm hidden-md hidden-lg');
				}
					break;
					/* case 'pullLeft':
										 	$element.addClass('left-icon');
											break; */
				case 'img-icon':
					$element.addClass('img-mrgn');
					break;
				case 'greenTick':
					$element.addClass('ht20wd20');
					break;
				case 'previous':
					$element.addClass('marL5'); // this is added for spanish directories and resources arrow images
					break;
				}
			}
			if(parent && parent.nodeName.indexOf("column") > -1 )
			{
				var $parentDiv = angular.element(document.getElementById($attrs.parent));
				var $secondChild = angular.element($parentDiv.children()[1]);
				$secondChild.append($element);
				$compile($secondChild)($rootScope);

			}
			if(parent && parent.nodeName.indexOf("appid") > -1)
			{
				var $parentDiv = angular.element(document.getElementById($attrs.parent));
				var $secondChild = angular.element($parentDiv.children()[0]);
				$secondChild.append($element);
				$compile($secondChild)($rootScope);

			}
		}

		if (node.childNodeList) {
			for (var i = 0; i < node.childNodeList.length; i++) {
				var childNode = node.childNodeList[i];

				switch (childNode.nodeName) {
				case 'url':
					if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
						if(childNode.nodeValue=='images/small-green-tick.png'){
							$element.attr('style','padding-right:5px');
						}
						$element.attr('src',getSource(childNode.nodeValue));
					}
					break;
				case 'src':
					if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
						$element.attr('src',getSource(childNode.nodeValue));
					}
					break;
				case 'alttext':
					if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
						if(childNode.nodeValue=="arrow" || childNode.nodeValue=="blue arrow image"){
							$element.attr('alt',"");
							if(window.location.href.indexOf("directoryAndResources") !== -1 || window.location.href.indexOf("qualityAndCostInfo") !== -1 ||
								      window.location.href.indexOf("savingsAndDiscounts") !== -1 || window.location.href.indexOf("importantInfo") !== -1){
								$element.attr('class','marL5');
							}
						}else{
							$element.attr('alt',childNode.nodeValue);
						}
					}
					break;
				default:
					break;
				}

			}
		}
	}
})();

},{}],37:[function(require,module,exports){
(function() {
  angular
		.module('nav-ui')
  	.directive('navImage', navImage);

  	function navImage() {
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: '<img></img>',
        controller: 'NavImageController'
      };  		
  	}
})();
},{}],38:[function(require,module,exports){
(function () {

	angular
	.module('nav-ui')
	.controller('NavLinkController', NavLinkController);

	NavLinkController.$inject = ['$scope', '$element', '$attrs', '$compile', '$window', '$rootScope', 'PageBuilderService','$state' , 'NavSpinnerService', '$sessionStorage', '$timeout','$uibModal','ProviderSearchCriteriaService','CommonUtilsService','LanguageDataService'];

	function NavLinkController($scope, $element, $attrs, $compile, $window, $rootScope, PageBuilderService,$state, NavSpinnerService, $sessionStorage, $timeout,$uibModal,ProviderSearchCriteriaService,CommonUtilsService,LanguageDataService){

		$scope.criteria = ProviderSearchCriteriaService.getCriteria();
		$scope.languageData = LanguageDataService.getLanguageData();
		var siteId = $scope.criteria.siteId;
		var language = $scope.criteria.language;
		$scope.mySessionVar = -1;
		$scope.showCount = true;
		//$scope.mySessionVar = $sessionStorage.unreadMsgCount;
		/*if(undefined==$sessionStorage.unreadMsgCount){
    		$sessionStorage.unreadMsgCount = 0;
    		SMCService.unreadMessageCount().then(function success(smcResponse) {

    			SMCService.getPHRPharmacyAlerts().then(
    				function success(alertsResponse){
    					if(alertsResponse.alertList){
    						$sessionStorage.unreadMsgCount = $sessionStorage.unreadMsgCount+alertsResponse.alertList.length;
    						if(parseInt($sessionStorage.unreadMsgCount)>0){
    						if(angular.element('.myMessageCounter')){
    							$timeout(function(){
    					    		$scope.showCount = true;
    					    		$scope.mySessionVar = $sessionStorage.unreadMsgCount;
    					    		angular.element('.myMessageCounter').css('visibility','visible');
    					    		angular.element('.myMessageCounter').text($sessionStorage.unreadMsgCount);
    					    	}, 100);

    						}
    						}
    					}
    				}, function error(alertsResponse){

    				});


				if (smcResponse != null) {
					$scope.unreadMsg = parseInt(smcResponse.unreadMessageCount);
					$scope.totalCount = $scope.unreadMsg;
					$sessionStorage.unreadMsgCount = $scope.totalCount+$sessionStorage.unreadMsgCount;
					console.log("count called once -- count :: "+$sessionStorage.unreadMsgCount);
					if (parseInt($sessionStorage.unreadMsgCount)>0){
					if(angular.element('.myMessageCounter')){
						$timeout(
								function(){
				    		$scope.showCount = true;
				    		$scope.mySessionVar = $sessionStorage.unreadMsgCount;
				    		angular.element('.myMessageCounter').css('visibility','visible');
				    		angular.element('.myMessageCounter').text($sessionStorage.unreadMsgCount);
				    	},
				    	100);

					}
					}
				}

			}, function error(smcResponse) {
				console.log("Error");
				console.log(smcResponse);
				$scope.inboxError = smcResponse;

			});
    	}*/

		$scope.mySessionVar = $sessionStorage.unreadMsgCount;

		if($sessionStorage.unreadMsgCount>0){
			$scope.showCount = false;
		}

		var node = PageBuilderService.getNodeInfo($attrs.id);
		var parent = PageBuilderService.getNodeInfo($attrs.parent);

		var showPaypremiumPopup = 'false';

		var ESAPI = require('node-esapi');

		// Loop through all Child Nodes
		if (node && node.childNodeList) {

			// if (parent && parent.attributeMap) {
			//     console.log("Hi HI hi");
			// }



			if (parent && parent.attributeMap && parent.attributeMap.type) {

				switch (parent.attributeMap.type) {
				case 'primary':
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							//$element[0].childNodes[0].href = childNode.nodeValue;
							$element[0].childNodes[0].href = "javascript:void(0)";

							var html = '<span class="pull-right arrowDesk"></span>';
							var $elementAnchor = angular.element($element[0].childNodes[0]);
							$elementAnchor.addClass("menuLink");
							$elementAnchor.append(html);
							$compile($element)($rootScope);
							break;
						case 'label':
							$element[0].childNodes[0].innerHTML = ESAPI.encoder().encodeForHTML( childNode.nodeValue );
							$element.attr('menuto', childNode.nodeValue);
							break;
						case 'title':
							$element[0].childNodes[0].title = childNode.nodeValue;
							break;
						case 'navkey':
							var htmlElement = $element[0].childNodes[0];
							for (var j = 0; j < htmlElement.attributes.length; j++) {
								if (htmlElement.attributes[j].name == "navkey") {
									htmlElement.attributes[j].nodeValue = childNode.nodeValue;
								}
							}
							break;
						default:
							break;
						}

					}

					break;
				case 'secendryMenu':



					var secondaryMenuHrefArrayDefault  =   {
						'#/contentPage?page=providerSearch':'sec-level-nav canbLevel',
						'#/contentPage?page=findUrgentCare':'sec-level-nav mobile-level-nav',
						'#/contentPage?page=claimListing':'borderLeftGrey sec-level-nav blueLevel',
						'#/contentPage?page=eobDetail':'sec-level-nav mobile-level-nav',
						'#/contentPage?page=coverageCost':'borderLeftGrey sec-level-nav hidden-xs hidden-sm',
						'#/contentPage?page=coverageBenefits':'sec-level-nav purpleLevel',
						'#/memberPayEst':'sec-level-nav hidden-xs hidden-sm',
						'#/contentPage?page=balanceLimits':'sec-level-nav hidden-xs hidden-sm',
						'#/aetnaHealthFunds':'sec-level-nav hidden-xs hidden-sm',
						'#/stayHealthy':'borderLeftGrey sec-level-nav greenLevel',
						'#/discounts':'sec-level-nav hidden-xs hidden-sm',
						'#/incentives':'sec-level-nav hidden-xs hidden-sm',
						'#/contentPage?page=cvsPharmacy':'borderLeftGrey sec-level-nav tealLevel',
						'#/contentPage?page=mailcvsPharmacy':'sec-level-nav hidden-xs hidden-sm',
						'#/contentPage?page=speccvsPharmacy':'sec-level-nav hidden-xs hidden-sm'
				};

					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						$element.addClass(node.attributeMap.style+'Marker');
						$element.attr('style','display:none');
						//$element.attr($rootScope.activeMenuClass);


						switch (childNode.nodeName) {
						case 'url':
							//   $element[0].href = childNode.nodeValue;
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);         $element.addClass(secondaryMenuHrefArrayDefault[childNode.nodeValue]);
							}
							break;
						case 'label':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
							}
							break;
						case 'title':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('title',childNode.nodeValue);
							}
							break;
						default:
							break;
						}

					}
					break;

				case 'homePageGrouplinks':
					$element.wrap("<li class='col-xs-12 width20 bottom-border home_group "+node.attributeMap.styleName+"' data-colorshade='canbPink'>");
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							$element[0].childNodes[0].innerHTML = ESAPI.encoder().encodeForHTML( childNode.nodeValue );
							$element.attr('menuto', childNode.nodeValue);

							break;
						case 'title':
							$element[0].childNodes[0].title = childNode.nodeValue;
							break;
						case 'navkey':
							var htmlElement = $element[0].childNodes[0];
							for (var j = 0; j < htmlElement.attributes.length; j++) {
								if (htmlElement.attributes[j].name == "navkey") {
									htmlElement.attributes[j].nodeValue = childNode.nodeValue;
								}
							}
							break;
						default:
							break;
						}

					}
					break;
				case 'note':
					$element.addClass('bold');
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							//   $element[0].href = childNode.nodeValue;
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
							}
							break;
						case 'title':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('title',childNode.nodeValue);
							}
							break;
						default:
							break;
						}

					}
					break;


				case 'category':
					if (window.location.href.indexOf("pharmacy") > -1 || window.location.href.indexOf("formsLib") > -1){/*
						$element.wrap('<li>');
						for (var i = 0; i < node.childNodeList.length; i++) {
							var childNode = node.childNodeList[i];

							switch (childNode.nodeName) {
							case 'url':
								//   $element[0].href = childNode.nodeValue;
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									if(node.attributeMap.window == 'popUp'){
										$element.addClass('pointer');
										$element.attr('ng-click',childNode.nodeValue);
										$compile($element)($rootScope);

									}
									else if(node.attributeMap.window == 'redirect'){
										$element.attr('href',childNode.nodeValue);
										$element.attr('ng-click','onClickTag($event)');
										$compile($element)($rootScope);

									}
									else if(node.attributeMap.window == 'newTab'){
										$element.attr('target','_blank');
										$element.attr('href',childNode.nodeValue);

									}
									else if(node.attributeMap.window == 'openIframe'){
										$element.addClass('pointer');
										$element.attr('href',childNode.nodeValue);
										$element.attr('ng-click','showSSOLink($event)');
										$compile($element)($rootScope);
									}
								}
								break;
							case 'label':
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.append(childNode.nodeValue);
								}
								break;
							case 'title':
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.attr('title',childNode.nodeValue);
								}
								break;
							default:
								break;
							}

						}
						$scope.onClickTag = function(objtarget){
							var obj = objtarget.target;
							console.log(obj.target);
							if(obj.text="Medicare pharmacy EOBs"){
								$sessionStorage.callingPageName='pharmacy';
							}


						};
						$scope.showSSOLink = function(objtarget){
							var obj = objtarget.target;
							NavSpinnerService.spin();
							obj.target="iFrameSSO";
							document.getElementById("iFrameSSODiv").style.display="";
							document.getElementsByClassName("SSOLinkShow")[0].style.display="none";
							document.getElementsByClassName("SSOLinkShow")[1].style.display="none";


						};
						$scope.getFeatureAPIUrl();
						$scope.orderDetail = function(code){
							NavSpinnerService.spin();
							//AnalyticsService.trackView(code,8);
							$scope.orderKey = $sessionStorage.stateKey;
							$rootScope.pharmacyAPIResult = "";
							$rootScope.pharmacyAPIResult = 'https://sit1fast.caremark.com/checkdrugcosts/v1.5/#/?apiKey=6ccc59e0-a851-454b-a495-87117bef4ba5&apiSecret=a0904244-47e5-4a46-8893-2e86973c5fc2&fenv=sit1&tokenid=001A007E5F6136B6BA4AD78707D171D9&faststyle=aetnaCore';
                                $rootScope.orderCode = code;
                                 NavSpinnerService.stop();

							if($scope.isMyAssistantUser) {
								$rootScope.orderCode = "MYASSISTANCE";
								NavSpinnerService.stop();
							} else {
									 CvsHomePageService.getJSON($scope.orderKey , code).then(
											function success(result) {
												$rootScope.pharmacyAPIResult = result;
												NavSpinnerService.stop();
												$rootScope.orderCode = code;
												console.log($rootScope.pharmacyAPIResult);
											},
											function error (errorMsg) {
												$rootScope.orderCode = "ERROR";
												console.log(" Failure12367 ");
												NavSpinnerService.stop();
											}
									);
							 }
						};
					*/}
					else if (window.location.href.indexOf("mpeLandingPage") > -1){/*
						$element.wrap('<li>');
						for (var i = 0; i < node.childNodeList.length; i++) {
							var childNode = node.childNodeList[i];

							switch (childNode.nodeName) {
							case 'url':
								//   $element[0].href = childNode.nodeValue;

								$element.addClass('pointer');


								break;
							case 'label':
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.append(childNode.nodeValue);
								}
								break;
							case 'title':
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.attr('title',childNode.nodeValue);
								}
								break;
							default:
								break;
							}

						}
					*/}
					break;
				case 'primaryMenu':

                    for (var i = 0; i < node.childNodeList.length; i++) {
                       var $parentDiv = angular.element(document.getElementById($attrs.parent));
                       var $firstChild = angular.element($parentDiv.children()[0]);
                       var $secondGrandChild = angular.element($firstChild.children()[1]);
                       $secondGrandChild.append($element);
                       $compile($secondGrandChild)($rootScope);
                    }
                        $element.wrap("<li role='menuitem' class='col-xs-12 home_group pad0'>");
                        $element.addClass('center-block pad0 col-xs-12 mobileClick');

                        for (var i = 0; i < node.childNodeList.length; i++) {
                                   var childNode = node.childNodeList[i];

                                   switch (childNode.nodeName) {
                                   case 'url':
                                    //   $element[0].href = childNode.nodeValue;
                                       if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
                                           $element.attr('href',childNode.nodeValue);
                                       }
                                       break;
                                   case 'label':
                                       if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
                                           $element.append('<div class="left-block col-xs-10 pad0"><p class="menu-list-txt"><span parent="link_24" id="textSpan_28" type="textSpan" class="ng-scope">'+childNode.nodeValue+'</span></p></div>');
                                       }
                                       break;
                                   case 'title':
                                           $element.attr('role',"link");
                                       break;
                                   default:
                                       break;
                                   }

                               }

                        $rootScope.menuColor    = '';

                   break;

					//case 'tabMenu':
				case 'secondaryTabMenu':

					var secondaryMenuHrefArrayDefault  =   {
						'P1S1':'sec-level-nav canbLevel',
                        'P1S2':'sec-level-nav mobile-level-nav',
                        'P2S1':'borderLeftGrey sec-level-nav blueLevel',
                        'P2S2':'sec-level-nav mobile-level-nav',
                        'P3S1':'borderLeftGrey sec-level-nav hidden-xs hidden-sm',
                        'P3S2':'sec-level-nav purpleLevel',
                        'P3S3':'sec-level-nav hidden-xs hidden-sm',
                        'P3S4':'sec-level-nav hidden-xs hidden-sm',
                        'P3S5':'sec-level-nav hidden-xs hidden-sm',
                        'P4S1':'borderLeftGrey sec-level-nav greenLevel',
                        'P4S2':'sec-level-nav hidden-xs hidden-sm',
                        'P4S3':'sec-level-nav hidden-xs hidden-sm',
                        'P5S1':'borderLeftGrey sec-level-nav tealLevel',
                        'P5S2':'sec-level-nav hidden-xs hidden-sm',
                        'P5S3':'sec-level-nav hidden-xs hidden-sm'
                    };

                    var secondaryTabMenuElement =   angular.copy($element);
                    var secondaryTabMenuElementParent  =   angular.element('.second-navigation');
                    var secondaryTabMenuElementChild   =   angular.element(secondaryTabMenuElementParent.children());
                    secondaryTabMenuElementChild.append(secondaryTabMenuElement);

					secondaryTabMenuElement.addClass(parent.attributeMap.style+'Marker');
					secondaryTabMenuElement.attr('style','display:none');

                    var $parentDiv = angular.element(document.getElementById($attrs.parent));
                    $parentDiv.addClass('col-xs-11 nested-list');
                    $parentDiv.attr('style','display:none');
                     $element.addClass('center-block pad0 col-xs-12 subMenuMobiView');

					//$(".mobileClick").on('click', function() {
					var navKeyArray    =   {};
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							//   $element[0].href = childNode.nodeValue;
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
								secondaryTabMenuElement.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
								secondaryTabMenuElement.append(childNode.nodeValue);
							}
							break;
						case 'title':

							secondaryTabMenuElement.attr('role','tab');
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('title',childNode.nodeValue);
								secondaryTabMenuElement.attr('title',childNode.nodeValue);
							}
							break;
						case 'navkey':
							secondaryTabMenuElement.addClass(secondaryMenuHrefArrayDefault[childNode.nodeValue]);
							navKeyArray[childNode.nodeValue]   =   node.childNodeList[0].nodeValue;
							navKeyArray[childNode.nodeValue+'Url']   =   node.childNodeList[1].nodeValue;
							break;
						case 'group':
							$scope.getNavkey(childNode.childNodeList[0]);
							break;
						default:
							break;
						}


					}
					var temp    =   angular.copy($sessionStorage.navMenuTotalList);

					if(temp!=undefined){
						angular.extend(temp, navKeyArray);
						$sessionStorage.navMenuTotalList    = angular.copy(temp);
					}
					else{
						$sessionStorage.navMenuTotalList    = angular.copy(navKeyArray);
					}

					//console.log($sessionStorage.navMenuTotalList);


					break;

				case 'homePageLinks':

					var $parentDiv = angular.element(document.getElementById($attrs.parent));
					var $Child = angular.element($parentDiv.parent()[0]);
					$Child.append($element);

					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								//$element.attr('href',childNode.nodeValue);
								/*$scope.getFeatureAPIUrl(node.attributeMap.background);
                                $scope.$watch('featureUrl', function() {
                                    $element.attr('href',$scope.featureUrl);
                                }); */
							}
							break;
						case 'label':
							$element[0].childNodes[0].innerHTML = '<span class="shadow-l" style="position: absolute;"></span>'+ESAPI.encoder().encodeForHTML( childNode.nodeValue );
							$element.attr('menuto', childNode.nodeValue);

							break;
						case 'title':
							$element[0].childNodes[0].title = childNode.nodeValue;
							break;
						case 'navkey':
							var htmlElement = $element[0].childNodes[0];
							for (var j = 0; j < htmlElement.attributes.length; j++) {
								if (htmlElement.attributes[j].name == "navkey") {
									htmlElement.attributes[j].nodeValue = childNode.nodeValue;
								}
							}
							break;
						default:
							break;
						}

					}

					break;

				case 'headerMenu':

					var $parentDiv = angular.element(document.getElementById($attrs.parent));

					if(node.attributeMap.mobileTop=='false'){

						angular.element($element.wrap('<li style="display:none">'));
					}
					else{angular.element($element.wrap('<li>'));}

					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						//console.log(childNode);
						switch (childNode.nodeName) {
						case 'url':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							/*if(childNode.attributeMap.type=='badge'){
                                    if(parseInt($sessionStorage.unreadMsgCount)>0){
                                    $element.append('<span class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                    }else{
                                    	$element.append('<span style="visibility:hidden" class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                    }
                                }
                                if(childNode.attributeMap.type=='text'){
                                    $element.append('<span class="nav-list-blk">'+childNode.nodeValue+'</span>');
                                }*/
							// Change done for public provider search
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
							}
							break;
						case 'title':
							$element.attr('title',childNode.nodeValue);
							break;
							/*default:
                                break;*/
						}
					}
					break;

				case 'headerLinks':

					var $parentDiv = angular.element(document.getElementById($attrs.parent));
					if(CommonUtilsService.checkIfURLIsThere(node.childNodeList)){
						angular.element($element.wrap('<li>'));
						var navKeyArray    =   {};
						for (var i = 0; i < node.childNodeList.length; i++) {
							var childNode = node.childNodeList[i];
							//console.log(childNode);
							switch (childNode.nodeName) {
							case 'url':
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.attr('href',childNode.nodeValue);
								}
								break;
							case 'label':
								// Change done for public provider search
								if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
									$element.append(childNode.nodeValue);
								}
								break;
							case 'title':
								$element.attr('title',childNode.nodeValue);
								if(childNode.nodeValue=='Home'){$element.addClass('home-util');}
								break;
							case 'navkey':
								navKeyArray[childNode.nodeValue]   =   node.childNodeList[3].nodeValue;
								navKeyArray[childNode.nodeValue+'Url']   =   node.childNodeList[1].nodeValue;
								break;
								/*default:
                                break;*/
							}
						}
						var temp    =   angular.copy($sessionStorage.navMenuTotalList);

						if(temp!=undefined){
							angular.extend(temp, navKeyArray);
							$sessionStorage.navMenuTotalList    = angular.copy(temp);
						}
						else{
							$sessionStorage.navMenuTotalList    = angular.copy(navKeyArray);
						}
					}
					break;
				case 'links':
					if(parent.attributeMap.style == 'headerLinks'){
						var $parentDiv = angular.element(document.getElementById($attrs.parent));
						if(CommonUtilsService.checkIfURLIsThere(node.childNodeList)){
							angular.element($element.wrap('<li>'));
							var navKeyArray    =   {};
							for (var i = 0; i < node.childNodeList.length; i++) {
								var childNode = node.childNodeList[i];
								//console.log(childNode);
								switch (childNode.nodeName) {
								case 'url':
									if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
										$element.attr('href',childNode.nodeValue);
										$element.attr('target','_blank');
										if(childNode.nodeValue.indexOf('toggleLanguage')>=0){
											$element.attr('ng-click','toggleLanguageFunction()');
											$element.attr('href','');
											var url= window.location.href;
											var currentLang= getLanguageParameter('language',url)
											if(currentLang=='en'){
												$element.attr('lang','es');
											}
											else{
												$element.attr('lang','en');
											}
											$compile($element)($scope);
										}//below changes are made for medicare transformation project
										else if(childNode.nodeValue.indexOf('newMedicareSearch')>=0)
											{
											$element.attr('ng-click','startNewSearch()');
											$element.attr('href','');
											}
									}
									break;
								case 'label':
									// Change done for public provider search
									if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
										$element.append(childNode.nodeValue);
									}
									break;
								case 'title':
									$element.attr('title',childNode.nodeValue);
									if(childNode.nodeValue=='Home'){$element.addClass('home-util');}
									break;
								case 'navkey':
									navKeyArray[childNode.nodeValue]   =   node.childNodeList[3].nodeValue;
									navKeyArray[childNode.nodeValue+'Url']   =   node.childNodeList[1].nodeValue;
									break;
									/*default:
	                                break;*/
								}
							}
							var temp    =   angular.copy($sessionStorage.navMenuTotalList);

							if(temp!=undefined){
								angular.extend(temp, navKeyArray);
								$sessionStorage.navMenuTotalList    = angular.copy(temp);
							}
							else{
								$sessionStorage.navMenuTotalList    = angular.copy(navKeyArray);
							}
						}
						break;
					}

				case 'mobileMenuList':

					var $parentDiv = angular.element(document.getElementById($attrs.parent));
					//var $childDiv = angular.element($parentDiv.children());
					angular.element('.mobile-list-new').append($element);
					angular.element($element.wrap('<li>'));
					$element.addClass('mobileMenuList');
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						//console.log(childNode);
						switch (childNode.nodeName) {
						case 'url':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							/*if(childNode.attributeMap.type=='badge'){
                                	if(parseInt($sessionStorage.unreadMsgCount)>0){
                                        $element.append('<span class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                        }else{
                                        	$element.append('<span style="visibility:hidden" class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                        }

                                }
                                if(childNode.attributeMap.type=='text'){
                                    $element.append(childNode.nodeValue);
                                }*/
							// Change done for public provider search
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
							}
							break;
						case 'title':
							$element.attr('title',childNode.nodeValue);
							if(childNode.nodeValue=='Home'){$element.addClass('home-util');}
							break;
							/*default:
                                break;*/
						}
					}

					angular.element(".mobileMenuList").unbind().click(function(){
						if($(window).width() <= 768){
							if($(this).parent('.nested-list').css('display') == "none"){
								console.log('none');
								$(this).parent('.nested-list').fadeIn();
								$(this).parent('.home-down-arrow').addClass('home-up-arrow');
							}else{
								$('.nested-list').fadeOut();
								$('.home-down-arrow').removeClass('home-up-arrow');
								$(".menu-list, .menu-overlay").fadeOut();
							}
						}
					});

					break;

				case 'homeMobileMenu':

					var $parentDiv = angular.element(document.getElementById($attrs.parent));
					var $ulElement = angular.element(angular.element('.home-mobile-menu').children('ul'));
					$ulElement.append($element);
					angular.element($element.wrap('<li>'));
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						switch (childNode.nodeName) {
						case 'url':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.attr('href',childNode.nodeValue);
							}
							break;
						case 'label':
							/*if(childNode.attributeMap.type=='badge'){

                                	if(parseInt($sessionStorage.unreadMsgCount)>0){
                                        $element.append('<span class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                        }else{
                                        	$element.append('<span style="visibility:hidden" class="myMessageCounter badge badge-important">'+$scope.mySessionVar+'</span>');
                                        }
                                }
                                if(childNode.attributeMap.type=='text'){
                                    $element.append(childNode.nodeValue);
                                }*/
							// Change done for public provider search
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								$element.append(childNode.nodeValue);
							}
							break;
						case 'title':
							$element.attr('title',childNode.nodeValue);
							break;
							/*default:
                                break;*/
						}
					}

					break;

				case 'homeIconLinkBlock':
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {

						case 'label':
							if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
								var getPara	=	angular.element('.HILBMenu').last().children();
								if(getPara.length==0){
									angular.element('.HILBMenu').last().append('<span class="font-16">'+childNode.nodeValue+'</span><br>');
								}else{
									angular.element('.HILBMenu').last().append('<span class="font21">'+childNode.nodeValue+'</span>');
								}
							}
							break;
						case 'url':
							var $aTag	=	angular.element('.bottom-border').last().children('a');
							$aTag.attr('href',childNode.nodeValue);
							break;
						default:
							break;
						}

					}
					break;

				default:

					if(node.attributeMap.mobileTop=='false'){$element.hide();}

				for (var i = 0; i < node.childNodeList.length; i++) {
					var childNode = node.childNodeList[i];

					switch (childNode.nodeName) {
					case 'url':
						//   $element[0].href = childNode.nodeValue;
						if(childNode.nodeValue!= undefined && childNode.nodeValue!=""){
							var linkhref =   childNode.nodeValue;
							if(linkhref && linkhref.indexOf("?page=")!= -1){
								if(childNode.nodeValue.indexOf("&storeURL=") > -1){
									var beforeStoreUrl= linkhref.substring(0, childNode.nodeValue.indexOf("&storeURL="));
									var storeUrl = linkhref.substring(childNode.nodeValue.indexOf("&storeURL="));
									linkhref = beforeStoreUrl+'&site_id='+siteId+'&language='+language+storeUrl;
								}else{
									var linkhref_siteId = getLanguageParameter('site_id', linkhref);
									var linkhref_lang = getLanguageParameter('language', linkhref);
									if(linkhref_siteId==null && linkhref_lang==null){
									                        linkhref = linkhref+'&site_id='+siteId+'&language='+language;
									}
									else if(linkhref_siteId==null){
									        linkhref = linkhref+'&site_id='+siteId;
									}
									else if(linkhref_lang==null){
									        linkhref = linkhref+'&language='+language;
									}
								}

							}
							if(node.attributeMap && node.attributeMap.style && node.attributeMap.style == 'purple_button'){
								$element.attr('class', 'member_btn purple_button');
								$element.children().attr('href',linkhref);
								$element.attr('linkToReplace',linkhref);
								$element.children().attr('target', '_blank'); 
								//$element.children().attr('class', 'purple_button');
							} else {
							   $element.attr('href',linkhref);
							   $element.attr('linkToReplace',linkhref);
							}
							if(childNode.nodeValue.indexOf("page=providerSearchGeo") > -1){
								$element.attr('onClick',"javascript: sessionStorage.setItem('boolForGeo', true)");
							}
							if(node.attributeMap && node.attributeMap.style && (node.attributeMap.style == 'register_button' || node.attributeMap.style == 'secure_button')){
								if(window.location.href.indexOf("providerSearchLanding") > -1){
									$element.attr("target","_blank");	
								}
							}

							if(window.location.href.indexOf("directoryAndResources") !== -1 || window.location.href.indexOf("qualityAndCostInfo") !== -1 ||
								      window.location.href.indexOf("savingsAndDiscounts") !== -1 || window.location.href.indexOf("importantInfo") !== -1){
										$element.attr('class', 'normalFont');
								        $element.parent().attr('class','marB10');
								        $element.attr('target', '_blank');
							}
						}
						break;
					case 'label':
					    if(node.attributeMap && node.attributeMap.style && node.attributeMap.style == 'purple_button'){
							$element.children().append(childNode.nodeValue);
						} else
						if(childNode.nodeValue!= undefined && childNode.nodeValue!=""){
						if(node.attributeMap && node.attributeMap.style && (node.attributeMap.style == 'register_button' || node.attributeMap.style == 'secure_button')){
								if(window.location.href.indexOf("providerSearchHome") > -1){
									$element.html(childNode.nodeValue);
									$element.addClass("primaryBtn previousStep");
									$element.wrap("<a href="+node.url+" target='_blank'>");
									//  $element.find('.primaryBtn .previousStep').append(childNode.nodeValue);
									//  $element.find('.primarylbl').append(childNode.nodeValue);
								}else if(window.location.href.indexOf("providerSearchLanding") > -1){
										if(node.attributeMap && node.attributeMap.style && node.attributeMap.style == 'purple_button'){
											//$element.find('.purple_button').append(childNode.nodeValue);
										}
										else if(node.attributeMap.style == 'secure_button'){
												$element.find('.primarySecurePurple').append(childNode.nodeValue);
										}else{
												$element.find('.primaryPurple').append(childNode.nodeValue);
										}
								}else{
									$element.find('.primarylbl').append(childNode.nodeValue);
								}
							}
							else
								$element.append(childNode.nodeValue);
						}
						break;
					case 'title':
					    if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.attr('title',childNode.nodeValue);
						}
						break;
						// case 'image':
						//    if(window.location.href.indexOf("providerSearchHome") > -1){
						//       $element.addClass("padL10");
						// 	}
						//     break;
					default:
						break;
					}

				}

				break;
				}
			}else{
				for (var i = 0; i < node.childNodeList.length; i++) {
					var childNode = node.childNodeList[i];

					switch (childNode.nodeName) {
					case 'url':
						//   $element[0].href = childNode.nodeValue;
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.attr('href',childNode.nodeValue);
						}
						break;
					case 'label':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.append(childNode.nodeValue);
						}
						break;
					case 'title':
						if(childNode.nodeValue!=undefined && childNode.nodeValue!=""){
							$element.attr('title',childNode.nodeValue);
						}
						break;
					case 'image':
						$element.append(PageBuilderService.processNodeIndividually(childNode.nodeName, childNode));
						break;
					default:
						break;
					}

				}
			}

			if(node.attributeMap && node.attributeMap.style){
				switch (node.attributeMap.style) {
				case 'linkParagraph':
					$element.wrap("<p>");
					break;
				case 'linkHomePageMultiPS':
					angular.element('.multiPSLink').children('p').append($element);
					break;
				case 'homeIconLinkBlockBelowButton':
					angular.element('.home_group').last().append($element);
					var elemChildP	=	angular.copy(angular.element($element.children('p')));
					angular.element($element.children('p')).remove();
					var elementInnerHtml	=	$element.html();
					elemChildP.append(elementInnerHtml);
					$element.html(elemChildP);

					var $parentUl	=	angular.element($element.siblings('ul'));
					var $parentDiv	=	angular.element($element.siblings('div'));
					if($parentUl!=undefined && $parentUl!=''){$parentUl.remove();}
					if($parentDiv!=undefined && $parentDiv!=''){$parentDiv.remove();}
					break;
				case 'planSponserLink':
					angular.element('.sponsor_links').last().append($element);
					break;
				case 'planSponserBannerLink':
					angular.element('.sponsor_details').last().append($element);
					$element.wrap('<div class="content_block">');
					angular.element('.content_block').last().append('<p class="mrgnT10 PSBPara"></p>');
					break;
				case 'planSponserBannerInnerLink':
					angular.element('.PSBPara').append('&nbsp;');
					angular.element('.PSBPara').append($element);
					break;
				case 'customCenterLink':
					if($('.customCenterImg')[0] == undefined){
						$element.parent().addClass('row');
						$element.parent().addClass('customLinkDiv');
						if(window.location.href.indexOf("providerSearchLanding") == -1
						&& window.location.href.indexOf("providerSearchPlanList") == -1
						&& window.location.href.indexOf("providerResults") == -1
						&& window.location.href.indexOf("providerDetails") == -1
						&& window.location.href.indexOf("providerHospDetails") == -1
						&& window.location.href.indexOf("providerOrgDetails") == -1){
												$element.parent().addClass('customSecMar');
						}
					}
					$element.addClass('normalFtWt');
					$element.addClass('customLinkMob');
					$element.addClass('customLinkDesk');
					$element.attr("target","_blank");
				break;
				case 'homeExtraLinks':
					if(window.location.href.indexOf("providerSearchHome") > -1 || window.location.href.indexOf("providerSearchGeo") > -1 || window.location.href.indexOf("providerSearchLanding") > -1 ){
						if(($element.index() === 1) || ($element.index() === 2) || ($element.index() === 3)){
							$element.wrap('<div class="col-xs-12 extralinks_short pad0 topMrgin">');
						}
						else{
							$element.wrap('<div class="col-xs-12 extralinks_long pad0 topMrgin">');
						}
						$element.attr('target','_blank');
					}
					break;
				case 'content_with_link':
					$element.attr('target','_blank');
					$element.css('display','inline-block');
				break;
				case 'newTabLink':
					$element.attr('target','_blank');
				break;
				case 'otherProvLinks':
					var a=window.location.href.split("=");
					if(window.location.href.indexOf("providerSearchSpecialists") > -1 ||
							window.location.href.indexOf("providerSearchPrimaryCare") > -1 ||
							window.location.href.indexOf("providerSearchTherapists") > -1 ||
							(window.location.href.indexOf("providerMedical") > -1) ||
							(window.location.href.indexOf("providerSearchHome") > -1) ||
							(window.location.href.indexOf("providerSearch") > -1) ||
							(window.location.href.indexOf("providerSearchGeo") > -1) ||
							(window.location.href.indexOf("providerSearchPlanList") > -1) ||
							(window.location.href.indexOf("providerResults") > -1) ||
							(window.location.href.indexOf("providerDetails") > -1) ||
							(window.location.href.indexOf("providerHospDetails") > -1) ||
							(window.location.href.indexOf("providerHospitalsAndFacilities") > -1) ||
							(window.location.href.indexOf("providerBehavioralHealth") > -1) ||
							(window.location.href.indexOf("findUrgentCare") > -1) ||
							(window.location.href.indexOf("providerAlternativeMedicine") > -1) ||
							(window.location.href.indexOf("providerVision") > -1) ||
							(window.location.href.indexOf("providerLabAndTesting") > -1) ||
							(window.location.href.indexOf("providerProceduresAndConditions") > -1) ||
							(window.location.href.indexOf("provider") > -1) ||
							(window.location.href.indexOf("providerOrgDetails") > -1)){
						if($element.index() === 1){
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							//$element.wrap('<div class="col-xs-12 resource_directories pad0 topMrgin">');
						}
						else if($element.index() === 2){
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							// $element.wrap('<div class="col-xs-12 resource_print pad0 topMrgin">');
						}
						else if($element.index() === 3){
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							// $element.wrap('<div class="col-xs-12 resource_quality pad0 topMrgin">');
						}
						else if($element.index() === 4){
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							// $element.wrap('<div class="col-xs-12 resource_other pad0 topMrgin">');
						}
						else if($element.index() === 5){
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							// $element.wrap('<div class="col-xs-12 resource_savings pad0 topMrgin">');
						}
						else{
							$element.attr('target','_blank');
							$element.addClass('otherResourceMar');
							$element.addClass('otherResourceMob');
							// $element.wrap('<div class="col-xs-12 col-md-2 pad0 topMrgin">');
						}
					}else{
						$element.attr('target','_blank');
						$element.wrap('<div class="col-xs-12 col-md-2 pad0 topMrgin">');
					}

					break;
				default:
					break;
				}
			}

			if (parent) {
				if (parent.nodeName.indexOf("column") > -1) {
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];

						switch (childNode.nodeName) {
						case 'url':
							$element[0].childNodes[0].href = childNode.nodeValue;
							break;
						case 'label':
							$element[0].childNodes[0].innerHTML = ESAPI.encoder().encodeForHTML( childNode.nodeValue );
							break;
						case 'title':
							$element[0].childNodes[0].title = childNode.nodeValue;
							break;
						case 'navkey':
							var htmlElement = $element[0].childNodes[0];
							for (var j = 0; j < htmlElement.attributes.length; j++) {
								if (htmlElement.attributes[j].name == "navkey") {
									htmlElement.attributes[j].nodeValue = childNode.nodeValue;
								}
							}
							break;
						default:
							break;
						}

					}


					var $parentDiv = angular.element(document.getElementById($attrs.parent));
					var $secondChild = angular.element($parentDiv.children()[1]);
					$secondChild.append($element);
					$compile($secondChild)($rootScope);

				}
			}
		}

		if (node) {
			if (parent && parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == 'pageTitle') {
				$element.addClass('aet-cont-hdrtxt pull-right');
				$element.wrap("<div id='aet-content-hdrtxttwo' class='aet-content-hdrtxt'>");
			}
		}
		//code which supports menu in mobile starts here (shared by design team)
		$('.menuLink').click(function (event) {
			event.stopImmediatePropagation();
			$('.menuLink').parent().removeClass('active');

			if ($(this).next().hasClass('menuOf')) {
				$(this).parent().addClass('active');

				if ($(window).width() <= 767) {
					if (!$(this).parent().hasClass('mob-active')) {
						$('.menu > ul > li').removeClass('mob-active');
						$('.menu > ul > li').removeClass('closeItem');
						$('.second-level li a').parent().removeClass('active');
						$('.second-level li a').removeClass('minus');
						$('.second-level li a').addClass('plus');
						$(this).parent().addClass('mob-active');
					} else {
						$('.menu > ul > li').removeClass('mob-active');
						$(this).parent().addClass('closeItem');
					}
				}

			}

		});

		$('.second-level li a').click(function (event) {
			event.stopImmediatePropagation();
			var page = angular.element($window);
			if (page.width() <= 767) {
				if (!$(this).parent().hasClass('active')) {
					$('.second-level li a').parent().children('ul').removeClass('expand');
					$('.second-level li a').removeClass('minus');
					$('.second-level li a').addClass('plus');
					$('.second-level li a').parent().removeClass('active');

					$(this).parent().addClass('active');
					$(this).removeClass('plus');
					$(this).addClass('minus');
				} else {
					$('.second-level li a').parent().removeClass('active');
					$('.second-level li a').removeClass('minus');
					$('.second-level li a').addClass('plus');
				}

			}

		});
		//code which supports menu in mobile ends here (shared by design team)

		$scope.cancel = function () {
			$rootScope.orderCode="";
			$scope.orderURL="";
			$scope.modalInstance.dismiss();
		};
		$scope.isMyAssistantUser = false;

		$scope.getNavkey	=	function(nodeList){
			var navKeyArray    =   {};
			for (var i = 0; i < nodeList.childNodeList.length; i++) {
				var childNode = nodeList.childNodeList[i];

				switch (childNode.nodeName) {
				case 'navkey':
					navKeyArray[childNode.nodeValue]   =   nodeList.childNodeList[0].nodeValue;
					navKeyArray[childNode.nodeValue+'Url']   =   nodeList.childNodeList[1].nodeValue;
					break;
				case 'group':
					$scope.getNavkey(childNode.childNodeList[0]);
					break;
				default:
					break;
				}


			}
			var temp    =   angular.copy($sessionStorage.navMenuTotalList);

			if(temp!=undefined){
				angular.extend(temp, navKeyArray);
				$sessionStorage.navMenuTotalList    = angular.copy(temp);
			}
			else{
				$sessionStorage.navMenuTotalList    = angular.copy(navKeyArray);
			}
		};

		$scope.$watch('mySessionVar', function(newVal, oldVal) {
			if(parseInt(newVal)>0){
				$scope.showCount=true;
				var currentElement = angular.element('.myMessageCounter');
				currentElement.css('visibility','visible');
				currentElement.text(newVal);
			}


		}, true);
		function getLanguageParameter( name, url ) {
			 if (!url) url = location.href;
			 name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
			 var regexS = "[\\?&]"+name+"=([^&#]*)";
			 var regex = new RegExp( regexS );
			 var results = regex.exec( url );
			 return results == null ? null : results[1];
	 }
	}

})();

},{"node-esapi":65}],39:[function(require,module,exports){
(function() {

	angular.module('nav-ui').directive('navLink', navLink);

	function navLink() {
		return {
			restrict : 'E',
			replace : true,
			template : function(element, attrs) {
				var template = '';
				var groupTemplate1 = '<a></a>';
				var groupTemplate2 = '<li><a class="navigationLink" href title navKey=""></a></li>';
				var groupTemplate3 = '<a href="" class="center-block i-need-scroll clearfix tile-seperator-size"></a>';
				var groupTemplate4 = '<a href="" class="pos-rel-block"><p class="primarylbl buttonpad"><span class="shadow-l" style="position: absolute;"></span></p></a>';
				var groupTemplate5 = '<a href="" class="blue-font"></a>';
				var groupTemplate6 = '<a href="#" class="clearfix"></a>';
				var groupTemplateSecureBut = '<a class="loginSecureButLink padR15 secbutPadT22" href title navKey=""><p class="primarySecurePurple BtnWidth buttonpad buttLan"></p></a>';
				var groupTemplateLanding = '<a class="" href title navKey=""><p id="emptyLink" class="primaryPurple BtnWidth buttonpad buttLan"></p></a>';
				var groupTemplateMedRegister = '<a class="" href title navKey=""><p class="purple_button BtnWidth buttonpad buttLan"></p></a>';
				var groupTemplateHeaderMenu = '<a></a>';
				var groupTemplateHomeIconLinkBlock	=	'<div class="left-block"><p class="marT10 HILBMenu"></p></div>';
				var buttonTemplate = '<a class="pos-rel-block" href="#"><p class="primarylbl buttonpad"><span class="shadow-l" style="position: absolute;"></span></p></a>';
				var buttonLTemplate = '<a class="" href="#"><p id="buttonEmptyLink" class="primaryPurple BtnWidth buttonpad buttLan"></p></a>';
				var groupTemplateButton = '<button></button>';
				var groupTemplateHomeIconLinkBlockBelowButton	=	'<a class="pos-rel-block" href="#"><p class="primarylbl buttonpad"><span class="shadow-l" style="position: absolute;"></span></p></a>';
				switch (attrs.parenttype) {
				case 'primary':
					template = groupTemplate2;
					break;

				case 'homePageGrouplinks':
					template = groupTemplate3;
					break;

				//case 'homePageLinks':
				case 'homeIconLinkBlock':
					//template = groupTemplate4;
					template = groupTemplateHomeIconLinkBlock;
					break;

				case 'urgentCareLinks':
					template = groupTemplate6;
					break;
				case 'note':
					template = groupTemplate1;
					break;

				case 'basicLink':
					template = groupTemplate5;
					break;
				case 'headerMenu':
					template = groupTemplateHeaderMenu;
					break;

				default:
					if (attrs.parent.indexOf("columnTwo") > -1) {
						template = groupTemplate1;
					} else if (attrs.parent.indexOf("column") > -1) {
								if((window.location.href.indexOf("providerSearchLanding") > -1) && attrs.nvstyle == 'secure_button'){
									template = groupTemplateSecureBut;
								}else if((window.location.href.indexOf("providerSearchLanding") > -1) && attrs.nvstyle == 'register_button'){
									template = groupTemplateLanding;
								}else{
									template = groupTemplate2;
								}
					}else if (attrs.nvstyle == 'button') {
						if(window.location.href.indexOf("providerSearchHome") > -1){
							template = groupTemplateButton;
						}else if(window.location.href.indexOf("providerSearchLanding") > -1){
							template = buttonLTemplate;
						}else{
							template = buttonTemplate;
						}
					}
					else {
						template = groupTemplate1;
					}

					break;
				};

				switch(attrs.nvstyle){
					case 'linkHomePageMultiPS':
						template = groupTemplate1;
					break;
					case 'homeIconLinkBlockBelowButton':
						template = groupTemplateHomeIconLinkBlockBelowButton;
					break;
				};
				return template;
			},
			controller : 'NavLinkController'

		};
	}
})();

},{}],40:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavTextController', NavTextController);

  NavTextController.$inject = ['$scope', '$element', '$attrs', '$compile', '$rootScope', 'PageBuilderService','$sessionStorage','$interpolate','$location'];

  function NavTextController($scope, $element, $attrs, $compile, $rootScope, PageBuilderService, $sessionStorage,$interpolate,$location) {
  	var node = PageBuilderService.getNodeInfo($attrs.id);
  	if (node) {
  		var parent = PageBuilderService.getNodeInfo($attrs.parent);
  		if(parent.attributeMap && parent.attributeMap.type)
  		{
  			switch (parent.attributeMap.type) {
        	case 'pageTitle':
        		$element.addClass('aet-cont-hdrtxt pull-right');

      			$element.wrap("<div id='aet-content-hdrtxttwo' class='aet-content-hdrtxt'>");
      			break;

        	case 'imgText':
        		for (var i = 0; i < parent.childNodeList.length; i++) {
                    var $parentDiv = angular.element(document.getElementById($attrs.parent));
                    var $secondChild = angular.element($parentDiv.children()[i]);
                    $secondChild.append($element);
                    $compile($secondChild)($rootScope);

                 }
        		var $parentDiv = angular.element(document.getElementById($attrs.parent));
		        var $secondChild = angular.element($parentDiv.children()[0]);
			    var $secondFirstChild = angular.element($secondChild.children()[0]).addClass('font-16');
		            angular.element($secondChild.children()[1]).html('<br>');
		        var $secondSecondChild = angular.element($secondChild.children()[1]).addClass('font21');

		        break;

        	case 'tabMenu':
        		$element.addClass('home-mobile-list home-down-arrow');
                var $parentDiv = angular.element(document.getElementById($attrs.parent));
                var $Child = angular.element($parentDiv.parent());
                $Child.append($element);
                $compile($Child)($rootScope);
        		break;

        	case 'texth2':
        		        $element.addClass('aet-txt-look');
        		break;

        	case 'note':
        		$element.addClass('note-text');
        		break;

        	case 'seperatorLine':
        		if (window.location.href.indexOf("pharmacy") > -1){
        		  	$element.addClass('marT10');
        		}
        		break;

        	case 'linkCategories':
        	     if (window.location.href.indexOf("pharmacy") > -1 || window.location.href.indexOf("formsLib") > -1){
                     $element.wrap('<div class="hdr-pharmacy clearfix">');
                     $element.addClass('pha-hdr-txt');
       		    }
        		break;

        	case 'nursline':
                    $element.wrap('<div class="col-xs-10">');

                    if(node.attributeMap && node.attributeMap.type && node.attributeMap.type == "textSpan")
                    {
                    	$element.addClass('nurseSubSectionWithoutLink');
                    }

        		break;
        	case 'iconLinkBlock':
        		$element.addClass('text-normal');
        		break;
        	case 'categoryBoxes':
        		$element.addClass('pha-hdr-txt');
        		break;
			case 'textSpan':
        		if (window.location.href.indexOf("ahfNew") > -1 || window.location.href.indexOf("adfNew") > -1){
        		  	$element.addClass('header-right bold');
        		}
        		break;
  			}
  		}

  		if((parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == 'listitem')||(node.attributeMap && node.attributeMap.type && node.attributeMap.type =='textSpan'))
  		{
  			var contentPage = $location.search().page;
        	if(!contentPage){
        		var a=window.location.href.split("=");
        		contentPage = a[a.length-1];
        	}
  			if(contentPage=="ProductsDiscounts"
  				/*|| a[a.length-1]=="providerSearch"*/ /* Commented to remove Spaces before and after the links in important Information.*/
  			){
  				node.nodeValue = "&nbsp;" + node.nodeValue + "&nbsp;";
  			}
  		}


        if(parent.attributeMap && parent.attributeMap.style){
                 switch (parent.attributeMap.style) {
                 case 'intakeFormPageTitle':
                 case 'intakeFormCenterContent':
                 case 'discountPageContent':
                 case 'oneColumnCenterContent':
                 case 'categoryBoxesLinkBlock':
                 case 'disclaimerFooter':
                	 //do nothing
                	 break;
						default:

								var $parentDiv = angular.element(document.getElementById($attrs.parent));
		                         var $secondChild = angular.element($parentDiv.children()[1]);
		                        //  $element.wrap("<div class='left-block  col-xs-10 pad0'><p class='menu-list-txt'>");
		                         var $forthChild = angular.element($parentDiv.children()[3]);
		                         $forthChild.addClass('home-mobile-list home-down-arrow');
									break;


					}
        }
		if(parent.nodeName.indexOf("column") > -1 )
		{
		  		var $parentDiv = angular.element(document.getElementById($attrs.parent));
		  	  	var $secondChild = angular.element($parentDiv.children()[1]);
		  	  	$secondChild.append($element);
		  	  	$compile($secondChild)($rootScope);

		}

		var $nodeText = $.parseHTML(node.nodeValue);
		var textContent = '';
		if($nodeText != undefined  ||  $nodeText != null){
          for (var k=0; k<$nodeText.length; k++){
                if($nodeText[k].tagName=='BR' || $nodeText[k].tagName=='SUP' || $nodeText[k].tagName=='STRONG'|| $nodeText[k].tagName=='EM' || $nodeText[k].tagName=='B' || $nodeText[k].tagName=='P' || $nodeText[k].tagName=='A' || $nodeText[k].tagName=='UL' || $nodeText[k].tagName=='LI'){

                  if(node.attributeMap.type =="evaluate")
                      $element.append(parseContent($nodeText[k].outerHTML));
                    else
                      $element.append($nodeText[k].outerHTML);

                }else{
                  if($nodeText[k].childNodes.length>0){
                    runAllChildNodes($nodeText[k]);
                  }else{
                    if(node.attributeMap.type =="evaluate")
                      $element.append(parseContent($nodeText[k].textContent));
                    else
                        $element.append($nodeText[k].textContent);
                    textContent = $nodeText[k].textContent;
                  }
                }
          }
    }
		function parseContent(template) {
			return $interpolate(template)($scope);
		  };
		function runAllChildNodes($nodeText){

				for (var i = 0; i < $nodeText.childNodes.length; i++) {
					var childNode = $nodeText.childNodes[i];
					if(childNode.tagName=='BR' || childNode.tagName=='B' || childNode.tagName=='P' || childNode.tagName=='A' || childNode.tagName=='UL' || childNode.tagName=='LI'){
						if(node.attributeMap.type =="evaluate")
							$element.append(parseContent(childNode.outerHTML));
						else
						   $element.append(childNode.outerHTML);
					}else{
						if(node.attributeMap.type =="evaluate")
							$element.append(parseContent(childNode.textContent));
						else
						   $element.append(childNode.textContent);
						textContent = childNode.textContent;
					}
				}
		}

  		if(node.attributeMap && node.attributeMap.type){
	  		switch (node.attributeMap.type) {
  //to here

          case 'columnTwo':
        	  var contentPage = $location.search().page;
          		if(!contentPage){
          			var a=window.location.href.split("=");
          			contentPage = a[a.length-1];
          		}
              if(contentPage=="providerSearchHome"){
                  $element.after("<br/>");
              }
          break;

          case 'texth4':
        	  var contentPage = $location.search().page;
            if (node.attributeMap.style == 'usefulResourcesHeader'){
              //$element.before("<h3 class='sr-only'>Empty Heading</h3>");
               $element.addClass('padHomeB20');
            }else if(contentPage=="providerSearchLanding" && node.attributeMap.style=="extraLinkHomeHeader"){
               $element.addClass('padT10');
               $element.after("<br/>");
            }
          break;

          case 'texth1':
              if (node.attributeMap.style == 'blueBarHeadingStyle'){
                  $element.addClass('aet-cont-hdrtxt');
                  $element.wrap("<div class='aet-content-header planSelectionHeading ng-scope'><div class='container clearfix'><div class='col-md-10 col-xs-6 aet-content-hdrtxt pad0' id='aet-content-hdrtxtone'>");
                  $element.after("</div></div></div>");
              }
            break;

          case 'texth3':
					
		if (node.attributeMap.style == 'usefulResourcesHeader'){
                  $element.addClass('padHomeB20');
               }
        	  var contentPage = $location.search().page;
          		if(!contentPage){
          			 var a=window.location.href.split("=");
          			contentPage = a[a.length-1];
          		}
              if(contentPage=="providerSearch"){
                  $element.after("<br/>");
              }
              if((contentPage=="providerSearchHome" && parent.uniqueId.indexOf("columnTwo") != -1) ||
                 (contentPage=="providerSearchHome" && node.attributeMap.style=="extraLinkHomeHeader") ||
                    (contentPage=="providerSearchLanding" && node.attributeMap.style=="extraLinkHomeHeader")){
                 $element.addClass('padT10 padB10');
                 $element.after("<br/>");
              }
              if(contentPage=="providerSearchHome" && node.attributeMap.style=="usefulResourcesHeader"){
                  $element.before('<br>');
                  $element.before('<br>');
                  $element.after('<br>');
              }
              else if(contentPage=="providerSearchGeo" && (node.attributeMap.style=="usefulResourcesHeader" ||
            		  node.attributeMap.style=="extraLinkHomeHeader")){
                  $element.after('<br>');
              }

              if(window.location.href.indexOf("providerSearchLanding") != -1){
                  $element.addClass('aet-txt-look');
              }
          break;

	  			case 'texth2':
          if(window.location.href.indexOf("acuteCare") != -1 || window.location.href.indexOf("fitnessReimbursementProgram") != -1
	  						|| window.location.href.indexOf("worksiteServicesAHCDM") != -1
	  						|| window.location.href.indexOf("worksiteServicesWellnessCounseling") != -1
							|| window.location.href.indexOf("worksiteServicesBHEAP") != -1){
	  					$element.wrap("<div class='col-xs-10 col-sm-8 levelTwoPage-titleText'>");
	  			  }
	  			  else if(window.location.href.indexOf("mpeProviderPhysicianList_Page") != -1 || window.location.href.indexOf("mpeProviderFacilityList_Page") != -1 || window.location.href.indexOf("mpeOutOfNetwork_Page") != -1){

	  			  }
	  			  else if(window.location.href.indexOf("mpeLandingPage") != -1){
	  				 $element.addClass('pha-hdr-txt');
	  			  }
            else if (window.location.href.indexOf("providerSearchHome") > -1 || window.location.href.indexOf("providerSearchGeo") > -1){
                $element.addClass('padTB101');
            }
            else if (window.location.href.indexOf("providerSearchLanding") > -1){
              // var appendCntrl = angular.element(document.getElementById('ProviderControllerStart'));
              var appendCntrl = document.getElementsByClassName('ProviderControllerStart');

              $element.addClass('aet-txt-look padT10 padB10');
              if($element[0].attributes.parenttype.value == 'columnOne'  || $element[0].attributes.parenttype.value == 'columnTwo'){
                  $element.addClass('cusFontHtLanding purplePleatTitle');
                  if($element[0].attributes.parenttype.value == 'columnOne'){
                    $element.addClass('firstPleatHead');
                  }else if($element[0].attributes.parenttype.value == 'columnTwo'){
                    $element.addClass('secondPleatHead');
                  }
              }

              $compile(appendCntrl)($scope);
              // $element.wrap("<div>");
            }
	  				else{
          	     if (window.location.href.indexOf("page=providerSearch&") > -1){
         		  					$element.addClass('aet-txt-look domaineFont');
         		  					$element.wrap("<div class='aet-back-txt marBot15'>");
					        }
        					else if(!(window.location.href.indexOf("page=providerSearchLanding") > -1 || window.location.href.indexOf("page=providerSearchPlanList") > -1 || window.location.href.indexOf("page=providerResults") > -1)){
            						$element.addClass('aet-txt-look domaineFont');
          		  				$element.wrap("<div class='aet-back-txt'>");
        					}
      					 else{
        		  					$element.addClass('aet-txt-look');
        		  					$element.wrap("<div class='aet-back-txt'>");
        		  		}
                  if(window.location.href.indexOf("page=providerSearchPlanList") > -1){
                        $element.addClass('planListTexth2');
                        $element.children().css('font-size','20px');
                  }
	  				}
	  				break;

	  			case 'textParagraph':
	  				if(textContent!='' && textContent.indexOf(":")!=-1){
	  					$element.addClass('benfits-p');
	  				}
	  				else if(window.location.href.indexOf("mpechooseMemebr") != -1){
	  					 $element.wrap('<div class="stepWizardContainer">');
		               	  $element.wrap('<div class="container">');
		               	  $element.wrap('<div id="step1" class="stepContent">');
		               	  $element.wrap('<div class="row">');
		               	  $element.wrap('<div  class="col-xs-12 step1_SubContianer">');
	  					$element.addClass('grey-bg-block grey-bg-blockxml');

	  					$element.wrap('<div class="col-xs-12">');
	  					var $parentDiv = angular.element(document.getElementById($attrs.parent));

                        var imagespan=$parentDiv.children()[0];
	  					var stepwizard=angular.element($parentDiv.children()[1]);
	  					var container=angular.element(stepwizard.children()[0]);
	  					var stepContent=angular.element(container.children()[0]);
	  					var row=angular.element(stepContent.children()[0]);
	  					var step1_conatainer=angular.element(row.children()[0]);
	  					paragraphdiv=angular.element(step1_conatainer.children()[0]);
	  					paragraph=angular.element(paragraphdiv.children()[0]);
	  					var text=paragraph.html();
	  					paragraph.html('');
	  					paragraph.append(imagespan);
	  					paragraph.append(text);
	  				}
	  				else if(window.location.href.indexOf("mpeDisclaimer") != -1){
	  				var $parentDiv = angular.element(document.getElementById($attrs.parent));
	  				var $secondChild=angular.element($parentDiv.children()[2]);
	  				$secondChild.addClass('red-txt');
	  				}
	  				else if(window.location.href.indexOf("mpeLandingPage") != -1 && (parent.attributeMap && parent.attributeMap.style && parent.attributeMap.style == 'mpe')){



	  						 $element.wrap('<div class="col-xs-12 pad0">');
		       				 $element.wrap('<div class="note-buld-text">');
		       				 $element.wrap('<span class="icon-block icon-block-purple">');
		       				var $parentDiv = angular.element(document.getElementById($attrs.parent));
		       				var stepwizard=angular.element($parentDiv.children()[0]);
		       				var image=angular.element(stepwizard.children()[0]);
		       				var stepwizard1=angular.element($parentDiv.children()[1]);
		       				var stepwizard2=angular.element(stepwizard1.children()[0]);

		       				var span=angular.element(stepwizard2.children()[0]);
		       				var paragraph=angular.element(span.children()[0]);
		       				var text=paragraph.html();
		       				paragraph.html('');
		       				span.append(image);
		       				span.append(text);


	  		     }
            if(node.attributeMap && node.attributeMap.style && node.attributeMap.style == 'outOfGeoPlanDisclaimer'){
                $element.addClass('planDisclaimer');
                $element.attr("id", "outOfGeoPlanDisclaimer");
 	  		    }
	  				break;
	  			default:
	  				break;
			}
  		}

  		var parentAttributes = '';

		if(node.attributeMap && node.attributeMap.type && node.attributeMap.type =='homeIconLinkBlockTextSpan')
		{
			var $parent	=	angular.element($element.parent('li'));
			if($parent!=undefined && $parent!=''){
				var $parentSibling	=	angular.element($parent.parent('p'));
				var innerText	=	$element.html();
				$element.html('');
				$parentSibling.append(innerText);
				$parentSibling.append($element);
				$parent.remove();
			}
			if($sessionStorage !=undefined && $sessionStorage.homePageUnorderedLength!=undefined){
				var paraChildren	=	angular.element($parentSibling.children());
				if($sessionStorage.homePageUnorderedLength==paraChildren.length){
					$parentSibling.children().last().remove();
					$parentSibling.children().last().remove();
				}
			}
		}
		if(node.attributeMap && node.attributeMap.style)
		{
			if(node.attributeMap.style == 'paragraphHomePageMultiPS'){
				var $parent	=	angular.element($element.parent());
				if($parent!=undefined && $parent!=''){
					var $grandParent	=	angular.element($parent.parent());
					if($grandParent!=undefined && $grandParent!=''){
						$grandParent.remove();
					}
					$parent.remove();
				}
				angular.element('.multiPSLink').append($element);
			}
			if(node.attributeMap.style == 'planSponserLinksH2' || node.attributeMap.style == 'planSponserLinksParagraph'){

				var $parent1	=	angular.element($element.parent());
				if($parent1!=undefined && $parent1!=''){
					var $parent2	=	angular.element($parent1.parent());
					if($parent2!=undefined && $parent2!=''){
						$parent2.remove();
					}
					$parent1.remove();
				}
				var $child1	=	angular.element(angular.element('.sponserBlockOverall').children()[0]);
				$child1.append($element);
			}

			if(node.attributeMap.style == 'planSponserBannerH2' || node.attributeMap.style == 'planSponserBannerParagraph'){

				var $parent1	=	angular.element($element.parent());
				if($parent1!=undefined && $parent1!=''){
					var $parent2	=	angular.element($parent1.parent());
					if($parent2!=undefined && $parent2!=''){
						$parent2.remove();
					}
					$parent1.remove();
				}
				angular.element('.sponserBlockBanner').append($element);
			}

			if(node.attributeMap.style == 'planSponserBannerItsTime'){
				var $parent1	=	angular.element($element.parent());
				if($parent1!=undefined && $parent1!=''){
					var $parent2	=	angular.element($parent1.parent());
					if($parent2!=undefined && $parent2!=''){
						$parent2.remove();
					}
					$parent1.remove();
				}
				$element.addClass('its-time');
				angular.element('.top_block').last().append($element);
			}

			if(node.attributeMap.style == 'planSponserBannerParagraph1'){
				var para1InnerHtml	=	$element.html();
				angular.element('.PSBPara').html(para1InnerHtml);

				var $parent1	=	angular.element($element.parent());
				if($parent1!=undefined && $parent1!=''){
					var $parent2	=	angular.element($parent1.parent());
					if($parent2!=undefined && $parent2!=''){
						$parent2.remove();
					}
					$parent1.remove();
				}
				$element.remove();
			}
			if(node.attributeMap.style == 'planSponserBannerParagraph2'){
				var para2InnerHtml	=	$element.html();
				var PSBPara	=	angular.element('.PSBPara').html();
				PSBPara	=	PSBPara+' '+para2InnerHtml;
				angular.element('.PSBPara').html(PSBPara);

				var $parent1	=	angular.element($element.parent());
				if($parent1!=undefined && $parent1!=''){
					var $parent2	=	angular.element($parent1.parent());
					if($parent2!=undefined && $parent2!=''){
						$parent2.remove();
					}
					$parent1.remove();
				}
				$element.remove();
			}
			if(node.attributeMap.style == 'secondLineLanding'){
        $element.addClass('padSecondLine');
			}

		}
  	}
  }
})();

},{}],41:[function(require,module,exports){
(function () {

    angular
        .module('nav-ui')
        .directive('navText', navText);

    function navText() {
        return {
            restrict: 'E',
            replace: true,
            template: function (element, attrs) {
               var textTemplate = '';
               var textTemplate1 = '<div></div>';
               var textTemplate2 = '<h2></h2>';
              var texttagh1='<h1></h1>';
               //nmd
               var textTemplate3 = '<h3></h3>';
               var textTemplate4 = '<h4></h4>';
               var textTemplateSpan = '<span></span>';
               var textTemplatePara = '<p></p>';

               var textTemplateSpanHF = '<span class="backTo"></span>';
	       var textTemplateParaCoverage = '<p class="fontsize20 blue-font"></p>';
                var textTemplateParaUrgentCare = '<p class="fontsize24 blue-font"></p>';
				var textTemplateEmailUrgentCare = '<p class="blue-font"></p>';
				var textTemplatehomeIconLinkBlockTextSpan	=	'<span class="dot-list"></span>';
				var textTemplateParaInline = '<p class="urgentCareNurseLineText"></p>';

               switch (attrs.type) {
                case 'texth2':
                    textTemplate = textTemplate2;
                    break;
                case 'texth3':
                    textTemplate = textTemplate3;
                    break;
                case 'texth4':
                    textTemplate = textTemplate4;
                    break;
                case 'textSpan':
                    textTemplate = textTemplateSpan;
                    break;
                case 'textParagraph':
                    textTemplate = textTemplatePara;
                    break;

                case 'healthFundsTextSpan':
                	textTemplate = textTemplateSpanHF;
                	break;
		case 'textParagraphCoverage':
                	textTemplate = textTemplateParaCoverage;
                	break;
		case 'textParagraphUrgentCare':
                	textTemplate = textTemplateParaUrgentCare;
                	break;
		case 'emptyText'  :
                    textTemplate = textTemplateSpan;
                       break;
		case 'emailLinkUrgentCare' :
					textTemplate = textTemplateEmailUrgentCare;



                       break;
				case 'homeIconLinkBlockTextSpan':
					textTemplate = textTemplatehomeIconLinkBlockTextSpan;
					break;
				case 'texth1':
					textTemplate = texttagh1;
					break;
				case 'textParaInline' :
					textTemplate = textTemplateParaInline;
					break;
                default:
                    textTemplate = textTemplate1;
                    break;
               };

			   switch(attrs.nvstyle){
				   case 'paragraphHomePageMultiPS':
					textTemplate =	textTemplatePara;
					break;
				case 'planSponserLinksH2':
				case 'planSponserBannerH2':
					textTemplate =	textTemplate2;
					break;
				case 'planSponserLinksParagraph':
				case 'planSponserBannerParagraph':
					textTemplate =	textTemplatePara;
					break;
				case 'planSponserBannerItsTime':
					textTemplate =	textTemplateSpan;
					break;
			   };
               return textTemplate;
           }
           , controller: 'NavTextController'
        };
    };
})();

},{}],42:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavTitleController', NavTitleController);

  NavTitleController.$inject = ['$scope', '$element', '$attrs', 'PageBuilderService'];

  function NavTitleController($scope, $element, $attrs, PageBuilderService) {
  	var node = PageBuilderService.getNodeInfo($attrs.id);
  	if (node) {
  		$element.find('.aet-cont-hdrtxt').html(node.nodeValue);
  	}
  }
})();

},{}],43:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navTitle', navTitle);

  	function navTitle() {
    	return {
    	  restrict: 'E',
    	  replace: true,    	  
    	  template: '<div class="aet-content-fluid pageTitleDiv"> <div class="pull-left PageTitleTxt"><span class="aet-cont-hdrtxt"></span><span class="aet-whitesld-arr"></span></div></div>',
        controller: 'NavTitleController'
      };  		
  	}
})();
},{}],44:[function(require,module,exports){
(function() {

  angular
    .module('nav-ui')
    .controller('NavUnorderedListController', NavUnorderedListController);

  NavUnorderedListController.$inject = ['$scope', '$element', '$attrs', 'PageBuilderService'];

  function NavUnorderedListController($scope, $element, $attrs, PageBuilderService) {
  	var node = PageBuilderService.getNodeInfo($attrs.id);
  	var parent = PageBuilderService.getNodeInfo($attrs.parent);

  	if (node && node.attributeMap && node.attributeMap.type) {
  		switch (node.attributeMap.type) {
		case 'rows':

			if(parent.attributeMap && parent.attributeMap.type && parent.attributeMap.type == 'baselinks'){
				$element.addClass('aet-footer-nav clearfix marginFix');
                var parentDiv   =   angular.element($element.parent());
                parentDiv.addClass('container padL0');
                parentDiv.removeClass('aet-content-fluid');
			}
			break;
		default:
			break;
	}

  	}
  }
})();

},{}],45:[function(require,module,exports){
(function() {

  angular
		.module('nav-ui')
  	.directive('navUnorderedList', navBoxHeader);

  	function navBoxHeader() {
    	return {
    	  restrict: 'E',
    	  replace: true,
    	  template: '<ul></ul>',
        controller: 'NavUnorderedListController'
      };  		
  	}
})();
},{}],46:[function(require,module,exports){
(function() {

    angular
	.module('nav-ui')
	.service('AnalyticsService', AnalyticsService);

	AnalyticsService.$inject = ['$http', '$q', 'configuration', '$location', '$window', '$sessionStorage'];

	function AnalyticsService($http, $q, configuration, $location, $window, $sessionStorage) {

        var DTM_PAGE_LOAD = 'page load';
        var DTM_SEARCH = 'search';
        var DTM_LOGIN = 'login';
        var DTM_FORM = 'form';
        var DTM_LINK = 'link click';
        var DTM_CLAIM_CART = 'claim_cart';
        var DTM_CLAIM_CHECKOUT = 'claim_checkout';
        var DTM_FILTER = 'filter';
        var DTM_ERROR = 'error';
        var DTM_PLANSELECTION = "plan_selection";
        var DTM_COMPARE_CHECKOUT = "compare_checkout";
        var DTM_COMPARE = "compare";
        var DTM_FILTER_SORT_SEARCH = "fitler sort search";
        
        var LINK_TYPE_PAGE = 'page link';
        var LINK_TYPE_PANEL = 'panel expansion';
        var LINK_TYPE_DOWNLOAD = 'download link';
        

        var PROV_SEARCH = 'PROV_SEARCH';

        var providerLinkBlocks = [];
        var pageMap = {};

        if ($window.analyticsPageMap && $window.analyticsPageMap.pageMap) {
            pageMap = $window.analyticsPageMap.pageMap;
        }

        return {
            LINK_TYPE_PAGE: LINK_TYPE_PAGE,
            LINK_TYPE_PANEL: LINK_TYPE_PANEL,
            LINK_TYPE_DOWNLOAD: LINK_TYPE_DOWNLOAD,
            startAnalytics: startAnalytics,
            trackCenterContent: trackCenterContent,
            trackView: trackView,
            trackSearch: trackSearch,
            trackLocation: trackLocation,
            trackForm: trackForm,
            trackLink: trackLink,
            trackClaimCart: trackClaimCart,
            trackClaimCheckout: trackClaimCheckout,
            trackFilterDropdown: trackFilterDropdown,
            trackFilterRadio: trackFilterRadio,
            trackFilterCheckbox: trackFilterCheckbox,
            trackPlanSelection: trackPlanSelection,
            trackError:trackError,
            trackAnchorLinks: trackAnchorLinks,
            captureSearchDetails:captureSearchDetails,
            trackAddRemoveCompare:trackAddRemoveCompare,
            trackCompare : trackCompare,
            markFilterAndSort : markFilterAndSort
        };

        function trackLocation(event, newUrl) {

            try {
                if (pageMap && pageMap.views) {

                    var tracked = false;
                    var newPage = getPagePath();
                    var contentInfo;
                    var pageParams = getPageParams(  );
                    
                    contentInfo = pageMap.views[newPage];

                    if (contentInfo) {
                        tracked = true;
                        var pageName = contentInfo.pageName;
                        var channel = getChannelName(contentInfo);

                        if (contentInfo.exclude == undefined || (contentInfo.exclude && contentInfo.exclude == false)) {
                            trackPage(pageName, channel, pageParams);
                        }

                        if (contentInfo.providerSearch) {
                          //  trackSearch({category: pageName});
                        }
                    }

                    if (tracked == false) {
                        for (var i = 0; i < providerLinkBlocks.length; i++) {
                            if (providerLinkBlocks[i].url && providerLinkBlocks[i].url == ('#' + $location.url())) {
                                var pageName = getNodeValue(providerLinkBlocks[i], 'header', true);
                                var channel = getChannelName(pageMap.views[pageMap[PROV_SEARCH]]);
                                trackPage(pageName, channel, pageParams);
                               // trackSearch({category: pageName});
                                break;
                            }
                        }
                    }
                }
            } catch(e) {

            }
        }

        function getPagePath() {
            var newPage = $location.path();

            if (newPage == '/contentPage') {
                var parms = $location.search();
                if (parms && parms.page) {
                    newPage = newPage + '?page=' + parms.page;
                }
            }
            return newPage;
        }

        function getPageParams(  ) {
        	var newPage = $location.path();

        	var newPageParams = { site_id : '' , language : ''};
        	if (newPage ) {
        		var parms = $location.search();
        		if( parms )
        		{
        			if( parms.site_id )
        			{
        				newPageParams.site_id =  parms.site_id ;
        			}

        			if( parms.language )
        			{
        				newPageParams.language =  parms.language ;
        			}
        		}
        	}
        	return newPageParams;
        }
        
        
        function getChannelName(contentItem) {
            var channelName;

            if (pageMap && pageMap.channels && contentItem) {
                channelName = pageMap.channels[contentItem.channel];
            }
            return channelName;
        }

        function startAnalytics() {
            try {
                var analyticsDataPromise = getAnalyticsData().then(
                function(response) {
                    if (response && response.data && response.data.navAnalytics && response.data.navAnalytics.member) {

                        initDigitalData();

                        $window.digitalData.login.member = response.data.navAnalytics.member;

                        if ($sessionStorage.memberUserName && $sessionStorage.memberUserName != '') {
                            $window.digitalData.login.myassistant = true;
                        } else {
                            $window.digitalData.login.myassistant = false;
                        }

                        var checkManagedLoginPromise = checkManagedLogin().then(
                            function success(response) {
                                if (response && response.samlPartnerInfo && response.samlPartnerInfo.isUserComingFromPartner &&  response.samlPartnerInfo.isUserComingFromPartner == "true") {
                                    $window.digitalData.login.sso = true;
                                } else {
                                    $window.digitalData.login.sso = false;
                                }

                                satelliteTrack(DTM_LOGIN);
                            },
                            function error(response) {
                                satelliteTrack(DTM_LOGIN);
                            }
                        );
                    }
                });
            } catch(e) {

            }
        }

		function getAnalyticsData() {
      //
      //       var deferred = $q.defer();
      //
      //       NavFeaturesService.getFeaturesCached('AnalyticsAPI,samlPartnerInfoInquriyAPI')
			// .then(function success(response) {
      //
      //           for(var i = 0; i < response.length; i++) {
      //               if(response[i].featureEvaluatedResult == "true" && response[i].featureName == 'AnalyticsAPI') {
      //                   var featureUrl = response[i].featureUrl;
      //                   $http({
      //                       method: 'GET',
      //                       url: featureUrl,
      //                       params: {
      //                           stateKey: $sessionStorage.stateKey
      //                       },
      //                       headers: {accept: 'application/json'}
      //                   }).then(
      //                       function success(response) {
      //                           deferred.resolve(response);
      //                       },
      //                       function error(response) {
      //                           deferred.reject(response);
      //                       }
      //                   );
      //                   break;
      //               }
      //           }
      //
      //
      //       }, function error(response) {
      //           deferred.reject(response);
      //       });
      //
      //       return deferred.promise;
        }

		function checkManagedLogin() {
            //
            // var deferred = $q.defer();
            //
            // NavFeaturesService.getFeaturesCached('samlPartnerInfoInquriyAPI').then(
            //     function success(response) {
            //         if (response && response[0] && response[0].featureEvaluatedResult == "true") {
            //
            //             ProfileInqService.genericApiCallForFeatures(response[0].featureUrl, 'stateKey=' + $sessionStorage.stateKey, response[0].apiHttpMethod).then(
            //                 function(value){
            //                     deferred.resolve(value);
            //                 },
            //                 function(value){
            //                     deferred.reject(value);
            //                 }
            //             );
            //
            //         } else {
            //             deferred.resolve(response);
            //         }
            //     },
            //     function error(response) {
            //         deferred.reject(response);
            //     }
            // );
            //
            // return deferred.promise;
        }


        function initDigitalData() {

            var savedData;
            if ($window.digitalData) {
                savedData = $window.digitalData;
            }

            $window.digitalData = {};
            $window.digitalData.page = {};
            $window.digitalData.page.pageInfo = {};
            $window.digitalData.search = {};
            $window.digitalData.login = {};
            $window.digitalData.form = {};
            $window.digitalData.link = {};
            $window.digitalData.claims = [];
            $window.digitalData.filters = [];
            $window.digitalData.error = {};

            $window.digitalData.planSelection = {};
            $window.digitalData.compareProvider = [];
            	
            if (savedData) {
                $window.digitalData.page = savedData.page;
                $window.digitalData.login = savedData.login;
            }
        }

        function trackCenterContent(contentId, content) {

            try {
                var isLinkBlock = false;

                for (var i = 0; i < providerLinkBlocks.length; i++) {
                    if (providerLinkBlocks[i].url && providerLinkBlocks[i].url == ('#' + $location.url())) {
                        isLinkBlock = true;
                        break;
                    }
                }

                providerLinkBlocks = [];

                if (getPagePath() == pageMap[PROV_SEARCH] || isLinkBlock) {
                    getAllNodesWithAttributeType(content, 'linkblock', providerLinkBlocks);
                }
            } catch(e) {

            }
        }

        function getNodeByNodeName(node, nodeName, nestedSearch) {

            if (node.nodeName == nodeName) {
                return node;
            }

            if (nestedSearch && node.childNodeList) {
                for (var i = 0; i < node.childNodeList.length; i++) {

                    var childNode = node.childNodeList[i];
	                var retVal = getNodeByNodeName(childNode, nodeName, nestedSearch);

                    if (retVal) {
                        return retVal;
                    }
	            }
            }

            return false;
        }

        function trackView(pageName, channelNum) {
            try {
                trackPage(pageName, pageMap.channels[channelNum], {});
            } catch(e) {

            }
        }

        function trackPage(pageName, channel, pageParams ) {

        	try {
        		initDigitalData();

        		if (pageName) {
        			$window.digitalData.page.pageInfo.pageName = pageName.toLowerCase();
        		}

        		if (channel) {
        			$window.digitalData.page.pageInfo.channel = channel.toLowerCase();
        		}

        		if(pageParams)
        		{
        			if (pageParams.site_id) {
        				$window.digitalData.page.pageInfo.siteId = pageParams.site_id;
        			}

        			if (pageParams.language) {
        				$window.digitalData.page.pageInfo.language = pageParams.language;
        			}
        		}

        		satelliteTrack(DTM_PAGE_LOAD);
        	} catch(e) {

            }
        }

        function captureSearchDetails(apiURL)
        {
            try {
            	$window.digitalData.search = {};

                if (apiURL) {
                	var url = new URL(apiURL); 
                	var params = url.search ; 
                	console.log(params);
                	
                	if(url.searchParams )
                	{
                		if( url.searchParams.get('searchText') )
                		{
                			$window.digitalData.search.searchText =  url.searchParams.get('searchText') ;
                		}
                		if( url.searchParams.get('listFieldSelections') )
                		{
                			$window.digitalData.search.listFieldSelections =  url.searchParams.get('listFieldSelections') ;
                		}
                		if( url.searchParams.get('isGuidedSearch') )
                		{
                			$window.digitalData.search.isGuidedSearch =  url.searchParams.get('isGuidedSearch') ;
                		}
                		if( url.searchParams.get('responseLanguagePreference') )
                		{
                			$window.digitalData.search.responseLanguagePreference =  url.searchParams.get('responseLanguagePreference') ;
                		}
                		if( url.searchParams.get('state') )
                		{
                			$window.digitalData.search.state =  url.searchParams.get('state') ;
                		}
                		if( url.searchParams.get('distance') )
                		{
                			$window.digitalData.search.distance =  url.searchParams.get('distance') ;
                		}
                		if( url.searchParams.get('latitude') )
                		{
                			$window.digitalData.search.latitude =  url.searchParams.get('latitude') ;
                		}
                		if( url.searchParams.get('longitude') )
                		{
                			$window.digitalData.search.latitude =  url.searchParams.get('longitude') ;
                		}
                		if( url.searchParams.get('postalCode') )
                		{
                			$window.digitalData.search.postalCode =  url.searchParams.get('postalCode') ;
                		}
                		if( url.searchParams.get('firstRecordOnPage') )
                		{
                			$window.digitalData.search.firstRecordOnPage =  url.searchParams.get('firstRecordOnPage') ;
                		}
                		if( url.searchParams.get('lastRecordOnPage') )
                		{
                			$window.digitalData.search.lastRecordOnPage =  url.searchParams.get('lastRecordOnPage') ;
                		}
                		if( url.searchParams.get('siteId') )
                		{
                			$window.digitalData.search.siteId =  url.searchParams.get('siteId') ;
                		}
                		if( url.searchParams.get('providerID') )
                		{
                			$window.digitalData.search.siteId =  url.searchParams.get('providerID') ;
                		}
                		if( url.searchParams.get('order') )
                		{
                			$window.digitalData.search.order =  url.searchParams.get('order') ;
                		}
                		if( url.searchParams.get('listSelections') )
                		{
                			$window.digitalData.search.listSelections =  url.searchParams.get('listSelections') ;
                		}
                	}
                }
            } catch(e) {

            }
        }
        
        function trackSearch(data) {

            try {

                if (data) {
                	
                	$window.digitalData.search.searchResults = data;
                	
                	if( $window.digitalData.filterOrSort == true )
            		{
            			$window.digitalData.filterOrSort = false;
            			/*If the search was triggered by filter and/or Sort expose the search as sort filter search search*/ 
            			satelliteTrack(DTM_FILTER_SORT_SEARCH);
            			return;
            		}
                	
                	satelliteTrack(DTM_SEARCH);
                }
            } catch(e) {

            }
        }
        
        
        function trackPlanSelection(data) {

            try {
                initDigitalData();

                if (data) {

                    if (data.plan) {
                        $window.digitalData.planSelection.plan = data.plan;
                    }
                    
                    if (data.productCode) {
                        $window.digitalData.planSelection.productCode = data.productCode;
                    }
                    
                    if (data.pipeName) {
                        $window.digitalData.planSelection.pipeName = data.pipeName;
                    }
                    
                    if (data.site_id) {
                        $window.digitalData.planSelection.site_id = data.site_id;
                    }
                    
                    if (data.searchBoxTerm) {
                        $window.digitalData.planSelection.searchBoxTerm = data.searchBoxTerm;
                    }
                    
                   /* if (data.totalPlans) {
                        if (data.totalPlans == 0 || data.totalPlans == '0' || isNaN(data.totalPlans)) {
                            $window.digitalData.planSelection.totalPlans = 'zero';
                        } else {
                            $window.digitalData.planSelection.totalPlans = data.totalPlans;
                        }
                    }
                    
                    if (data.filteredPlans) {
                        if (data.filteredPlans == 0 || data.filteredPlans == '0' || isNaN(data.filteredPlans)) {
                            $window.digitalData.planSelection.filteredPlans = 'zero';
                        } else {
                            $window.digitalData.planSelection.filteredPlans = data.filteredPlans;
                        }
                    }*/

                    satelliteTrack(DTM_PLANSELECTION);
                }
            } catch(e) {

            }
        }

        function getNodeValue(node, nodeName, nestedSearch) {

            if (node.childNodeList) {
                for (var i = 0; i < node.childNodeList.length; i++) {
                    var childNode = node.childNodeList[i];
                    if (childNode.nodeName && childNode.nodeName == nodeName) {
                        if (childNode.nodeValue) {
                            return childNode.nodeValue;
                        }
                    }
                }
            }

            if (nestedSearch && node.childNodeList) {
                for (var i = 0; i < node.childNodeList.length; i++) {

                    var childNode = node.childNodeList[i];
	                var retVal = getNodeValue(childNode, nodeName, nestedSearch);
                    if (retVal) {
                        return retVal;
                    }
	            }
            }

            return false;
        }

        function getNodeByAttributeType(node, attributeType, nestedSearch) {

            if (node.attributeMap && node.attributeMap.type == attributeType) {
                return node;
            }

            if (nestedSearch && node.childNodeList) {
                for (var i = 0; i < node.childNodeList.length; i++) {

                    var childNode = node.childNodeList[i];
	                var retVal = getNodeByAttributeType(childNode, attributeType, nestedSearch);

                    if (retVal) {
                        return retVal;
                    }
	            }
            }

            return false;
        }

        function getAllNodesWithAttributeType(node, attributeType, results) {

            if (node.attributeMap && node.attributeMap.type == attributeType) {
                results.push(node);
            }

            if (node.childNodeList) {
                for (var i = 0; i < node.childNodeList.length; i++) {
                    var childNode = node.childNodeList[i];
	                getAllNodesWithAttributeType(childNode, attributeType, results);
	            }
            }
        }

        function satelliteTrack(ruleName) {
            try {
                $window._satellite.track(ruleName);
            } catch(e) {

            }
        }

        function trackForm(data) {

            try {
                initDigitalData();

                if (data) {
                    $window.digitalData.form = data;

                    if (data.state && data.state == 'completed') {
                        satelliteTrack(DTM_FORM);
                    }
                }
            } catch(e) {

            }
        }
        
        function removeFromCompare(provider) {
        	if (provider) {
        		var key = provider.key;

        		if (!key) {
        			return;  // invalid provider object
        		}

        		if (! $window.digitalData.compareProvider.lookup[key]) {
        			return;  // item is not being compared
        		}

        		for (var i=0; i< $window.digitalData.compareProvider.length; i++) {
        			var key2 = $window.digitalData.compareProvider[i].key;
        			if (key === key2) {
        				$window.digitalData.compareProvider.splice(i, 1);
        				break;  // found it
        			} // if found
        		} // look through providers being compared
        		$window.digitalData.compareProvider.lookup[key] = null;  // remove from lookup
        	}
        }
        
        function trackAddRemoveCompare(data, action) {

            try {
            	/* Not intiallizing so the search for which the compare is 
            	 * in progress can be captured if required*/
                /*initDigitalData();*/ 

                if (data) {
                	if( action == 'remove')
                	{
                		/*var index =
                			 $window.digitalData.compareProvider.indexOf(data);
                		
                		$window.digitalData.compareProvider = $window.digitalData.compareProvider.splice(1, index);*/
                		
                		removeFromCompare(data);
                	}
                	else
                	{
                		$window.digitalData.compareProvider.push(data);
                	}
                    //satelliteTrack(DTM_COMPARE_CHECKOUT);
                }
            } catch(e) {

            }
        }
        
        function trackCompare()
        {

            try {
            	/* Not intiallizing so the search for which the compare is 
            	 * in progress can be captured if required*/
                /*initDigitalData();*/ 

            	satelliteTrack(DTM_COMPARE);
                
            } catch(e) {

            }
        }
        
        
        function trackError(data) {

            try {
                initDigitalData();

                if (data) {
                    $window.digitalData.error = data;

                    if (data.state && data.state == 'error') {
                        satelliteTrack(DTM_ERROR);
                    }
                }
            } catch(e) {

            }
        }
        
        function trackAnchorLinks(data) {

        	/*try 
        	{
        		if( $window.digitalData.page.pageInfo.pageName == "provider search change location" &&
        				data && data.linkText == "Change location")
        		{
        			return;
        		}
        	}
        	catch( e )
        	{      		
        	}*/
        	try {

        		if (data) {

        			/* Check if the link is a filter and expose it as a filter rather than a link*/
        			if( data.anchorTagID &&  data.anchorTagID.startsWith("FilterSection_") )
        			{
        				//trackFilter( data.linkText );
        				return;

        			}

        			initDigitalData();
        			$window.digitalData.link = data;

        			satelliteTrack(DTM_LINK);
        		}
        	} catch(e) {

        	}
        }
        
        function trackLink(linkName, linkType, elementName) {
            try {
                initDigitalData();

                var selectedName = linkName;

                if (linkType == LINK_TYPE_PANEL && elementName) {

                    var panel = document.getElementById(elementName);
                    if (panel && panel.text) {
                        selectedName = panel.text.trim();
                    }
                }

                if (selectedName) {
                    $window.digitalData.link.name = selectedName;

                    if (linkType) {
                        $window.digitalData.link.type = linkType;
                    }

                    satelliteTrack(DTM_LINK);
                }
            } catch(e) {

            }
        }

        /*function trackError(errorName) {

            try {
                initDigitalData();

                if (errorName) {
                    $window.digitalData.error.errorName = errorName;
                    satelliteTrack(DTM_ERROR);
                }
            } catch(e) {

            }
        }*/

        function trackClaimCart(data, claimType) {

            try {
                initDigitalData();

                if (data && claimType) {

                    for (var i = 0; i < data.length; i++) {

                        var claim = {
                            date: data[i].serviceBeginDate,
                            type: claimType,
                            ID: data[i].baseClaimId,
                            member: 'member',
                            provider: data[i].providerGroupName,
                            billamount: data[i].totalSubmittedAmount,
                            planpaid: data[i].serviceLinePymtAmt,
                            amount: data[i].memberResAmt
                        };

                        $window.digitalData.claims.push(claim);
                    }

                    satelliteTrack(DTM_CLAIM_CART);
                }
            } catch(e) {

            }
        }

        function trackClaimCheckout(data, pharmData) {

            try {
                initDigitalData();

                if (pharmData == undefined) {

                    var claim = {
                        date: data.claimSegments[0].cfcDt,
                        type: data.productCategoryText,
                        ID: data.claimSegments[0].applClaimId,
                        member: 'member',
                        provider: data.claimSegments[0].prvdrName,
                        billamount: data.claimLvlData.totClmSub,
                        planpaid: data.claimLvlData.amtPdByPlan,
                        amount: data.claimSegments[0].mbrPays
                    };

                    $window.digitalData.claims.push(claim);

                    satelliteTrack(DTM_CLAIM_CHECKOUT);

                } else {

                    var claim = {
                        date: pharmData.claimLvlData.clmStartDt,
                        type: 'RX',
                        ID: pharmData.claimLvlData.prescriptionNumber,
                        member: pharmData.claimLvlData.mbrFirstNm + ' ' + pharmData.claimLvlData.mbrLastNm,
                        provider: pharmData.claimLvlData.providerGroupName,
                        billamount: pharmData.claimLvlData.chargedByPhar,
                        planpaid: pharmData.claimLvlData.amtPdByPlan,
                        amount: pharmData.claimLvlData.memberResAmt
                    };

                    $window.digitalData.claims.push(claim);

                    satelliteTrack(DTM_CLAIM_CHECKOUT);

                }
            } catch(e) {

            }
        }
        
        function markFilterAndSort(  )
        {
        	$window.digitalData.filterOrSort = true;
        	return
        }
        
        function trackFilterDropdown(sendNow, analyticsName, elementName, selectedText) {

            try {

                var selectedValue;
                var filterClicked = true;

                if (elementName) {
                    var e = document.getElementById(elementName);

                    if (e && e.options)
                    {
                        if (e.selectedIndex != -1) {
                            selectedValue = e.options[e.selectedIndex].text;
                        }

                        if (e.options.length <= 1) {
                            filterClicked = false;
                        }
                    }
                }

                if (selectedText != undefined) {
                    selectedValue = selectedText;
                }

                if (filterClicked) {
                    var filter = {
                        type: 'dropdown',
                        name: analyticsName,
                        selected: selectedValue
                    };

                    $window.digitalData.filters.push(filter);
                }

                if (sendNow) {
                    if ($window.digitalData.filters.length > 0) {
                        satelliteTrack(DTM_FILTER);
                        initDigitalData();
                    }
                }
            } catch(e) {

            }
        }

        function trackFilterRadio(sendNow, analyticsName, selectedValue) {

            try {
                if (analyticsName) {
                    var filter = {
                        type: 'radio button',
                        name: analyticsName,
                        selected: selectedValue
                    };

                    $window.digitalData.filters.push(filter);
                }

                if (sendNow) {
                    if ($window.digitalData.filters.length > 0) {
                        satelliteTrack(DTM_FILTER);
                        initDigitalData();
                    }
                }
            } catch(e) {

            }
        }

        function trackFilterCheckbox(sendNow, analyticsName, selectedValue) {

            try {
                if (analyticsName) {
                    var filter = {
                        type: 'checkbox',
                        name: analyticsName,
                        selected: selectedValue
                    };

                    $window.digitalData.filters.push(filter);
                }

                if (sendNow) {
                    if ($window.digitalData.filters.length > 0) {
                        satelliteTrack(DTM_FILTER);
                        initDigitalData();
                    }
                }
            } catch(e) {

            }
        }
    }
})();

},{}],47:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('BrandingLogoService', BrandingLogoService);

	BrandingLogoService.$inject = ['$http', '$q', 'configuration', '$sessionStorage', 'ProviderSearchCriteriaService'];

	function BrandingLogoService($http, $q, configuration,$sessionStorage,ProviderSearchCriteriaService) {

		function getBrandingLogo(){
			return fetchBrandingLogo();
		};

		function fetchBrandingLogo(){
			var domainName=location.origin
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var lang = criteria.language;
			var siteId=criteria.siteId;
			var url = configuration.brandingLogoURL;
			var clientId = configuration.brandingLogoClientId;

			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				url = configuration.externalBrandingLogoURL;
				clientId = configuration.externalClientId;
			}

			url = url + "brandingURL="+domainName;
			url = url + "&siteId="+siteId;
			var deferred = $q.defer();

			return $http({
				method: 'GET',
				url: url,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(
					function success(response)
					{
						if (response) {
							deferred.resolve(response);
						} else {
							deferred.resolve('The Logo is not available');
						}
						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						/* Perfecto issue changes */
						//alert("Perfecto issue : internal : Error : response " + response.status )
						var perfectoSwitch = configuration.perfectoSwitch;

						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							//alert("Perfecto issue : Calling External Function")
							return fetchBrandingLogoExternalCall( );
						}
						else{
							// the following line rejects the promise
							deferred.reject(response);
							// promise is returned
							return deferred.promise;
						}
					});
		}

		function fetchBrandingLogoExternalCall(){
			var domainName=location.origin
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var lang = criteria.language;
			var siteId=criteria.siteId;
			var externalApiURl = configuration.externalBrandingLogoURL;
			var externalClientId = configuration.externalClientId;
			externalApiURl = externalApiURl + "brandingURL="+domainName;
			externalApiURl = externalApiURl + "&siteId="+siteId;
			var deferred = $q.defer();
			//alert("Perfecto issue : external URL: "+externalApiURl);

			//alert("Perfecto logo issue :  " + externalApiURl + "   id :  " + externalClientId);

				return $http({
					method: 'GET',
					url: externalApiURl,
					headers : {
						accept : 'application/json',
						'X-IBM-Client-Id' : externalClientId
					}
				}) .then(
						function success(response)
						{


								$sessionStorage.isExternal = true;
							//alert ("Perfecto issue : external : Success : response " + JSON.stringify(response) );
									if (response) {
											deferred.resolve(response);
									} else {
											deferred.resolve('The Logo is not available');
									}
									// promise is returned
									return deferred.promise;
						},
						function error(response)
						{
							//alert ("Perfecto issue : external : Error : response " + JSON.stringify(response) );
							// the following line rejects the promise
							deferred.reject(response);
							// promise is returned
							return deferred.promise;
						});

				//alert ("Perfecto issue : After plan list call ");

		};

	return {
		getBrandingLogo:getBrandingLogo
	};
}
})();

},{}],48:[function(require,module,exports){
angular.module('nav-ui').directive("phoneformat", function () {
	    return {
	        restrict: "A",
	        require: "ngModel",
	        link: function (scope, element, attr, ngModelCtrl) {
	            var phoneParse = function (value) {
	                var numbers = value && value.replace(/-/g, "");
	                if (/^\d{10}$/.test(numbers)) {
	                    return numbers;
	                }
	                    
	                return undefined;
	            }
	            var phoneFormat = function (value) {
	                var numbers = value && value.replace(/-/g,"");
	                var matches = numbers && numbers.match(/^(\d{3})(\d{3})(\d{4})$/);
	                
	                if (matches) {
	                    return matches[1] + "-" + matches[2] + "-" + matches[3];
	                }

	                return undefined;
	            }
	           ngModelCtrl.$parsers.push(phoneParse);
	           ngModelCtrl.$formatters.push(phoneFormat);
	            
	            element.bind("keyup", function () {
	                var value = phoneFormat(element.val());
	                var isValid = !!value;
	                if (isValid) {
	                    ngModelCtrl.$setViewValue(value);
	                    ngModelCtrl.$render();
	                }
	                
	                ngModelCtrl.$setValidity("telephone", isValid);
	                scope.$apply();
	            });
	        }
	    };
	});
},{}],49:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('CommonUtilsService', CommonUtilsService);

	CommonUtilsService.$inject = ['$state', 'ProviderSearchCriteriaService','NavSpinnerService','$sessionStorage'];

	function CommonUtilsService($state, ProviderSearchCriteriaService,NavSpinnerService,$sessionStorage) {

		var tempObject = {};

		this.setTempObject= function(tObj) {
				tempObject = tObj;
		};

		this.getTempObject= function() {
				return tempObject;
		};

		this.checkIfURLIsThere= function(childNodeList) {
			for (var i = 0; i < childNodeList.length; i++) {
				if(childNodeList[i].nodeName == 'url' && childNodeList[i].nodeValue!=undefined && childNodeList[i].nodeValue!=""){
					return true;
				}
			}
			return false;
		};

		this.replaceParamValInStringFromUrl = function(url, paramName, paramValFromUrl) {

			var index = url.indexOf(paramName);
			if(index == -1){
				url = url +"&"+paramName+"="+paramValFromUrl;
			}
			else{
				var value = url.substring(index);
				var paramValue;
				value = value.split("=")[1];
				if(value.indexOf('&') != -1){
					paramValue = value.substring(0, value.indexOf('&'));
				}else{
					paramValue = value;
				}
				if(paramValue != paramValFromUrl){
					url = url.replace('&'+paramName+'='+paramValue, '&'+paramName+'='+paramValFromUrl);
				}
			}
			return url;
		};

		this.identifyMobileDevices = function(){

			if(navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)){
				return true;
			}else
				return false;
		};

		this.stateReloadNeeded = function(){
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var siteIdInUrl = $state.params.site_id;
			var lang = criteria.language;
			var languageInUrl = $state.params.language;
			

			if(siteIdInUrl == null || siteIdInUrl == undefined || siteIdInUrl == ''){
				siteIdInUrl = 'dse';
			}
			if(languageInUrl == null || languageInUrl == undefined || languageInUrl == ''|| languageInUrl !== "es"){
				languageInUrl = 'en';
			}
			if(siteId != null && siteId != undefined && siteId != '' && siteIdInUrl != null && siteIdInUrl != undefined && siteIdInUrl != '' && siteIdInUrl != siteId){
				return true;
			}else if(lang != null && lang != undefined && lang != '' && languageInUrl != null && languageInUrl != undefined && languageInUrl != '' && languageInUrl != lang){
				return true;
			}
			return false;
		};

		this.closeSpinner=function(){
			if(!(window.location.href.indexOf("providerResults") !== -1 || window.location.href.indexOf("providerDetails") !== -1 || window.location.href.indexOf("providerHospDetails") !== -1 || window.location.href.indexOf("providerOrgDetails") !== -1)){
				NavSpinnerService.stop();
			}
		};

		this.resetBreadcrumbVariables = function(emptyBreadcrumbArray){
			$sessionStorage.breadCrumArray.push(emptyBreadcrumbArray);
			$sessionStorage.breadcrumbArray.push(emptyBreadcrumbArray);
		};
	}
})();

},{}],50:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('CompareProviderService', CompareProviderService);

	CompareProviderService.$inject = ['configuration','$http','$q','$sessionStorage','$log','$rootScope','$translate'];

	function CompareProviderService(configuration,$http,$q,$sessionStorage,$log,$rootScope,$translate) {
		var providersToCompare=[];
		var showComparePopUp = false;
		var showHospitals = false;
		var hosCount = 0;
		
		var getProvidersToCompare = function(){
			return providersToCompare;
		};
		var setProvidersToCompare = function( providers ){
			providersToCompare = providers;
		};
		
		var getShowComparePopUp = function(){
			return showComparePopUp;
		};
		var setShowComparePopUp = function( showPopUp ){
			showComparePopUp = showPopUp;
		};
		
		var getShowHospitals = function(){
			return showHospitals;
		};
		var setShowHospitals = function( showHospitalAff ){
			showHospitals = showHospitalAff;
		};
		
		var getHosCount = function(){
			return hosCount;
		};
		var setHosCount = function( count ){
			hosCount = count;
		};
		
		var reset = function( ){
			providersToCompare=[];
			showComparePopUp = false;
			showHospitals = false;
			hosCount = 0;
		};
		
		return {
			getProvidersToCompare:getProvidersToCompare,
			setProvidersToCompare:setProvidersToCompare,
			getShowComparePopUp:getShowComparePopUp,
			setShowComparePopUp:setShowComparePopUp,
			getShowHospitals:getShowHospitals,
			setShowHospitals:setShowHospitals,
			getHosCount:getHosCount,
			setHosCount:setHosCount,
			reset:reset
		};
	
	}
	})();

},{}],51:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('ContentResultsService', ContentResultsService);

	ContentResultsService.$inject = ['$http', '$q', 'configuration', '$sessionStorage','ProviderSearchCriteriaService','$state','$window','CommonUtilsService','LanguageDataService'];

	function ContentResultsService($http, $q, configuration, $sessionStorage, ProviderSearchCriteriaService,$state,$window,CommonUtilsService,LanguageDataService) {


		function getContent(contentId, contentType, contentLang){
			var criteria = ProviderSearchCriteriaService.getCriteria();
			if(CommonUtilsService.stateReloadNeeded()){
                LanguageDataService.setLanguageData("");
				$state.reload("mainlayoutWC");
			}
			var siteId = criteria.siteId;

			// If site id changed in the url and is different from current value, use the latest site id
			var siteIdInUrl = $state.params.site_id;
			if(siteIdInUrl != siteId){
				siteId = siteIdInUrl;
				if (siteId == null || siteId == undefined) {
					siteId = 'dse';
				}
				criteria.siteId = siteId;
			}
			var lang = criteria.language;
			if (lang == null || lang == undefined || lang === 'en') {
				lang = ''; // blank defaults to English
			}

			// If language changed in the url and is different from current value, use the latest language
			var languageInUrl = $state.params.language;
			if (languageInUrl == null || languageInUrl == undefined || languageInUrl !== "es") {
				languageInUrl = "en";
			}

			if(languageInUrl != lang && languageInUrl != null && languageInUrl != undefined){
				lang = languageInUrl;
				if (lang == null || lang == undefined || lang === 'en') {
					lang = '';
				}
			}
			var returnObj;

			if($sessionStorage.isExternal == undefined || $sessionStorage.isExternal == false){
				returnObj = fetchContent(contentId, contentType, lang, siteId);

				/*if( $sessionStorage.isExternal && $sessionStorage.isExternal == true ){
					alert("1");
					returnObj = fetchContentExternalCall(contentId, contentType, lang, siteId);
					externalCallDone = true ;
				}
				alert("2");*/
			}
			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true ){
				returnObj = fetchContentExternalCall(contentId, contentType, lang, siteId);
			}
			/*alert(  "Return value"+JSON.stringify(returnObj));*/
			return returnObj;
		};

		function fetchContent (contentId, contentType, lang, siteId){
			var results;
			var deferred = $q.defer();
			/*var url = configuration.publicPageContentAPIURL;*/

			/*if( location.protocol == "https:")
			{
				url = configuration.publicPageContentHTTPSAPIURL;
			}*/
			var url = configuration.publicPageContentAPICURL;
			var clientId = configuration.publicPageContentClientId;
			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				url = configuration.externalPublicPageContentAPICURL;
				clientId = configuration.externalPublicPageContenCliendId;
			}

			return $http({
				method: 'GET',
				url: url,
				params: {contentId:contentId, contentType:contentType, languageCode:lang, siteId:siteId},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(
					function success(response)
					{
						/*$sessionStorage.isExternal = false;*/
						if (response.data && response.data.application) {
							deferred.resolve(response.data.application[0]);
						}else if (response.data && response.data.content) {
							deferred.resolve(response.data.content.application[0]);
						}else if (response.data) { // This condition is to read developer content. It doesnt have application node in the response
							deferred.resolve(response.data);
						}else {
							deferred.resolve('Application node not found in response.');
						}

						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						
						/*$sessionStorage.isExternal = true;*/
						/*deferred.reject(response);
						return deferred.promise;*/

						/*if ( url == configuration.externalPublicPageContentAPICURL)*/
						{
							/*alert("External call error"  + JSON.stringify(response) +
									" \nurl" + url +
									"\n params" + contentId + " " +contentType + " " + lang +" " +siteId);*/
						}

						/* Perfecto issue changes */
						var perfectoSwitch = configuration.perfectoSwitch;

						console.log("response.status : " + response.status + " perfectoSwitch : " + perfectoSwitch );
						
						/* FIX */
						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							return fetchContentExternalCall(contentId, contentType, lang, siteId);
						}else{
							// the following line rejects the promise
							deferred.reject(response);

							// promise is returned
							return deferred.promise;
						}

					});

	};


	function fetchContentExternalCall (contentId, contentType, lang, siteId){

		var results;
		var deferred = $q.defer();
		//var url = configuration.publicPageContentAPIURL;
		var url = configuration.externalPublicPageContentAPICURL;
		var clientId = configuration.externalPublicPageContenCliendId;

		return $http({
			method: 'GET',
			url: url,
			params: {contentId:contentId, contentType:contentType, languageCode:lang, siteId:siteId},
			headers : {
				accept : 'application/json',
				'X-IBM-Client-Id' : clientId
			}
		}) .then(
				function success(response)
				{
					// alert("External response"  + JSON.stringify(response) +
					// " \nurl" + url +
					// "\n params" + contentId + " " +contentType + " " + lang +" " +siteId);
					
					$sessionStorage.isExternal = true;

					if (response.data && response.data.application) {
						deferred.resolve(response.data.application[0]);
					}else if (response.data && response.data.content) {
						deferred.resolve(response.data.content.application[0]);
					}else if (response.data) { // This condition is to read developer content. It doesnt have application node in the response
						deferred.resolve(response.data);
					}else {
						deferred.resolve('Application node not found in response.');
					}
					// promise is returned
					return deferred.promise;
				},
				function error(response)
				{
					alert("External error"  + JSON.stringify(response) +
							" \nurl" + url +
							"\n params" + contentId + " " +contentType + " " + lang +" " +siteId);
					// the following line rejects the promise
					deferred.reject(response);

					// promise is returned
					return deferred.promise;
				});
	}

	return {
		getContent: getContent
	};
}
})();

},{}],52:[function(require,module,exports){

angular.module('nav-ui')
    .service('ContentIdListService', function () {
       
      this.findCareContentIdArray=function(){
      return (["findUrgentCare","providerSearch","providerMedical","provider","healthHistory","providerResults"])
			 };
			 
			 this.manageClaimsContentIdArray= function(){
				 return(["claimListing","eobList","claimDetails","eobDetail","pharmacyClaimDetails"])
			 };
			 
			 this.seeCoverageAndCostsContentIdArray=function(){
				 return(["coverageOverviewNew","coverageBenefits","mpeLanding","balanceLimits","ahfNew","adfNew","mpechooseMemebr_Page","mpeSelectService_Page","mpeProcedureListFacility_Page","mpeSearchByNameFacility_Page","mpeProviderFacilityList_Page","mpeOfficeVisitService_Page","mpePrimarySpecialist_Page","mpeProcedureListPhysician_Page","mpeSearchByNamePhysician_Page","mpeDisclaimer_Page","mpeProviderPhysicianList_Page","mpeOutOfNetwork_Page","mpeTradChoice_Page", "mpeDisclaimer_PageFac","fsaHcHealthFunds","fsaDcHealthFunds","rraHealthFunds","hraHealthFunds","rraClaimListPage","hraClaimListPage","fsaDcClaimListPage","fsaHcClaimListPage","rraPaymentListPage","hraPaymentListPage","fsaDcPaymentListPage","fsaHcPaymentListPage","navCostCareList","costCareList","costCareDetails"])
			 };
			 
			 this.stayHealthyContentIdArray=function(){
				 return(["wellnessHome","stayHealthy","discountPrograms","newIncentives","intakeFormHealthMgmtProgram","homeProductsDiscounts","naturalProductsDiscounts","fitnessProductsDiscounts","bookProductsDiscounts","visionProductsDiscounts","oralHealthCareProductsDiscounts","hearingProductsDiscounts","lifeMartProductsDiscounts","weightMgmtProductsDiscounts","intakeFormBreastHealthSurvey","intakeFormMaternityMgt","intakeFormHealthMgmtProgramStep2","intakeFormHealthProgramConfirmation","intakeFormMaternityMgtStep2","intakeFormMaternityMgtStep3","intakeFormMaternityMgtConfirm","intakeFormBHSConfirm","healthLifeStyleCoaching","intakeFormHealthyLifestyleConfirm","acuteCarePage","worksiteServicesAHCDM","worksiteServicesWellnessCounseling","incentiveDetails","newIncentives","preventiveHealthSchedule","fitnessReimbursementProgram"])
			 };
			 
			 this.OthersContentIdArray=function(){
				 return(["changePCP","changePCD","confirmPCP","pcpConfirmation","directoryAndResources","importantInfo","savingsAndDiscounts","qualityAndCostInfo","pcpPreConfirmation","pcpQuestionnaire"]);
			 };
        
			this.managePrescriptionsContentIdArray=function(){
				return(["pharmacy_benefits","pharmacy_mailOrder","pharmacy_SpecialtyPharmacy","pharmacy_SpecialtyPharmacyCoverage"])
			};
			//See Coverage and Costs-Secondary Navigation Sub Pages -Start
			this.FinancialOverviewInternalPageContentIdArray=function(){
				return(["ahfNew","adfNew","fsaHcHealthFunds","fsaDcHealthFunds","rraHealthFunds","hraHealthFunds","rraClaimListPage","hraClaimListPage","fsaDcClaimListPage","fsaHcClaimListPage","rraPaymentListPage","hraPaymentListPage","fsaDcPaymentListPage","fsaHcPaymentListPage"])
			};
			
			this.CoverageAndBenefitsInternalPageContentIdArray=function(){
				return(["balanceLimits"])
			};
			
			this.EstimateCostsInternalPageContentIdArray=function(){
				return(["mpechooseMemebr_Page","mpeSelectService_Page","mpeProcedureListFacility_Page","mpeSearchByNameFacility_Page","mpeProviderFacilityList_Page","mpeOfficeVisitService_Page","mpePrimarySpecialist_Page","mpeProcedureListPhysician_Page","mpeSearchByNamePhysician_Page","mpeDisclaimer_Page","mpeProviderPhysicianList_Page","mpeOutOfNetwork_Page","mpeTradChoice_Page", "mpeDisclaimer_PageFac","navCostCareList","costCareList","costCareDetails"])
			};
			//See Coverage and Costs-Secondary Navigation Sub Pages -End
			//Stay Healthy-Secondary Navigation Sub Pages -Start
			this.HealthProgramsInternalPageContentIdArray=function(){
				return(["stayHealthy", "intakeFormHealthMgmtProgram", "intakeFormBreastHealthSurvey","intakeFormMaternityMgt","intakeFormHealthMgmtProgramStep2","intakeFormHealthProgramConfirmation","intakeFormMaternityMgtStep2","intakeFormMaternityMgtStep3","intakeFormMaternityMgtConfirm","intakeFormBHSConfirm","healthLifeStyleCoaching","intakeFormHealthyLifestyleConfirm","acuteCarePage","worksiteServicesAHCDM","worksiteServicesWellnessCounseling", "preventiveHealthSchedule","fitnessReimbursementProgram"])
			};
            this.DiscountsInternalPageContentIdArray=function(){
				return(["homeProductsDiscounts","naturalProductsDiscounts","fitnessProductsDiscounts","bookProductsDiscounts","visionProductsDiscounts","oralHealthCareProductsDiscounts","hearingProductsDiscounts","lifeMartProductsDiscounts","weightMgmtProductsDiscounts"])
			};
			 this.IncentiveInternalPageContentIdArray=function(){
				return(["incentiveDetails","newIncentives"])
			};
			//Stay Healthy-Secondary Navigation Sub Pages -End
			this.topChromeContentIdArray=function(){
				return(["homePageNew","messages","idCard","formsLib","profile","contactUs"])
			};
			this.firstTabSecondaryNavContentIdArray=function(){
				return(["pharmacy_benefits","providerSearch","claimListing","coverageOverviewNew","wellnessHome"])
			};
			this.secondTabSecondaryNavContentIdArray=function(){
				return(["coverageBenefits","findUrgentCare","discountPrograms","pharmacy_mailOrder"])
			};
    
});

  
},{}],53:[function(require,module,exports){
angular.module('nav-ui').filter('phoneFormat',phoneFormat);

/** This is to convert any 10 digit number to phone format.  **/
function phoneFormat() {
	return  function(phone) {
		if(phone!= undefined && phone != ''){

			phone = phone.replace(/[^\d]/g, "");
			//check if number length equals to 10
			if (phone.length == 10) {
				//reformat and return phone number
				return phone.replace(/(\d{3})(\d{3})(\d{4})/, "($1) $2-$3");
			}else if(phone.length < 10){
				return phone;
			}else{
				return phone.replace(/(\d{3})(\d{3})(\d{4})(\d)/, "($1) $2-$3 ext. $4");
			}

		}
	};
}

},{}],54:[function(require,module,exports){
(function () {
  angular
    .module('nav-ui')
    .service('mapsService', mapsService);
  mapsService.$inject = ['$log', '$q', 'ProviderSearchCriteriaService'];
  /* To use this service, just create a element in your html  like  but is 'map' <div style="display:none" id="map" style="height:300px;width:50%"></div>
   */
  function mapsService($log, $q, ProviderSearchCriteriaService) {
    markers = [];
    map = [];
    geocoder = null;
    infoWindows = [];
    var resetMapInfo = function () {
        markers = [];
        map = [];
        geocoder = null;
        infoWindows = [];
      }
      //Clear any exisiting map and markers.
    var deleteMap = function () {
      removeALLMarkers(null);
      map = null;
      element = document.getElementById('map');
      element.style.display = "none";
      element.innerHTML = "whatever";
    }

    var toggleMap = function () {
        element = document.getElementById('map');
        var mapCancelButton = document.getElementById('map_cancel');
        if (element == undefined)
          return;
        if (element.style.display == "none") {
          element.style.display = "block";
          mapCancelButton.style.display = "block";
        } else {
          element.style.display = "none";
          mapCancelButton.style.display = "none";
        }
      }
      /*
       * Created a map with given center and zoom level
       * input parameters are :
       *lat: latitude of center, longitude: longitude of center, zoomLevel : the level of zoom expected, uniqueId : ID of the div to display the map
       */

    var createMapWithAddress = function (address, zoomLevel, uniqueId) {
      resetMapInfo();
      if (typeof google === 'object' && typeof google.maps === 'object') {
        geocoder = new google.maps.Geocoder();
        document.getElementById('map').style.display = "block";
        document.getElementById('map_cancel').style.display = "block";
        geocoder.geocode({
          'address': address
        }, function (results, status) {
          if (status === 'OK') {
            var centerLatLong = {
              lat: parseFloat(results[0].geometry.location.lat()),
              lng: parseFloat(results[0].geometry.location.lng())
            };
            map = new google.maps.Map(document.getElementById(uniqueId), {
              zoom: zoomLevel,
              center: centerLatLong
            });
          } else {
            $log.error("Google maps were not loaded corrects. Please try reloading your page.");
          }
        })
      } else {
        $log.error("Google maps were not loaded corrects. Please try reloading your page.");
      }
    }

    var createMap = function (latitude, longitude, zoomLevel, uniqueId) {
      resetMapInfo();
      if (typeof google === 'object' && typeof google.maps === 'object') {
        geocoder = new google.maps.Geocoder();
        document.getElementById('map').style.display = "block";
        document.getElementById('map_cancel').style.display = "block";
        var centerLatLong = {
          lat: parseFloat(latitude),
          lng: parseFloat(longitude)
        };
        map = new google.maps.Map(document.getElementById(uniqueId), {
          zoom: zoomLevel,
          center: centerLatLong
        });
      } else {
        $log.error("Google maps were not loaded corrects. Please try reloading your page.");
      }
    }
    var updateCenterFromAddress = function (address) {
        if (geocoder == null) {
          if (typeof google === 'object' && typeof google.maps === 'object') {
            geocoder = new google.maps.Geocoder();
          } else {
            $log.error("Geodecoder was not initialzed.Hence returning")
            return;
          }
        }
        if (status === 'OK') {
          var center = new google.maps.LatLng(results[0].geometry.location.lat(), results[0].geometry.location.lng());
          map.panTo(center);
        } else {
          $log.error('Geocode was not successful for the following reason: ' + status);
          return;
        }
      }
      //Update the center of an existing map
    var updateCenter = function (latitude, longitude) {
      var center = new google.maps.LatLng(latitude, longitude);
      map.panTo(center);
    }

    var getAllMarkers = function () {
      return markers;
    }

    var addMarkerFromAddress = function (address, markerContent, isOpenWindow) {
        if (map == null) {
          $log.error("No map to add a marker");
          return;
        }
        //use the URL doamin to create the distance image URL. This will help it work on JV's as well.
        var iconURL = '../../dsepublic/images/distance.png';
        if (geocoder == null) {
          if (typeof google === 'object' && typeof google.maps === 'object') {
            geocoder = new google.maps.Geocoder();
          } else {
            $log.error("Geodecoder was not initialzed.Hence returning")
            return;
          }
        }
        geocoder.geocode({
          'address': address
        }, function (results, status) {
          if (status === 'OK') {
            var position = results[0].geometry.location;
            var marker = new google.maps.Marker({
              position: position,
              icon: iconURL,
              map: map
            });
            markers.push(marker);
            var infowindow = new google.maps.InfoWindow({
              content: markerContent,
              position: marker.getPosition()
            });
            infoWindows.push(infowindow);
            marker.addListener('click', function () {
              //Close all Information windows before opening it.
              for (var i = 0; i < infoWindows.length; i++)
                infoWindows[i].close();
              //map.setCenter(marker.getPosition());
              infowindow.open(map);
            });
            //Only show the marker if needed.
            if (isOpenWindow)
              infowindow.open(map, marker);
          } else {
            $log.error('Geocode was not successful for the following reason: ' + status);
            return;
          }
        });
      }
      /**
	   Add one marker on map. Inputs - lat, lon, markerContent
	   isopenWindow : If true will open the information window.
	*/
      //add one marker on map
    var addMarker = function (latitude, longitude, markerContent, isOpenWindow) {
      if (map == null) {
        $log.error("No map to add a marker");
        return;
      }
      //use the URL doamin to create the distance image URL. This will help it work on JV's as well.
      var iconURL = '../../dsepublic/images/distance.png';
      var position = new google.maps.LatLng(latitude, longitude);
      var marker = new google.maps.Marker({
        position: position,
        icon: iconURL,
        map: map
      });
      // IS this needed here? ISnt this needed only for multiple markers? Commenting for now.
      // Yes this is needed as we need to know what and which markers are on the map
      //as google does not have a function to get all markers from map..
      markers.push(marker);
      var infowindow = new google.maps.InfoWindow({
        content: markerContent,
        position: marker.getPosition()
      });
      infoWindows.push(infowindow);
      marker.addListener('click', function () {
        //Close all Information windows before opening it.
        for (var i = 0; i < infoWindows.length; i++) {
          infoWindows[i].close();
          infowindow.open(map);
        }
      });
      //Only show the marker if needed.
      if (isOpenWindow) {
        infowindow.open(map, marker);
      }
    }

    var openInfoWindow = function (index) {
      for (var i = 0; i < infoWindows.length; i++)
        infoWindows[i].close();
      if (infoWindows != null && infoWindows != undefined) {
        infoWindows[index].open(map);
      }
    }

    var addMultipleMarker = function (markerInfo) {
      if (map == null) {
        $log.error("No map to add a marker");
        return;
      }
      var infoWindow = new google.maps.InfoWindow();
      var iconURL = '../../dsepublic/images/distance.png';
      for (var i = 0; i < markerInfo.length; i++) {
        var position = new google.maps.LatLng(markerInfo[i].lat, markerInfo[i].long);
        marker = new google.maps.Marker({
          position: position,
          icon: iconURL,
          map: map
        });
        if (!markerInfo[i].providerSelectedForMap) {
          google.maps.event.addListener(marker, 'click', (function (marker, i) {
            return function () {
              infoWindow.setContent(markerInfo[i].markerContent);
              infoWindow.open(map, marker);
            }
          })(marker, i));
        } else {
          google.maps.event.addListener(marker, 'click', (function (marker, i) {
            return function () {
              infoWindow.setContent(markerInfo[i].markerContent);
              infoWindow.open(map, marker);
            }
          })(marker, i));
        }
      }
    }

    //Deletes all markers.
    var removeALLMarkers = function (map) {
      for (var i = 0; i < markers.length; i++) {
        markers[i].setMap(map);
      }
      markers = [];
    }

    var geocodeAddress = function (address) {
      var deferred = $q.defer();
      if (geocoder == null) {
        if (typeof google === 'object' && typeof google.maps === 'object') {
          geocoder = new google.maps.Geocoder();
        } else {
          $log.error("Geodecoder was not initialzed.Hence returning")
          return deferred.resolve("Geodecoder was not initialzed");
        }
      }
      geocoder.geocode({
        'address': address
      }, function (results, status) {
        if (status === 'OK') {
          deferred.resolve(results[0].geometry.location);
        } else {
          deferred.resolve(status);
          $log.error('Geocode was not successful for the following reason: ' + status);
        }
      });
      return deferred.promise;
    }

    //Input should be of the format :  {lat: 40.731, lng: -73.997}
    var reverseGeocode = function (latitude, longitude) {
      var deferred = $q.defer();
      try {
        latlong = {
          lat: parseFloat(latitude),
          lng: parseFloat(longitude)
        };
      } catch (error) {
        $log.error("lat or long is a number" + latitude + " " + longitude)
      }
      if (geocoder == null) {
        if (typeof google === 'object' && typeof google.maps === 'object') {
          geocoder = new google.maps.Geocoder();
        } else {
          $log.error("Geodecoder was not initialzed.Hence returning")
          return deferred.resolve("Geodecoder was not initialzed");
        }
      }
      geocoder.geocode({
        'location': latlong
      }, function (results, status) {
        if (status === 'OK') {
          deferred.resolve(results[0].formatted_address);
        } else {
          deferred.resolve(status);
          $log.error('Geocode was not successful for the following reason: ' + status);
        }
      });
      return deferred.promise;
    }

    var createGoogleMapsDirectionURL = function (destination) {
      var dirUrl = "https://www.google.com/maps/dir/?api=1&destination="
      destination = encodeURIComponent(destination).replace(/%20/g, '+');
      dirUrl = dirUrl + destination;
      return dirUrl;
    }

    var getGeoState = function (latitude, longitude) {
      var criteria = ProviderSearchCriteriaService.getCriteria();
      var lat = latitude,
        lng = longitude,
        latlng = new google.maps.LatLng(lat, lng),
        geocoder = new google.maps.Geocoder();
      geocoder.geocode({
        'latLng': latlng
      }, function (results, status) {
        if (status == google.maps.GeocoderStatus.OK) {
          if (results[1]) {
            for (var ac = 0; ac < results[0].address_components.length; ac++) {
              var components = results[0].address_components;
              for (var i = 0; i < components.length; i++) {
                if (components[i].types[0] === 'administrative_area_level_1') {
                  criteria.position.state = components[i].short_name;
                  break;
                }
              }
            };
          } else {
            console.log("No reverse geocode results.")
          }
        } else {
          console.log("Geocoder failed: " + status)
        }
      });
    }

    return {
      createMap: createMap,
      geocodeAddress: geocodeAddress,
      addMarker: addMarker,
      addMultipleMarker: addMultipleMarker,
      removeALLMarkers: removeALLMarkers,
      deleteMap: deleteMap,
      openInfoWindow: openInfoWindow,
      toggleMap: toggleMap,
      reverseGeocode: reverseGeocode,
      createGoogleMapsDirectionURL: createGoogleMapsDirectionURL,
      updateCenter: updateCenter,
      getAllMarkers: getAllMarkers,
      getGeoState: getGeoState,
      addMarkerFromAddress: addMarkerFromAddress,
      createMapWithAddress: createMapWithAddress,
			updateCenterFromAddress: updateCenterFromAddress
    };
  }
})();

},{}],55:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('LanguageDataService', LanguageDataService);

	LanguageDataService.$inject = ['$sessionStorage','$log'];

	function LanguageDataService($sessionStorage,$log) {
				var languageData = {};

				var getLanguageData= function(){
						var tempLanguageData = $sessionStorage.languageData;
						if(tempLanguageData != null && tempLanguageData != undefined)
						{
							languageData = tempLanguageData;
						}
						return languageData;
				};

				/* Uncommenting and using this method to update sessionStorage */
				var setLanguageData = function(langData){
				 		$sessionStorage.languageData = langData;
				};

				return {
						setLanguageData:setLanguageData,
						getLanguageData:getLanguageData
				};
	}
})();

},{}],56:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('NavSpinnerService', NavSpinnerService);



	function NavSpinnerService() {
		this.spin= function() {

			var spinner = angular.element('<div id="newNavSpinner2"><img src="/dsepublicContent/assets/images/Loader_new.gif" class="newNavSpinnerImg"></img></div><div id="loader-overlay"></div>');
			var body = angular.element(document).find('body').eq(0);
			body.prepend(spinner);
			var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
			var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
			var top=h/2- 75 ;
			var left=w/2 - 75;
			angular.element("#newNavSpinner2").css("position","fixed");
			angular.element("#newNavSpinner2").css("margin-left",left+"px");
			angular.element("#newNavSpinner2").css("margin-top",top+"px");
			angular.element("#newNavSpinner2").css("z-index","1000001");
			window.scrollTo(0,0);
		};

		this.stop=function(){
			var spinner=angular.element(document).find('body').find('#newNavSpinner2');
			var spinnerOverlay=angular.element(document).find('body').find('#loader-overlay');
			spinnerOverlay.remove();
			spinner.remove();
		};


		this.spinWithModal=function (){
			var spinner = angular.element('<div id="newNavSpinner2"><img src="images/navSpinner.gif" class="newNavSpinnerImg"></img></div>');
			var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
			var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
			var top=h/2- 100 ;
			var left=w/2 - 100;
			spinner.css("position","fixed");
			spinner.css("margin-left",left+"px");
			spinner.css("margin-top",top+"px");
			spinner.css("z-index","1000");
			var body = angular.element(document).find('body').eq(0);
			if(angular.element("#newNavSpinner2").length==0){
				body.prepend(spinner);
			}
			if(angular.element("#spinnerModal").length==0){
				body.prepend("<div id='spinnerModal' class='modal-backdrop fade in'></div>");
			}

		};

		this.stopWithModal =function(){
			if(angular.element("#newNavSpinner2").length>0){
				var spinner=angular.element('#newNavSpinner2');
				spinner.remove();
			}
			if(angular.element("#spinnerModal").length>0){
				angular.element("#spinnerModal" ).remove();
			}
		};


	}
})();

},{}],57:[function(require,module,exports){
(function() {

angular
	.module('nav-ui')
	.service('PageBuilderService', PageBuilderService);

	PageBuilderService.$inject = ['$rootScope', '$compile','CommonUtilsService'];

	function PageBuilderService($rootScope, $compile,CommonUtilsService ) {
		var HEADER_START_DIV = 'aet-header';
		var MENU_DIV = 'aet-menu';
        	var NEWMENU_DIV = 'aet-newMenu';
		var CENTER_START_DIV = 'main-div';
		var FOOTER_START_DIV = 'aet-footer';
		var BOX_HEADER = 'box-header';
		var UNORDERED_LIST = 'unordered-list';

		var allNodes = {};
		var nodeInfo = {};
		var uniqueId = 0;
		var parents = {};
		var footerBottomChrome = 'false';
		var className = '';
		var linkCount= 0;
		var applicationType = "";
		var pageTitle = "";
		var params = null;
		var centerContentParagraphs = 0;
		var numberOfParagraphNodes = 0;
		var headerLinksElement = false;
		//$rootScope.paragraphStyle = '';

		return {
			buildPage: buildPage,
			addElement: addElement,
			getNodeInfo: getNodeInfo,
			buildPageWithParameters:buildPageWithParameters,
			processNodeIndividually:processNodeIndividually,
			addElements:addElements,
			buildPageWithRoot :buildPageWithRoot
		};

		function getNodeInfo(id) {
			return nodeInfo[id];
		}

		function getUniqueId(nodeType) {
			uniqueId += 1;
			return nodeType + "_" + uniqueId.toString();
		}

		function buildPageWithParameters(node,parameters){
			params = parameters;
			buildPage(node);
		}
		function buildPageWithRoot(node,root){
			var mainView = angular.element(document.getElementById(root));
			mainView.empty();
			allNodes=node;
			addNewNode('application', allNodes, root);
		}
		function buildPage(node) {

			allNodes = node;
			if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'footer')
			{

				var mainView = angular.element(document.getElementById(FOOTER_START_DIV));
				mainView.empty();
				applicationType = "footer";
				addNewNode('application', allNodes, '0-footer');
			}
			else if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'topchrome')
			{
				var mainView = angular.element(document.getElementById(HEADER_START_DIV));
				mainView.empty();
				applicationType = "";
				addNewNode('application', allNodes, '0-header');

			}
      else if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'topChromeNew')
			{
				var mainView = angular.element(document.getElementById(HEADER_START_DIV));
				mainView.empty();
				applicationType = "";
				addNewNode('application', allNodes, '0-header');

			}
			else if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'navigation')
			{
				var newMainView = angular.element(document.getElementById(NEWMENU_DIV));
				newMainView.empty();
				applicationType = "";
				addNewNode('application', allNodes, '0-menu');
				$rootScope.newMenuViewLoaded = 'true';

			}
      else if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'newNavigation')
			{
				var newMainView = angular.element(document.getElementById(NEWMENU_DIV));
				newMainView.empty();
				applicationType = "";
				addNewNode('application', allNodes, '0-menu');
				$rootScope.newMenuViewLoaded = 'true';

			}
			else if(node != undefined && node.attributeMap !== undefined  && node.attributeMap.type != undefined && node.attributeMap.type == 'boxpage')
			{
				var mainView = angular.element(document.getElementById(CENTER_START_DIV));
				mainView.empty();
				applicationType = "boxpage";
				addNewNode('application', allNodes, '0-center');
			}
			else
			{	applicationType = "";
				var mainView = angular.element(document.getElementById(CENTER_START_DIV));
				mainView.empty();
				applicationType = "";
				addNewNode('application', allNodes, '0-center');
				//Separating pagetitle and main-div of center content
				var jsonPageTitleDiv = angular.element(document.querySelector('div[id^="pageTitle_"]'));

				var pageTitleDiv = angular.element(document.getElementById('centerContentPagetitle-div'));
				pageTitleDiv.append(jsonPageTitleDiv);
				$compile(pageTitleDiv)($rootScope);
				applicationType = "";

			}

		}

		function addNewNode(newNodeName, newNode, parentId) {
			if(newNode.attributeMap && newNode.attributeMap.type){
				newNode.uniqueId = getUniqueId(newNode.attributeMap.type);
			}else{
				newNode.uniqueId = getUniqueId(newNode.nodeName);
			}
			parents[newNode.uniqueId] = parentId;
			processNode(newNodeName, newNode);
		}

		function getInsertPoint(insertId) {
			var ele = document.getElementById(insertId);
			if (ele) {
				return insertId;
			} else {
				var newId = parents[insertId];
				if (newId) {
					return getInsertPoint(newId);
				} else {
					return null;
				}
			}
		}

		function addElement(elementName, parentId, uniqueId, node) {
			var start;
			var element;
			var nodeType = "";
			var nodeFunction = "";
			var nodeStyle = "";
			var navkey = "";
			var orientation = "";
			var bulletType = "";
			if(node != undefined && node.attributeMap !== undefined  && node.attributeMap)
			{
				if(node.attributeMap.type){
					nodeType = node.attributeMap.type;
				}
				if(node.attributeMap['function']){
					nodeFunction = node.attributeMap['function'];
				}
				if(node.attributeMap.style){
					nodeStyle = node.attributeMap.style;
				}
				if(node.attributeMap.navkey){
					navkey = node.attributeMap.navkey;
				}
				if(node.attributeMap.orientation){
					orientation = node.attributeMap.orientation;
				}
				if(node.attributeMap.bulletType){
					bulletType = node.attributeMap.bulletType;
				}
			}

			var parent = getNodeInfo(parentId);
			var parentType = "";
			var parentStyle = "";
			if(parent && parent.attributeMap)
			{
				parentType = parent.attributeMap.type;
				parentStyle = parent.attributeMap.style;
			}
			if(nodeType == 'footerbottomchrome'){
				footerBottomChrome = 'true';
			}
			else{
				footerBottomChrome = 'false';
			}
			
			if( parentStyle && parentStyle == 'headerLinks')
			{
				headerLinksElement = true;
			}
			else
			{
				headerLinksElement = false;
			}
			

			switch (elementName) {
				case 'link':
					if(applicationType == "footer" && footerBottomChrome=='false'){
						if(CommonUtilsService.checkIfURLIsThere(node.childNodeList)){
							var eName = 'nav-' + elementName;
							element = '<li' + ' class="' + className + '">' + '<' + eName + ' parent=' + parentId;
							if (uniqueId) {
								element += ' id=' + uniqueId;
							}
							if (nodeFunction) {
								element += ' functionname=' + nodeFunction;
							}
							if (nodeType) {

								element += ' type=' + nodeType;

							}
							if(parentType)
							{
								element += ' parentType=' + parentType;
							}
							if (nodeStyle) {

								element += ' nvstyle=' + nodeStyle;

							}

							element += '></' + eName + '>' + '</li>';
						}

					}else{
						if( ( headerLinksElement && CommonUtilsService.checkIfURLIsThere(node.childNodeList) )
								|| !headerLinksElement )
						{
							var eName = 'nav-' + elementName;
							element = '<' + eName + ' parent=' + parentId;
							if (uniqueId) {
								element += ' id=' + uniqueId;
							}
							if (nodeFunction) {
								element += ' functionname=' + nodeFunction;
							}
							if (nodeType) {

								element += ' type=' + nodeType;

							}
							if(parentType)
							{
								element += ' parentType=' + parentType;
							}
							if (nodeStyle) {

								element += ' nvstyle=' + nodeStyle;

							}
							element += '></' + eName + '>';
							applicationType = "";
						}
					}
					break;
				default:
					var eName = 'nav-' + elementName;
					element = '<' + eName + ' parent=' + parentId;
					if (uniqueId) {
						element += ' id=' + uniqueId;
					}
					if (nodeFunction) {
						element += ' functionname=' + nodeFunction;
						/*if(nodeFunction == "webApplicationContent")
							{

					 		  element += ' parameters=' + params;

							}*/
					}
					if (nodeType) {

						element += ' type=' + nodeType;

					}
					if(parentType)
					{
						element += ' parentType=' + parentType;
					}
					if (nodeStyle) {

						element += ' nvstyle=' + nodeStyle;

					}
					if (navkey) {

						element += ' navkey=' + navkey;

					}
					if (orientation) {

						element += ' orientation=' + orientation;

					}
					if (bulletType) {

						element += ' bulletType=' + bulletType;

					}
					element += '></' + eName + '>';
			}

			var html = angular.element(element);
			var insertAt = getInsertPoint(parentId);

			if (insertAt) {
				start = angular.element(document.getElementById(insertAt));
			}
			else if(nodeType == 'topchrome'){
				start = angular.element(document.getElementById(HEADER_START_DIV));
			}
            else if(nodeType == 'topChromeNew'){
				start = angular.element(document.getElementById(HEADER_START_DIV));
			}
			else if(nodeType == 'navigation'){
				start = angular.element(document.getElementById(NEWMENU_DIV));
			}
            else if(nodeType == 'newNavigation'){
				start = angular.element(document.getElementById(NEWMENU_DIV));
			}
			else if(nodeType == 'page' || nodeType == 'boxpage'){
				start = angular.element(document.getElementById(CENTER_START_DIV));
			}
			else if(nodeType == 'footer'){
				start = angular.element(document.getElementById(FOOTER_START_DIV));
			}

			if(start==undefined || start==null){
			}
			else{
				start.append(html);
				$compile(html)($rootScope);
			}


		}

		function processNode(nodeName, node) {

			nodeInfo[node.uniqueId] = $.extend(true, {}, node);

			switch (node.nodeName) {

				case 'group':
					if(node.attributeMap.type == 'rows' && applicationType == 'boxpage')
					{

					}
					else if(node.attributeMap.type == 'rows')
					{
						addElement('UNORDERED-LIST', parents[node.uniqueId], node.uniqueId, node);
					}
					else if(node.attributeMap.type == 'baselinks' || node.attributeMap.type == 'leftjustified' || node.attributeMap.type == 'centerjustified' || node.attributeMap.type == 'tabLabel' || node.attributeMap.type == 'tabContainer' || node.attributeMap.type == 'tab'){
						//do nothing.
					}
					else
					{
						addElement(node.nodeName, parents[node.uniqueId], node.uniqueId, node);
					}

					if (node.attributeMap.header && node.attributeMap.type == 'box') {
						addElement(BOX_HEADER, node.uniqueId);
					}
					break;
				case 'column':
					//addElement('UNORDERED_LIST', parents[node.uniqueId], node.uniqueId, node);
					addElement(node.nodeName, parents[node.uniqueId], node.uniqueId, node);

					break;
				case 'listItem':
					addElement('column', parents[node.uniqueId], node.uniqueId, node);
					break;
				case 'image':
							if(node.childNodeList[0].nodeValue==undefined){
							}else{
								 addElement(node.nodeName, parents[node.uniqueId], node.uniqueId, node);
							}
					break;
				case 'application':
				case 'text':
				case 'link':
							addElement(node.nodeName, parents[node.uniqueId], node.uniqueId, node);
							break;
				case 'appid':
						/**
							This is to pass parameters to the included template's.
						*/
						if(node.attributeMap['function'] == "webApplicationContent")
							{
							  if(params!=null && params!=undefined){
								  node.attributeMap.parameters = window.encodeURIComponent(params);
							  }
							  else
								  {
								  	node.attributeMap.parameters = null;
								  }
							  nodeInfo[node.uniqueId] = $.extend(true, {}, node);
							}
						addElement(node.nodeName, parents[node.uniqueId], node.uniqueId, node);

					break;
				default:
					break;
			}


			if (node.childNodeList ) {
				if(node.attributeMap && (node.attributeMap.type=='linkblock' ||   node.attributeMap.style=='topBorder' ||  node.attributeMap.style=='top_Border' || node.attributeMap.style=='contentLink' || node.attributeMap.style=='bottomBorder' || node.attributeMap.type=='tabLabel' || node.attributeMap.style=='discountPageTitle' || node.attributeMap.style=='discountPageReadMoreSection' || node.attributeMap.style=='discountPageSeperator'))
				{
					//do nothing
				}
				else
				{
					for (var i = 0; i < node.childNodeList.length; i++) {
						var childNode = node.childNodeList[i];
						if(childNode.attributeMap && childNode.attributeMap.type){
							childNode.uniqueId = getUniqueId(childNode.attributeMap.type);
							/*if(childNode.attributeMap.type == "tab" && childNode.attributeMap.name){
								childNode.uniqueId = childNode.attributeMap.name;
							}*/
						}else{
							childNode.uniqueId = getUniqueId(childNode.nodeName);
						}
						parents[childNode.uniqueId] = node.uniqueId.toString();
						processNode(childNode.nodeName, childNode);

					}
				}

			}

		}

		/*function processNodeIndividually(nodeName, node){
	    nodeInfo[node.uniqueId] = $.extend(true, {}, node);
      switch (node.nodeName) {
      	case 'link':
          return addElements(node.nodeName);
          break;
        case 'appid':
          return addElements(node.nodeName);
          break;
        case 'image':
          return addElements(node.nodeName);
          break;
        case 'text':
          return addElements(node.nodeName);
          break;
        default:
          break;
      }
		}

    function addElements(elementName) {
    	var start;

      var eName = 'nav-' + elementName;
      var element = '<' + eName + ' title=';
      element += '></' + eName + '>';

      var html = angular.element(element);

      var htmls = $compile(html)($rootScope);
      return htmls;
    }*/

		function processNodeIndividually(nodeName, node){

			if(node.attributeMap && node.attributeMap.type){
				node.uniqueId = getUniqueId(node.attributeMap.type);
			}else{
				node.uniqueId = getUniqueId(node.nodeName);
			}
            nodeInfo[node.uniqueId] = $.extend(true, {}, node);
            switch (node.nodeName) {

            case 'group':
                  addElements(node.nodeName, parents[node.uniqueId], node.uniqueId);
                  if (node.attributeMap.header && node.attributeMap.type == 'box') {
                         addElement(BOX_HEADER, node.uniqueId);
                  }
                  break;

            case 'application':
            case 'link':
            case 'appid':
            case 'image':
            case 'text':
            case 'title':
                  return addElements(node.nodeName,node.uniqueId);
                  break;

            default:
                  break;
     }
            if (node.childNodeList) {
	            for (var i = 0; i < node.childNodeList.length; i++) {
	                  var childNode = node.childNodeList[i];
	                  processNodeIndividually(childNode.nodeName, childNode);
	            }
	     }


     }




function addElements(elementName,uniqueId) {
var start;
var parentType="secondary";
var parentId = 89808098;
var eName = 'nav-' + elementName;
     element = '<' + eName + ' parent=' + parentId;
     if (uniqueId) {
            element += ' id=' + uniqueId;
     }
    element += ' parentType=' + parentType;
     element += '></' + eName + '>';

var html = angular.element(element);

var htmls = $compile(html)($rootScope);
return htmls;
}



	}

})();

},{}],58:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('PdfService', PdfService);

	PdfService.$inject = ['$http', '$q', 'configuration', '$sessionStorage', 'ProviderSearchCriteriaService','$window'];

	function PdfService($http, $q, configuration,$sessionStorage,ProviderSearchCriteriaService,$window) {

		//var acoPdfURLs[][2];

		function getACOpdf( category ){
			return openACOpdf( category );
		};

		var getACOpdfs = function() {
			//return acoPdfURLs;
		}; // getACOpdfs

		function openACOpdf( category ){

			/* var criteria = ProviderSearchCriteriaService.getCriteria();
		  var siteId = criteria.siteId;
		  var lang = criteria.language;*/
			var apiUrl = configuration.acoPdfAPIURL;
			var clientId = configuration.acoPdfAPIClientId;

			//alert("Debug 1: " + $sessionStorage.isExternal  + "  " + configuration.externalACOPdfAPIURL +  category.trim()+configuration.externalClientId);

			if(  $sessionStorage.isExternal && $sessionStorage.isExternal == true  )
			{
				 apiUrl = configuration.externalACOPdfAPIURL;
				 clientId = configuration.externalACOpdfClientId;
			}

			if( category != null && category != ''){
				apiUrl = apiUrl + category.trim();
			}
			console.log("apiUrl :: "+apiUrl);

			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId,
				}
			}) .then(
					function success(response)
					{
						//alert("Debug success internal");
						if (response && response.data && response.data.ChannelACOMapping
								&& response.data.ChannelACOMapping.link
								&& response.data.ChannelACOMapping.link != '' ) {

							//alert("Debug 2: " + response + response.data.ChannelACOMapping.link );
							deferred.resolve(response);
							//$window.open(response.data.ChannelACOMapping.link,'_blank');
						} else {
							deferred.resolve('There is no pdf info found in response');
						}

						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{

						//alert ("Perfecto issue : internal : Error : response " + response.status );

						/* Perfecto issue changes */
						var perfectoSwitch = configuration.perfectoSwitch;

						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							return openACOpdfExternalCall( category );
						}
						else{
							// the following line rejects the promise
							deferred.reject(response);
							// promise is returned
							return deferred.promise;
						}
					});
		};


		function openACOpdfExternalCall( category ){
			var apiUrl = configuration.externalACOPdfAPIURL;
			var clientId = configuration.externalACOpdfClientId;

			//alert("Debug 4: " + $sessionStorage.isExternal  + "  " + configuration.externalACOPdfAPIURL +  category.trim()+configuration.externalClientId);

			if( category != null && category != ''){
				apiUrl = apiUrl + category.trim();
			}
			console.log("apiUrl :: "+apiUrl);

			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId,
				}
			}) .then(
					function success(response)
					{
						//alert("Debug success external");
						$sessionStorage.isExternal = true;

						if (response && response.data && response.data.ChannelACOMapping
								&& response.data.ChannelACOMapping.link
								&& response.data.ChannelACOMapping.link != '' ) {

							//alert("Debug 5: " + response + response.data.ChannelACOMapping.link );
							deferred.resolve(response);
						} else {
							deferred.resolve('There is no pdf info found in response');
						}

						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						//alert ("Perfecto issue : external : Error : response " + response.status );
						// the following line rejects the promise
						deferred.reject(response);
						// promise is returned
						return deferred.promise;

					});
		};

		return {
			getACOpdf:getACOpdf,
			openACOpdf:openACOpdf
		};
	}
})();

},{}],59:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('PlanListService', PlanListService);

	PlanListService.$inject = ['$http', '$q', 'configuration', '$sessionStorage', 'ProviderSearchCriteriaService','$state','$log'];

	function PlanListService($http, $q, configuration,$sessionStorage,ProviderSearchCriteriaService,$state,$log) {

		var geoTemplate = '';
		function getPlanPleatList(currProId, currLocId){
			return fetchPlanPleatList(currProId, currLocId);
		};

		function addMedicareSpecificParameters(apiUrl){
			var criteria = ProviderSearchCriteriaService.getCriteria();
			if(criteria.siteId!=undefined && criteria.siteId!=null && criteria.siteId =='medicare'){
				try{
					apiUrl = apiUrl + "&year="+criteria.medicare.planYear;
					apiUrl = apiUrl + "&planType="+criteria.medicare.category;
					apiUrl = apiUrl + "&planCounty="+(criteria.medicare.county).toUpperCase();
					apiUrl = apiUrl + "&planState="+criteria.medicare.state;
				}
				catch( e)
				{

				}
			}
			return apiUrl;
		}

		function fetchPlanPleatList(currProId, currLocId){
			var results;
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var apiUrl = configuration.publicPlanDetailsPleatAPIURL;

			var clientId = configuration.publicPlanDetailsPleatClientId;
			var secretId = configuration.publicPlanDetailsPleatSecretKey;

			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				apiUrl = configuration.externalPublicPlanDetailsPleatAPIURL;
				clientId = configuration.externalPublicPlanDetailsPleatClientId;
				secretId = configuration.externalPublicPlanDetailsPleatSecretKey;
			}

			
			var tempProId = 'PROID~'+currProId;
			apiUrl = apiUrl.replace("PROIDTempToBeFilled", tempProId);
			apiUrl = apiUrl + currLocId;
			apiUrl = apiUrl + "?docFindProductCode=" + criteria.planProductCode;
			var pType = $state.params.pType;
			var debug = $state.params.debug;
			if(pType != null && pType != undefined && pType == 'Organization'){
				apiUrl = apiUrl + "&listFieldSelections=groupsearch" + ((debug == 'true') ? ',debug' : '');
			}else
				apiUrl = apiUrl + "&listFieldSelections=affiliations" + ((debug == 'true') ? ',debug' : '');
			apiUrl = apiUrl + "&pipeName=" + criteria.planPipeName;

			/* Below new Parameter has been added for PNI Pleat new Logic which is to send either state or zipcode entered by the user */
			if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
				apiUrl = apiUrl + "&postalCode="+criteria.typeAheadLocationResults.zipcode;
			}else if(criteria.typeAheadLocationResults.stateabbr != '' && criteria.typeAheadLocationResults.stateabbr != undefined){
				apiUrl = apiUrl + "&state="+criteria.typeAheadLocationResults.stateabbr;
			}

			var siteId = criteria.siteId;
			var lang = criteria.language;

			apiUrl = addMedicareSpecificParameters(apiUrl);
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId,
					'X-IBM-Client-Secret' : secretId
				}
			}) .then(
					function success(response)
					{
						if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
						{
							// alert("Api url : " + apiUrl);
						}
						if (response) {
							if(response.status != 200){
								deferred.resolve('Status code not 200');
							}else{
								deferred.resolve(response);
							}
						} else {
							deferred.resolve('There is no plan details for the pleat info found in response');
						}
						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						/* Perfecto issue changes */
						var perfectoSwitch = configuration.perfectoSwitch;

						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							return fetchPlanPleatListExternalCall(currProId, currLocId);
						}
						else{
							if(response.status != 200 && !perfectoSwitch ){
								deferred.reject('Status code not 200');
							}else{
								printResponseDetails(response);
								deferred.reject(response);
							}
							return deferred.promise;
						}
					});
		};

		var printResponseDetails = function(response)
		{
			$log.debug("API :" + response.config.url);
			$log.debug("Response Header :" + response.status + " " + response.statusText);
			if(response.data!=null && response.data.error)
			{
				$log.error("Error: " + response.data.error +" - " + response.data.error_description);
			}
		}

		function fetchPlanPleatListExternalCall(currProId, currLocId){
			var results;
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var apiUrl = configuration.externalPublicPlanDetailsPleatAPIURL;
			var tempProId = 'PROID~'+currProId;
			apiUrl = apiUrl.replace("PROIDTempToBeFilled", tempProId);
			apiUrl = apiUrl + currLocId;
			apiUrl = apiUrl + "?docFindProductCode=" + criteria.planProductCode;
			apiUrl = apiUrl + "&listFieldSelections=affiliations";
			apiUrl = apiUrl + "&pipeName=" + criteria.planPipeName;
			
			/* Below new Parameter has been added for PNI Pleat new Logic */
			if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
				apiUrl = apiUrl + "&postalCode="+criteria.typeAheadLocationResults.zipcode;
			}else if(criteria.typeAheadLocationResults.stateabbr != '' && criteria.typeAheadLocationResults.stateabbr != undefined){
				apiUrl = apiUrl + "&state="+criteria.typeAheadLocationResults.stateabbr;
			}

			var siteId = criteria.siteId;
			var lang = criteria.language;

			var clientId = configuration.externalPublicPlanDetailsPleatClientId;
			var secretId = configuration.externalPublicPlanDetailsPleatSecretKey;

			apiUrl = addMedicareSpecificParameters(apiUrl);
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId,
					'X-IBM-Client-Secret' : secretId
				}
			}) .then(
					function success(response)
					{
						if (response) {
							if(response.status != 200){
								deferred.resolve('Status code not 200');
							}else{
								deferred.resolve(response);
							}
						} else {
							deferred.resolve('There is no plan details for the pleat info found in response');
						}
						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						if(response.status != 200){
							deferred.reject('Status code not 200');
						}
						return deferred.promise;
					});
		};

		function getPlanList(){
			return fetchPlanList();
		};

		function fetchPlanList(){

			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;
			var results;
			var apiUrl = configuration.planListAPIURL;
			var clientId = configuration.planListAPIURLClientId;
			if(criteria.planValFromURL == null || criteria.planValFromURL == ''){

				/* Added for Medicare project */
				if($state.params.site_id == 'medicare')
				{
					//apiUrl = configuration.plansListURL;
					apiUrl = apiUrl + "year="+criteria.medicare.planYear;
					apiUrl = apiUrl + "&category="+criteria.medicare.category;
					apiUrl = apiUrl + "&county="+(criteria.medicare.county).toUpperCase();
					apiUrl = apiUrl + "&state="+criteria.medicare.state;
					if(criteria.medicare.isDebug){
						apiUrl = apiUrl + "&debug="+criteria.medicare.isDebug;
					}
				}
				/* End - Added for Medicare project */
				else if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
					apiUrl = apiUrl + "postalCode="+criteria.typeAheadLocationResults.zipcode;
				}else if(criteria.typeAheadLocationResults.stateabbr != '' && criteria.typeAheadLocationResults.stateabbr != undefined){
					apiUrl = apiUrl + "state="+criteria.typeAheadLocationResults.stateabbr;
				}else {
					apiUrl = apiUrl;
				}
			}

			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId,
				}
			}) .then(
					function success(response)
					{
						if (response) {
							deferred.resolve(response);
						} else {
							deferred.resolve('There is no plan info found in response');
						}
						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						/* Perfecto issue changes */
						var perfectoSwitch = configuration.perfectoSwitch;

						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							return fetchPlanListExternalCall( );
						}
						else{
							// the following line rejects the promise
							deferred.reject(response);
							// promise is returned
							return deferred.promise;
						}
					});


		};

		/* Perfecto issue changes */
		function fetchPlanListExternalCall(){
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;
			var results;

			/* Perfecto issue changes */
			var externalApiURl = configuration.externalPlanListAPIURL;
			var externalClientId = configuration.externalClientId;
			if(criteria.planValFromURL == null || criteria.planValFromURL == ''){
				/* Added for Medicare project */
				if($state.params.site_id == 'medicare')
				{
				
					externalApiURl = externalApiURl + "year="+criteria.medicare.planYear;
					externalApiURl = externalApiURl + "&category="+criteria.medicare.category;
					externalApiURl = externalApiURl + "&county="+(criteria.medicare.county).toUpperCase();
					externalApiURl = externalApiURl + "&state="+criteria.medicare.state;
					if(criteria.medicare.isDebug){
						externalApiURl = externalApiURl + "&debug="+criteria.medicare.isDebug;
					}
				}
				/* End - Added for Medicare project */

				else if(criteria.typeAheadLocationResults.zipcode != '' && criteria.typeAheadLocationResults.zipcode != undefined){
					externalApiURl = externalApiURl + "postalCode="+criteria.typeAheadLocationResults.zipcode;
					//alert("if part");
				}else{
					/*if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)
					){
										//alert("else part");
										alert(externalApiURl);
										alert(criteria.useCurrentLocation);
										alert(criteria.position.state);
					 }*/
					if(criteria.useCurrentLocation){
						//alert("if part of useCurrentLocation");
						externalApiURl = externalApiURl + "state="+criteria.position.state;
					}
					else{
						//alert("else part of useCurrentLocation");
						externalApiURl = externalApiURl + "state="+criteria.typeAheadLocationResults.stateabbr;
					}
				}
			}
			// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
			// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
			// || navigator.userAgent.match(/Windows Phone/i)
			// ){
			// 					alert(externalApiURl);
			// 					alert(criteria.position.state);
			//  }
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: externalApiURl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : externalClientId,
				}
			}) .then(
					function success(response)
					{
						$sessionStorage.isExternal = true;
						//alert ("Perfecto issue : external : Success : response " + response.data );


						if (response) {
							deferred.resolve(response);
						} else {
							deferred.resolve('There is no plan info found in response');
						}
						// promise is returned
						return deferred.promise;
					},
					function error(response)
					{
						alert("internal error"  + JSON.stringify(response) +
								" \nurl" + externalApiURl + " " + externalClientId + 
								"\n params" + siteId + " " +lang );
						//alert ("Perfecto issue : external : Error : response " + response.status );
						// the following line rejects the promise
						deferred.reject(response);
						// promise is returned
						return deferred.promise;
					});

			//alert ("Perfecto issue : After plan list call ");

		};

		function setPlansArr(planList){
			var plans = [];
			var headerName;
			var subHeaderName;
			var plansToAdd;
			var headerLength = 0;
			var headerDesc = '';
			var order = 0;
			var criteria = ProviderSearchCriteriaService.getCriteria();
			
			if(planList.headerName){
				headerLength = planList.headerName.length;
			}
			//If header is present
			if(headerLength > 0){
				for (var i=0; i<headerLength; i++) {
					headerName = planList.headerName[i].name; // Add header name in the object
					order = planList.headerName[i].code;
					headerDesc = planList.headerName[i].description ? planList.headerName[i].description : '';
					//check if subHeader is present then iterate on subHeader and add subHeader and plans inside that in the object


					subHeader = planList.headerName[i].subHeaderName;
					subHeaderLength = subHeader.length;
					//If header has only one subheader
					if(subHeaderLength == 1 && subHeader[0].name != undefined && subHeader[0].name != ''){
						subHeaderName = subHeader[0].name;
						subHeaderCode = subHeader[0].code;
						totalLength =0;
						for(var a=0;a<subHeaderLength;a++){
							totalLength = totalLength + subHeader[a].plan.length;
						}	
						plan = subHeader[0].plan;
						planLength = plan.length;
						if(planLength > 0){
							for (var k=0; k<planLength; k++) {
								plansToAdd = {};
								plansToAdd.headerName = headerName;
								plansToAdd.subHeaderName = subHeaderName;
								plansToAdd.productCode = plan[k].productCode;
								plansToAdd.pipeName = plan[k].pipeName;
								plansToAdd.displayName = plan[k].displayName;
								plansToAdd.dummyId = plan[k].productCode+"_"+plan[k].pipeName;
								if(!angular.isArray(plan[k].link))
								{
									plansToAdd.externalUrl = plan[k].link.externalUrl;
									plansToAdd.redirectUrl = plan[k].link.redirectUrl;
								}
								else if(plan[k].link!=undefined && plan[k].link.length == 1)
								{
									plansToAdd.externalUrl = plan[k].link[0].externalUrl;
									plansToAdd.redirectUrl = plan[k].link[0].redirectUrl;
								}
								plansToAdd.inGeo = plan[k].inGeo;
								//Attributes specifically needed for medicare. 
								plansToAdd.plansLength = totalLength;
								plansToAdd.headerDesc = headerDesc;
								plansToAdd.shortDesc = plan[k].shortDesc;
								plansToAdd.longDesc = plan[k].longDesc;
								plansToAdd.planType = plan[k].planType;
								plansToAdd.link = plan[k].link;
								plansToAdd.pinDisplay=plan[k].pinDisplay;
								plansToAdd.code = order;
								plansToAdd.subHeaderCode = subHeaderCode;
								
								if(criteria.siteId && criteria.siteId == 'medicare'){
									plansToAdd.dummyId = plan[k].productCode+"_"+plan[k].pipeName+"_"+headerName;
								}
								plans.push(plansToAdd);
							}
						}
					}else{

						totalLength =0;
						
						for(var a=0;a<subHeaderLength;a++){
							totalLength = totalLength + subHeader[a].plan.length;
						}
						if(subHeaderLength > 1){
							for (var j=0; j<subHeaderLength; j++) {
								subHeaderName = subHeader[j].name;
								subHeaderCode = subHeader[j].code;
								plan = subHeader[j].plan;
								planLength = plan.length;
								if(planLength > 0){
									for (var k=0; k<planLength; k++) {
										plansToAdd = {};
										plansToAdd.headerName = headerName;
										plansToAdd.subHeaderName = subHeaderName;
										plansToAdd.productCode = plan[k].productCode;
										plansToAdd.pipeName = plan[k].pipeName;
										plansToAdd.displayName = plan[k].displayName;
										plansToAdd.dummyId = plan[k].productCode+"_"+plan[k].pipeName;
										if(!angular.isArray(plan[k].link))
										{
											plansToAdd.externalUrl = plan[k].link.externalUrl;
											plansToAdd.redirectUrl = plan[k].link.redirectUrl;
										}
										else if(plan[k].link!=undefined && plan[k].link.length == 1)
										{
											plansToAdd.externalUrl = plan[k].link[0].externalUrl;
											plansToAdd.redirectUrl = plan[k].link[0].redirectUrl;
										}
										plansToAdd.inGeo = plan[k].inGeo;
										//Attributes specifically needed for medicare. 
										plansToAdd.plansLength = totalLength;
										plansToAdd.headerDesc = headerDesc;
										plansToAdd.shortDesc = plan[k].shortDesc;
										plansToAdd.longDesc = plan[k].longDesc;
										plansToAdd.planType = plan[k].planType;
										plansToAdd.link = plan[k].link;
										plansToAdd.pinDisplay=plan[k].pinDisplay;
										plansToAdd.code = order;
										plansToAdd.subHeaderCode = subHeaderCode;
										//plansToAdd.dummyId = plan[k].productCode+"_"+k
										if(criteria.siteId && criteria.siteId == 'medicare'){
												plansToAdd.dummyId = plan[k].productCode+"_"+plan[k].pipeName+"_"+headerName;
										}
										plans.push(plansToAdd);
									}
								}
							}
						}else{
							//if subHeader is not present then add plans in the object
							subHeaderName ='';
							plan = planList.headerName[i].plan;
							planLength = plan.length;
							//adding the plan[0].displayNae check as apic sends empty linkcausing the planLength> 0
							if(planLength > 0 && plan[0].displayName!=undefined){
								for (var j=0; j<planLength; j++) {
									plansToAdd = {};
									plansToAdd.headerName = headerName;
									plansToAdd.subHeaderName = subHeaderName;
									plansToAdd.productCode = plan[j].productCode;
									plansToAdd.pipeName = plan[j].pipeName;
									plansToAdd.displayName = plan[j].displayName;
									plansToAdd.dummyId = plan[j].productCode+"_"+plan[j].pipeName;
									
									if(!angular.isArray(plan[j].link))
									{
										plansToAdd.externalUrl = plan[j].link.externalUrl;
										plansToAdd.redirectUrl = plan[j].link.redirectUrl;
									}
									else if(plan[j].link!=undefined && plan[j].link.length == 1)
									{
										plansToAdd.externalUrl = plan[j].link[0].externalUrl;
										plansToAdd.redirectUrl = plan[j].link[0].redirectUrl;
									}
									if(criteria.siteId && criteria.siteId == 'medicare'){
									  plansToAdd.dummyId = plan[j].productCode+"_"+plan[j].pipeName+"_"+headerName;
								    }
									plansToAdd.inGeo = plan[j].inGeo;
									plansToAdd.pinDisplay=plan[j].pinDisplay;
									//No plans will ever be added to medicare without a subheader. 
									/*if($state.params.site_id == 'medicare'){
										plansToAdd.plansLength = totalLength;
										plansToAdd.headerDesc = headerDesc;
										plansToAdd.shortDesc = plan[k].shortDesc;
										plansToAdd.longDesc = plan[k].longDesc;
										plansToAdd.planType = plan[k].planType;
										plansToAdd.link = plan[k].link;
										plansToAdd.code = order;
										//plansToAdd.dummyId = plan[k].productCode+"_"+k
									}*/
									plans.push(plansToAdd);
								}
							}
							else{
								//If subheader is not present and there are no plans too, then in case of medicare, we stil need to show the header. Needed for medicare 
								if(subHeaderLength == 1 && (subHeader[0].name == undefined || subHeader[0].name == '' ))
								{
									plansToAdd = {};
									plansToAdd.headerName = headerName;
									plansToAdd.plansLength = 0;
									plansToAdd.headerDesc = headerDesc;
									plansToAdd.code = order;
									plans.push(plansToAdd);
								}

							}
						}
					}
				}
			}else{
				//If plans are without any header
				headerName = '';
				subHeaderName ='';
				planLength = planList.plan.length;
				if(planLength > 0){
					plan = planList.plan;
					for (var j=0; j<planLength; j++) {
						plansToAdd = {};
						plansToAdd.headerName = headerName;
						plansToAdd.subHeaderName = subHeaderName;
						plansToAdd.productCode = plan[j].productCode;
						plansToAdd.pipeName = plan[j].pipeName;
						plansToAdd.displayName = plan[j].displayName;
						plansToAdd.dummyId = plan[j].productCode+"_"+plan[j].pipeName;
						
						if(!angular.isArray(plan[j].link))
						{
							plansToAdd.externalUrl = plan[j].link.externalUrl;
							plansToAdd.redirectUrl = plan[j].link.redirectUrl;
						}
						else if(plan[j].link!=undefined && plan[j].link.length == 1)
						{
							plansToAdd.externalUrl = plan[j].link[0].externalUrl;
							plansToAdd.redirectUrl = plan[j].link[0].redirectUrl;
						}
				
						plansToAdd.inGeo = plan[j].inGeo;
						plansToAdd.pinDisplay=plan[j].pinDisplay;
						plans.push(plansToAdd);
					}
				}
			}
			return plans;
		}
		var isOpened = true;
		function selectedPlan(planYear, category, index){
			var geoPleat = false;
			var perResidencePleat = false;
			var isLocationboxClicked = false;
			var criteria = ProviderSearchCriteriaService.getCriteria();
			criteria.medicare.geoPleat = true;
			criteria.medicare.perResidencePleat = true;
			if(planYear != undefined && category != undefined)
			{
				criteria.medicare.planYear = planYear;
				criteria.medicare.category = category;
			}
			if(!clicked){
				clicked = true;
				if(document.getElementsByClassName('columnOne') != undefined && document.getElementById('dynamicTemplate') != undefined && 
						document.getElementsByClassName('columnOne').length>0)
				{
					document.getElementsByClassName('columnOne')[0].style.display = "none";
					document.getElementById('dynamicTemplate').style.display = "block";
					geoTemplate = document.getElementById('dynamicTemplate');
					$('.My_Coverage').append(geoTemplate);
				}
			} else {
				setShowCounty(false);
				criteria.medicare.planTypeaHeadLocation = '';
				$('.My_Coverage #dynamicTemplate').remove();
				/*Need to destroy all watches...*/
				$('.My_Coverage').append(geoTemplate);
			}
			if((navigator.userAgent.match(/Android/i) && window.screen.width < 992) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
					|| (navigator.userAgent.match(/iPad/i) && window.screen.width < 992) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
					|| navigator.userAgent.match(/Windows Phone/i)){
				if(window.location.href.indexOf("openPleats") != -1){
					memberPleat = false;
					geoPleat = false;
					perResidencePleat = false;
				}else{
					memberPleat = criteria.medicare.memberPleat;
					geoPleat = criteria.medicare.geoPleat;
					perResidencePleat = criteria.medicare.perResidencePleat;
				}
				//$(".thirdPleatBody").toggle(1000);
				$(".firstPleatHead").attr("tabindex", "0");
				$(".secondPleatHead").attr("tabindex", "0");
				$(".thirdPleatHead").attr("tabindex", "0");

				/*$(".secondPleatHead").keypress(function(e) {
						if (e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
								geoPleat = !geoPleat;
								$scope.criteria.medicare.geoPleat = !geoPleat;
								$(".secondPleatBody").toggle(1000);
							}
						});*/
				$(".thirdPleatHead").keypress(function(e) {
					if(e.keyCode == 13 || e.keyCode === 0 || e.keyCode === 32) {
						perResidencePleat = !perResidencePleat;
						criteria.medicare.perResidencePleat = !perResidencePleat;
						setGeoTemplate(!isOpened);
						$(".thirdPleatBody").toggle(1000);
					}
				});

				/*$(".secondPleatHead").click(function() {
							geoPleat = !geoPleat;
							$scope.criteria.medicare.geoPleat = !geoPleat;
							$(".secondPleatBody").toggle(1000);
						});*/

				$(".thirdPleatHead").click(function(){
					perResidencePleat = !perResidencePleat;
					criteria.medicare.perResidencePleat = !perResidencePleat;
					if(criteria.medicare.perResidencePleat){
							setGeoTemplate(!isOpened);
					}
					$(".thirdPleatBody").toggle(1000);
				});
			}
			//$sessionStorage.criteria=criteria;
		};

		var isShowCounty;
		function getShowCounty()
		{
			return isShowCounty;
		}

		function setShowCounty(showCounty)
		{
			isShowCounty = showCounty;
		}
		
		var isGeotemplateEnable = true;
		function getGeoTemplate()
		{
			return isGeotemplateEnable;
		}

		function setGeoTemplate(showTemplate)
		{
			isGeotemplateEnable = showTemplate;
		}

		return {
			getPlanList:getPlanList,
			getPlanPleatList:getPlanPleatList,
			setPlansArr:setPlansArr,
			selectedPlan:selectedPlan,
			getShowCounty: getShowCounty,
			setShowCounty: setShowCounty,
			getGeoTemplate: getGeoTemplate,
			setGeoTemplate:setGeoTemplate
		};
	}
})();

},{}],60:[function(require,module,exports){
(function() {

	angular.module('nav-ui').service('RatingsService', RatingsService);

	RatingsService.$inject = ['configuration', '$http', '$q', '$log', '$translate', '$sessionStorage'];

	function RatingsService(configuration, $http, $q, $log, $translate, $sessionStorage) {
		// service initialization

		// css classes to produce all 10 types of stars from empty to full
		var stars = ["star0","star1","star2","star3","star4","star5","star6","star7","star8","star9"];

		var ratings;  // holds all ratings information

		initialize();

		// clear everything in preparation to get another set of ratings
		function initialize() {
			ratings = {};  // prepare for new ratings
			ratings.ids = [];  // everyone to get ratings for
		}

		// set the classes that produce the stars for ratings
		// 10 levels of stars from empty to full
		// names: an array of 10 strings containing class names
		function setStarClassNames(names) {
			stars = names;
		}

		// add a provider to list of providers to get ratings for
		function checkRating(id) {
			//console.log('checkRating: ' + id);
			if (id) {
				ratings.ids.push(id);  // add to list
				ratings[id] = {};  // ratings for this id
				// all stars for this id default to empty
				ratings[id].status = 'added';  // added but not checked
				ratings[id].numRatings = 0;  // nothing yet
				ratings[id].rating = 0;  // no ratings yet
				//console.log('ID added: ' + id);
			}
		}

		// given a rating number and a star number, return the class needed to produce that star
		// rating: string with values '0' or '1.0' to '5.0'
		// star: 1 to 5
		function calculateStarClass(rating,star) {
			// get data in the form x.y
			//console.log('calculateStarClass: ' + rating,',',star);
			rating += '';  // turn into a string
			if (rating.length == 1) {
				rating += ".0";
			} else if (rating.length < 3) {
				rating = '0.0';  // bad data
			} else if (rating.length > 3) {
				rating = rating.substr(0,3);
			}
			if (rating < '0.0' || rating > '5.0' || rating.length != 3) {
				rating = '0.0';  // bad data
			}

			// get the whole and decimal parts of the rating
			var whole = parseInt(rating.substr(0,1));
			var part = parseInt(rating.substr(2,3));

			var className;
			if (star <= whole) {
				// full stars up to the rating number
				className = stars[9];
			} else if (star > whole+1) {
				// empty stars after the rating number and partial rating
				className = stars[0];
			} else {
				// doing partial rating star (decimal value 0 to 9
				className = stars[part];
			}
			//console.log('calculateStarClass returns: ' + className);
			return className;
		}

		// rating status for an id.  The valid values are
		// - notFound: id was never added to be rated or service found no info on id
		// - added: id was added but not processed by web service
		// - found: id has info from the rating web service
		function ratingStatus(id) {
			//console.log('ratingsStatus: ' + id);
			if (!id || !ratings || !ratings[id]) {
				//console.log('returns: notFound');
				return 'notFound';  // bad data means not rated
			} else {
				//console.log('returns: ' + ratings[id].status);
				return ratings[id].status;
			}
		}

		// get the rating for an id
		function getRating(id) {
			//console.log('getRating: ' + id);
			if (!id || !ratings || !ratings[id]) {
				//console.log('returns: 0');
				return 0;  // bad data means not rated
			} else {
				//console.log('returns: ' + ratings[id].rating);
				return ratings[id].rating;
			}
		}

		// get the value for a particular star on an id
		function getStarClass(id,star) {
			return calculateStarClass(getRating(id), star);
		}

		// get the number of ratings for a particular star on an id
		function getNumberOfRatings(id) {
			//console.log('getNumberOfRatings: ' + id);
			if (!id || !ratings || !ratings[id]) {
				//console.log('returns: 0');
				return 0;  // bad data means not rated
			} else {
				//console.log('returns: ' + ratings[id].numRatings);
				return ratings[id].numRatings;
			}
		}

		// call the ratings service for all providers added
		function getAllRatings() {
			
			var apiUrl;
			var clientId;
			
			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				apiUrl = configuration.externalProviderRatingsServiceURL;
				clientId = configuration.externalProviderRatingsServiceClientId;
			}
			else
			{
				apiUrl = configuration.ProviderRatingsServiceURL;
				clientId = configuration.ProviderRatingsServiceClientId;
			}
			
			apiUrl = buildRatingsServiceURL( apiUrl );
			
			//alert (apiUrl + "   " + clientId );
			
			//console.log('getAllRatings: ' + apiUrl);
			var results;
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(

				function success(response) {
					
					//alert ( " Success : " + JSON.stringify(response)); 
					
					//console.log('getAllRatings success');
					if (response.data && // something back from the service
							response.data.providerReviewsResponse && // something valid from service
							response.data.providerReviewsResponse.status && // valid status from service
							response.data.providerReviewsResponse.status.statusCode == 0 && // good status
							response.data.providerReviewsResponse.readProviderReviewsResponse && // data returned
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews // review data returned
					) {
						//console.log('good results');
						results = response.data;
						deferred.resolve(results);
						processRatingsData(response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews);
					} else {
						//console.log('bad results');
						deferred.resolve('No Results found');
					}

					// promise is returned
					return deferred.promise;
				},
				function error(response) {
					
					//alert ( " Error : " + JSON.stringify(response)); 
					
					/* Perfecto issue changes */
					var perfectoSwitch = configuration.perfectoSwitch;

					if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
					{
						return getAllRatingsExternalCall( ); 
					}
					else{
						//console.log('getAllRatings error: ' + JSON.stringify(response));
						deferred.reject(response);
						return deferred.promise;
					}
				});

		};
		
		/* Perfecto Issue - External call */
		function getAllRatingsExternalCall() {
			var apiUrl = buildExternalRatingsServiceURL();
			var clientId = configuration.externalProviderRatingsServiceClientId;
			//console.log('getAllRatings: ' + apiUrl);
			var results;
			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(

				function success(response) {
					//console.log('getAllRatings success');
					if (response.data && // something back from the service
							response.data.providerReviewsResponse && // something valid from service
							response.data.providerReviewsResponse.status && // valid status from service
							response.data.providerReviewsResponse.status.statusCode == 0 && // good status
							response.data.providerReviewsResponse.readProviderReviewsResponse && // data returned
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews // review data returned
					) {
						//console.log('good results');
						results = response.data;
						deferred.resolve(results);
						processRatingsData(response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews);
					} else {
						//console.log('bad results');
						deferred.resolve('No Results found');
					}

					// promise is returned
					return deferred.promise;
				},
				function error(response) {
					//console.log('getAllRatings error: ' + JSON.stringify(response));
					deferred.reject(response);
					return deferred.promise;
				});

		};
		
		// create the URL for the ratings service
		function buildExternalRatingsServiceURL() {
			//console.log('buildRatingsServiceURL()')
			var url = configuration.externalProviderRatingsServiceURL;  // url including ?
			var providerIdList = '';  // comma-separated list of IDs
			for (var i=0; i<ratings.ids.length; i++) {
				if (i>0) {
					providerIdList += ',';  // comma before all but first id
				}
				var id = ratings.ids[i];
				ratings[id].status = "notFound";  // not yet
				// the service needs leading zeros to make the ID 10 digits
				id = '0000000000' + id;
				id = id.substr(id.length - 10);
				providerIdList += id;
			}

			// create the URL parameters from the data
			var parmProviderIDs = "providerIDs=" + encodeURIComponent(providerIdList);

			// create the URL
			url += parmProviderIDs;
			//console.log('returns: ' + url);
			return url;
		}


		// create the URL for the ratings service
		function buildRatingsServiceURL( APIurl ) {
			//console.log('buildRatingsServiceURL()')
			var url = APIurl;  // url including ?
			var providerIdList = '';  // comma-separated list of IDs
			for (var i=0; i<ratings.ids.length; i++) {
				if (i>0) {
					providerIdList += ',';  // comma before all but first id
				}
				var id = ratings.ids[i];
				ratings[id].status = "notFound";  // not yet
				// the service needs leading zeros to make the ID 10 digits
				id = '0000000000' + id;
				id = id.substr(id.length - 10);
				providerIdList += id;
			}

			// create the URL parameters from the data
			var parmProviderIDs = "providerIDs=" + encodeURIComponent(providerIdList);

			// create the URL
			url += parmProviderIDs;
			//console.log('returns: ' + url);
			return url;
		}

		// process the array of ratings data from the ratings service.  Populate the global structure.
		// If only one rating, object is not an array.
		function processRatingsData(data) {
			if (!Array.isArray(data)) {
				// turn data into an array
				data = [data];
			}
			//console.log('processRatingsData: ' + data.length + ' elements');
			for (var i=0; i<data.length; i++) {
				var status = 'notFound';  // assume the worst
				var single = data[i];
				var id = parseInt(single.providerID);
				var numRatings = 0;  // default
				var rating = 0;  // default
				var addReviewURL = null;  // default
				var readReviewsURL = null;  // default
				if (single.PrimaryNPI &&
						single.PrimaryNPI.rating &&
						Array.isArray(single.PrimaryNPI.rating) &&
						single.PrimaryNPI.rating.length >= 1 &&
						single.PrimaryNPI.rating[0].responseCode == "000" && /* When the data is not available in EDH the response code is 102 000 is for success */
						single.PrimaryNPI.rating[0].ratingSummary &&
						typeof single.PrimaryNPI.rating[0].ratingSummary.numberOfRatings == 'string'  // data exists
						) {
					var summary = single.PrimaryNPI.rating[0].ratingSummary;
					status = 'found';
					numRatings = summary.numberOfRatings;
					rating = summary.averageRating ? summary.averageRating : '0';
					addReviewURL = single.PrimaryNPI.rating.addReviewURL;
					readReviewsURL = single.PrimaryNPI.rating.readReviewsURL;
				}
				//console.log('id=' + id + ', numRatings=' + numRatings + ', rating=' + rating);
				ratings[id].status = status;
				ratings[id].numRatings = numRatings;
				ratings[id].rating = rating;
				ratings[id].addReviewURL = addReviewURL;
				ratings[id].readReviewsURL = readReviewsURL;
			}
		}

		return {
			initialize: initialize,
			setStarClassNames: setStarClassNames,
			checkRating: checkRating,
			getAllRatings: getAllRatings,
			ratingStatus: ratingStatus,
			getRating: getRating,
			getStarClass: getStarClass,
			getNumberOfRatings: getNumberOfRatings
		};


	}

})();

},{}],61:[function(require,module,exports){
(function() {

angular.module('nav-ui').service('ProviderResultsService', ProviderResultsService);

ProviderResultsService.$inject = ['$http','$q','ProviderSearchCriteriaService','$log','$timeout',
  '$sessionStorage','$window','$translate','configuration','$rootScope', '$state', 'AnalyticsService','$filter','LanguageDataService','CommonUtilsService'];

function ProviderResultsService($http,$q,ProviderSearchCriteriaService,$log,$timeout,
	$sessionStorage,$window,$translate,configuration,$rootScope,$state,AnalyticsService,$filter,LanguageDataService,CommonUtilsService) {

		var currentPage='';
		var findDoctors='';
		var multipleLocations;
		var provider={};
		var hospitalId='';
		var groupName='';
		var groupId='';
		var ipaId='';
		var scrollTo ='';
		var newSearchClicked;
		var cancelFilter;
		var okFilter;
		var updatedDate='';
		var hideDistance=false;
		var providerType=''; //
		var compareData={};  // holds data and flags used for displaying compare content
		compareData.MAX_SIZE = 3;  // max number of providers that can be compared
		compareData.showCompare = false;
		var associatedProvidersSearchForGroup = false;/* used to indicate that the search is for assocaited providers by clicking on 
		 'Find Doctors associated to group' link. */
		

		function setAllVariables( allVariables ){
			currentPage = allVariables.currentPage;
			findDoctors = allVariables.findDoctors;
			multipleLocations = allVariables.multipleLocations;
			provider = allVariables.provider;
			hospitalId = allVariables.hospitalId;
			groupName = allVariables.groupName;
			groupId = allVariables.groupId;
			ipaId = allVariables.ipaId;
			scrollTo = allVariables.scrollTo;
			newSearchClicked = allVariables.newSearchClicked;
			cancelFilter = allVariables.cancelFilter;
			okFilter = allVariables.okFilter;
			updatedDate = allVariables.updatedDate;
			hideDistance = allVariables.hideDistance;
			providerType = allVariables.providerType; 
			compareData = allVariables.compareData;  
			associatedProvidersSearchForGroup = allVariables.associatedProvidersSearchForGroup;
			
		};
		
		function getAllVariables(){
			return allVariables = {
					"currentPage" : currentPage,
					"findDoctors" : findDoctors,
					"multipleLocations" : multipleLocations,
					"provider" : provider,
					"hospitalId" : hospitalId,
					"groupName" : groupName,
					"groupId" : groupId,
					"ipaId" : ipaId,
					"scrollTo" : scrollTo,
					"newSearchClicked" : newSearchClicked,
					"cancelFilter" : cancelFilter,
					"okFilter" : okFilter,
					"updatedDate" : updatedDate,
					"hideDistance" : hideDistance,
					"providerType" : providerType, 
					"compareData" : compareData, 
					"associatedProvidersSearchForGroup" : associatedProvidersSearchForGroup
			};
		};
		
		var getProvider = function(){
			
			if($sessionStorage.provider!=null && $sessionStorage.provider!=undefined)
			{
				provider = $sessionStorage.provider;

			}			
			return provider;
		};
		function getMultipleLocations(){
			return multipleLocations;
		};

		function getHospitalId(){
			return hospitalId;
		};

		provider = getProvider();
		var resultSearch = 0;
		var results_scopeID;
		var groupListSelections = '[{"listAttributeName":"groupnavigator","listFilterCode":"{{groupId}}"}]';

		function getResults(){
			   return fetchResults();
		};

		function createURLforIpaDetails(url,id){
    			var criteria = ProviderSearchCriteriaService.getCriteria();
          var languageData = LanguageDataService.getLanguageData();
    			var orgListSelections = '[{"listAttributeName":"orgnavigator","listFilterCode":"{{orgId}}"}]';
    			var listSelections = orgListSelections.replace('{{orgId}}',id);
				// url = url + "listSelections=" +  window.encodeURIComponent(listSelections) +  "&";

				var processedThisLS = window.encodeURIComponent(listSelections);
				if(criteria.listSelections!=null && criteria.listSelections!='' && criteria.listSelections!="%5B%5D" && criteria.listSelections!="[]")
				{
					var processedOldnThis = concateOldFilters(processedThisLS, criteria.listSelections);
					url = url + "listSelections=" + "%5B" +  processedOldnThis + "%5D" +  "&";
				}else{
					url = url + "listSelections=" + "%5B" +  processedThisLS + "%5D" + "&";
				}

    			var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
    			url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&";
    			if(criteria.isGuidedSearch){
    				url = url + "isGuidedSearch=true&";
    			}
    			else{
    				url = url + "isGuidedSearch=false&";
    			}
    			if(criteria.direction!='')
    			{
    				url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
    				url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
    				url = url + "direction=" + criteria.direction + "&";
    				url = url + "total=" + criteria.total + "&";
    			}
    			else{
    				url = url + "firstRecordOnPage=1&";
    				url = url + "lastRecordOnPage=0&";
    				//url = url + "direction=''&";
    			}
    			if(criteria.planProductCode!=''){
    				url = url + "productIdentifier=~" + criteria.planProductCode + "&";
    			}
    			return url;
		}

		/** function to create the url parameters for Group affiliations**/
		function createURLforGroupDetails( url, id, groupName, associatedProvidersSearchForGroup ){
    			var criteria = ProviderSearchCriteriaService.getCriteria();
          var languageData = LanguageDataService.getLanguageData();
    			var groupListSelections = '{"listAttributeName":"groupnavigator","listFilterCode":"{{groupId}}"}';
				var listSelections = groupListSelections.replace('{{groupId}}',id);
				var processedThisLS = window.encodeURIComponent(listSelections);
				if(criteria.listSelections!=null && criteria.listSelections!='' && criteria.listSelections!="%5B%5D" && criteria.listSelections!="[]")
				{
					var processedOldnThis = concateOldFilters(processedThisLS, criteria.listSelections);
					url = url + "listSelections=" + "%5B" +  processedOldnThis + "%5D" +  "&";
				}else{
					url = url + "listSelections=" + "%5B" +  processedThisLS + "%5D" + "&";
				}

    			var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
    			url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&";
    			if(criteria.isGuidedSearch){
    				url = url + "isGuidedSearch=true&";
    			}
    			else{
    				url = url + "isGuidedSearch=false&";
    			}
    			if(criteria.direction!='')
    			{
    				url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
    				url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
    				url = url + "direction=" + criteria.direction + "&";
    				url = url + "total=" + criteria.total + "&";
    			}
    			else{
    				url = url + "firstRecordOnPage=1&";
    				url = url + "lastRecordOnPage=0&";
    				//url = url + "direction=''&";
    			}
		        if(criteria.planProductCode!=''){
		            url = url + "productIdentifier=~" + criteria.planProductCode + "&";
		        }
    			return url;
		}

		/** function to creste the url parameters for hospital affiliations**/
		function createURLforHospitalAffiliations(url,hospitalId){
      			var criteria = ProviderSearchCriteriaService.getCriteria();
            var languageData = LanguageDataService.getLanguageData();
      			var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
      			url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&";
      			url = url + "providerID=" + hospitalId + "&";
      			if(criteria.isGuidedSearch){
      				url = url + "isGuidedSearch=true&";
      			}
      			else{
      				url = url + "isGuidedSearch=false&";
      			}
      			if(criteria.direction!='')
      			{
      				url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
      				url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
      				url = url + "direction=" + criteria.direction + "&";
      				url = url + "total=" + criteria.total + "&";
      			}else{
      				url = url + "firstRecordOnPage=1&";
      				url = url + "lastRecordOnPage=0&";
      				//url = url + "direction=''&";
      			}
      			if(criteria.planProductCode!=''){
      				url = url + "productIdentifier=~" + criteria.planProductCode + "&";
      			}
      		return url;
		}

    function createURLforProviderDetails(){
			provider = getProvider();
			var pProviderIdentifier=provider.providerInformation.providerID;

			var  locations = provider.providerLocations;
			var locationsArray = $filter('toArray')(locations);


			var pServiceLocationIdentifier=locationsArray[0].locationID;
			$rootScope.distance = locationsArray[0].address.distance;

			var pType = provider.providerInformation.type;
			var criteria = ProviderSearchCriteriaService.getCriteria();
      var languageData = LanguageDataService.getLanguageData();
			var apiUrl = configuration.ProviderDetailsIndividualURL;

			if(pType === "Individual")
				apiUrl = configuration.ProviderDetailsIndividualURL;
			else if(pType === "Hospital")
				apiUrl = configuration.ProviderDetailsHospitalURL;
			else if(pType === "Organization")
				apiUrl = configuration.ProviderDetailsOrganizationURL;

			var url = apiUrl;
			url = url + "providerIdentifier="+pProviderIdentifier+"&serviceLocationIdentifier="+pServiceLocationIdentifier+"&";
			var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
			url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&" ;
			if(criteria.planProductCode!=''){
				url = url + "productCode=" + criteria.planProductCode + "&";
			}
			// send the language selected by the user
			//var lang = $translate.use();
			//url = url + "responseLanguagePreference=en";
			return url;
		}

    function createExternalURLforProviderDetails(){
		provider = getProvider();

		var  locations = provider.providerLocations;
		var locationsArray = $filter('toArray')(locations);


		var pProviderIdentifier=provider.providerInformation.providerID;
		var pServiceLocationIdentifier=locationsArray[0].locationID;
		$rootScope.distance = locationsArray[0].address.distance;

		/*var pServiceLocationIdentifier=provider.providerLocations.locationID;
		$rootScope.distance = provider.providerLocations.address.distance;*/
		console.log("Distance : " +$rootScope.distance);
		var pType = provider.providerInformation.type;
		var criteria = ProviderSearchCriteriaService.getCriteria();
    var languageData = LanguageDataService.getLanguageData();
		var apiUrl = configuration.externalProviderDetailsIndividualURL;

		if(pType === "Individual")
			apiUrl = configuration.externalProviderDetailsIndividualURL;
		else if(pType === "Hospital")
			apiUrl = configuration.externalProviderDetailsHospitalURL;
		else if(pType === "Organization")
			apiUrl = configuration.externalProviderDetailsOrganizationURL;

		var url = apiUrl;
		url = url + "providerIdentifier="+pProviderIdentifier+"&serviceLocationIdentifier="+pServiceLocationIdentifier+"&";
		var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
		url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&" ;
		if(criteria.planProductCode!=''){
			url = url + "productCode=" + criteria.planProductCode + "&";
		}
		// send the language selected by the user
		//var lang = $translate.use();
		//url = url + "responseLanguagePreference=en";
		return url;
	}

		/**function to create the url paramaeters needed to show different office locations of a provider**/

		function createURLforOfficeLocation(url)
		{
      				var provider = getProvider();
      				if(provider.providerInformation.providerID){
      					url = url + "providerID=" + provider.providerInformation.providerID + "&";
      				}
      				var criteria = ProviderSearchCriteriaService.getCriteria();
              var languageData = LanguageDataService.getLanguageData();
      				var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
      				url = url + appendListFieldSelectionsToUrl(suppressFutureProviders) +"&";
      				if(criteria.isGuidedSearch){
      					url = url + "isGuidedSearch=true&";
      				}
      				else{
      					url = url + "isGuidedSearch=false&";
      				}
      				if(criteria.direction!='')
      				{
      					url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
      					url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
      					url = url + "direction=" + criteria.direction + "&";
      					url = url + "total=" + criteria.total + "&";
      				}
      				else{
      					url = url + "firstRecordOnPage=1&";
      					url = url + "lastRecordOnPage=0&";
      					//url = url + "direction=''&";
      				}
      				if(criteria.planProductCode!=''){
      					url = url + "productIdentifier=~" + criteria.planProductCode + "&";
      				}
      			return url;
		};

		/** function to show different doctors associated to the hospital**/

		function createURLforFindDoctors(url)
		{
        var criteria = ProviderSearchCriteriaService.getCriteria();
		var provider = getProvider();
		var groupListSelections = '{"listAttributeName":"hospitalnavigator","listFilterCode":"{{hospitalId}}"}';

		if(criteria.findDocPrevId){
				if(criteria.listSelections!=null && criteria.listSelections!=undefined && criteria.listSelections!=""){
						listSelections = criteria.listSelections;
						url= url + "listSelections=" + listSelections + "&";
				}else{
						var listSelections = groupListSelections.replace('{{hospitalId}}',criteria.findDocPrevId);
						url= url + "listSelections=" +  window.encodeURIComponent("["+listSelections+"]") +  "&";
						ProviderSearchCriteriaService.setHospitalNavigator(listSelections);
				}
		}
		else{
				var listSelections = groupListSelections.replace('{{hospitalId}}',provider.providerInformation.providerID);
				url= url + "listSelections=" +  window.encodeURIComponent("["+listSelections+"]") +  "&";
				ProviderSearchCriteriaService.setHospitalNavigator(listSelections);
		}

      				var criteria = ProviderSearchCriteriaService.getCriteria();
              var languageData = LanguageDataService.getLanguageData();
      				criteria.typeahead ={};
      				var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
      				if(suppressFutureProviders == 'true')
      					url = url + "&listFieldSelections=suppressFutureProv,suppressFutureGroup" +"&";
      				if(criteria.isGuidedSearch){
      					url = url + "isGuidedSearch=true&";
      				}
      				else{
      					url = url + "isGuidedSearch=false&";
      				}
      				if(criteria.direction!='')
      				{
      					url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
      					url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
      					url = url + "direction=" + criteria.direction + "&";
      					url = url + "total=" + criteria.total + "&";
      				}
      				else{
      					url = url + "firstRecordOnPage=1&";
      					url = url + "lastRecordOnPage=0&";
      					//url = url + "direction=''&";
      				}
      				if(criteria.planProductCode!=''){
      					url = url + "productIdentifier=~" + criteria.planProductCode + "&";
      				}
      				return url;
		};

		function appendListFieldSelectionsToUrl(suppressFutureProviders){
			var temp;
			
			if(window.location.href.indexOf("debug=true") != -1){
				temp = "listFieldSelections=debug,affiliations";
				if(suppressFutureProviders == 'true')
					temp = "listFieldSelections=debug,affiliations,suppressFutureProv,suppressFutureGroup";
				if( associatedProvidersSearchForGroup == true )
					temp = temp + ",associatedproviderssearchforgroup";
			}
			else{
				temp = "listFieldSelections=affiliations";
				if(suppressFutureProviders == 'true')
					temp = "listFieldSelections=affiliations,suppressFutureProv,suppressFutureGroup";
				if( associatedProvidersSearchForGroup == true )
					temp = temp + ",associatedproviderssearchforgroup";
			}
			return temp;
		}

		/** function to create the url parameters needed to call the search service **/
		function createURLforSearch(url)
		{
      			//Mandatroy parameters all ways to be passed.
      			var criteria = ProviderSearchCriteriaService.getCriteria();
            var languageData = LanguageDataService.getLanguageData();
      			// console.log(" createURLforSearch " + criteria.planProductCode
      			// 		+ "   " + JSON.stringify(criteria.planName)
      			// 		+ "   " + JSON.stringify(criteria));
            //
      			var anyLocationFlow = false;
      			if(criteria.searchText!=undefined && criteria.searchText != "")
      			{
      				var term = criteria.searchText.replace(/'/g,"");
      				
      				if( criteria.searchTextForBackEnd != undefined && criteria.searchTextForBackEnd != "" )
      				{ 
      					term =  criteria.searchTextForBackEnd.replace(/'/g,"");
      				}
      				if(term.contains('any location')){
      					anyLocationFlow = true;
      				}
      				url = url + "searchText="+ encodeRFC5987ValueChars(term) + "&";
      			}
      			criteria.anyLocationFlow = anyLocationFlow;
      			var suppressFutureProviders = languageData.SUPPRESS_FUTURE_PROVIDERS;
	            if(criteria.planProductCode!=''){
	                url = url + "productIdentifier=~" + criteria.planProductCode + "&";
	            }
            	url = url + appendListFieldSelectionsToUrl(suppressFutureProviders);

      			// indicate in listFieldSelections if it is a group search
            	if (criteria.typeahead && criteria.typeahead.subcategory === 'group') {
            		url = url + ',groupSearch&';
            	} else {
            		url = url + '&';
            	}

      			//Send the guided Search Parameter.
      			if(criteria.isGuidedSearch)
      			{
      				url = url + "isGuidedSearch=true&";
      				criteria.typeahead = null;  // don't use typeahead info for guided search
      			}
      			else{
      				url = url + "isGuidedSearch=false&";
      			}

      			// send the language selected by the user
      			/*var lang = $translate.use();
      			url = url + "responseLanguagePreference=" + lang + "&";*/

      			//Send specific parameters based on some booleans in critera.
      			if(criteria.isProviderForIPA)
      			{
      				url= url +  "associatedOrgID=" +criteria.ipaId + "&";
      			}
      			else{
        				if(criteria.isProviderForGroup)
        				{
        					var listSelections = groupListSelections.replace('{{groupId}}',criteria.groupId);
        					url= url + "listSelections=" + /* window.encodeURIComponent(listSelections) + */ "&";

        				}
	      				var providerInfo = criteria.typeahead;
	      				if(providerInfo != undefined && providerInfo.aetnaid!=null)
	      				{
	      					if (providerInfo.subcategory === 'ipa') {
	      						url = url + "associatedOrgID=" + providerInfo.aetnaid + "&";
	      					} else {
	      						url = url + "providerID=" + providerInfo.aetnaid + "&";
	      					}
	      				}
              }

	      				/* Business wants location to be considered even for Any location */
		      			//if(!anyLocationFlow)
		      			 // send geo details only when (any location) option is not selected from search typeahead
		      				// add any location information selected by the user
		      				var location = criteria.typeAheadLocationResults;
		      				if (location.stateabbr) {  // we always give state if we have it
		      					url = url + "state=" + location.stateabbr + "&";
		      				}
		      				if (location.subcategory == 'city' || location.subcategory == 'zipcode' || location.subcategory == 'coordinates') {
		      					// user selected distance is used for this type of location
		      					url = url + "distance=" + criteria.distance + "&";
		      					if (location.coordinates != null && criteria.distance > 0) { // we got lat/lon for the location
									var coordinates = location.coordinates; // sends the cordinates received from geo location entered on landing page/location popup
									// Below code sends the latlong from typeahead search talix, which we don't want to send.
		      						// var latLongFromSearchTypeAhead = getLatLongValue(criteria);
		      						// if(latLongFromSearchTypeAhead != undefined && latLongFromSearchTypeAhead != null){
		      						// 	coordinates = latLongFromSearchTypeAhead;
		      						// }
		      						// else{
		      						// 	coordinates = location.coordinates;
		      						// }
		      						var latLon = coordinates.split(",");
		      						if (latLon.length >= 2) { // we have a valid lat/lon
		      							url = url + "latitude=" + latLon[0] + "&";
		      							url = url + "longitude=" + latLon[1] + "&";
		      						}if (location.zipcode) { // we don't have a valid lat/lon
		      							url = url + "postalCode=" + location.zipcode + "&";
		      						} // if valid lat/lon
		      					} else if (location.zipcode) { // we didn't get coordinates
		      						url = url + "postalCode=" + location.zipcode + "&";
		      					} // if we have coordinates
		      				} else if (location.subcategory == 'county') {
		      					url = url + "county=" + (location.county).toUpperCase() + "&";
		      				}


      				if(criteria.direction!='')
      				{
      					url = url + "firstRecordOnPage=" + criteria.firstRecordOnPage + "&";
      					url = url + "lastRecordOnPage=" + criteria.lastRecordOnPage + "&";
      					url = url + "direction=" + criteria.direction + "&";
      					url = url + "total=" + criteria.total + "&";
      				}
      				else{
      					url = url + "firstRecordOnPage=1&";
      					url = url + "lastRecordOnPage=0&";
      				}
      				if(criteria.order!=null)
      				{
      					url=url+ "order=" + criteria.order + "&";
      				}
      				if(criteria.listSelections!=null && criteria.listSelections!='' && criteria.listSelections!="%5B%5D" && criteria.listSelections!="[]")
      				{
      					url=url+ "listSelections=" + criteria.listSelections + "&";
      				}
					var pipeName = ProviderSearchCriteriaService.getPlanPipeName();
					if(pipeName)
      				{
      					url=url+ "pipeName=" + pipeName + "&";
      				}

      			return url;
		};


		function getLatLongValue(criteria){
			if(criteria && !criteria.isGuidedSearch && criteria.typeahead != undefined && criteria.typeahead.coordinates != undefined){
				return criteria.typeahead.coordinates;
			}
			else{
				return null;
			}
		}

		function addMedicareSpecificParameters(apiUrl){
			var criteria = ProviderSearchCriteriaService.getCriteria();
			if(criteria.siteId!=undefined && criteria.siteId!=null && criteria.siteId =='medicare'){
				try{
					apiUrl = apiUrl + "year="+criteria.medicare.planYear;
					apiUrl = apiUrl + "&planType="+criteria.medicare.category;
					apiUrl = apiUrl + "&planCounty="+(criteria.medicare.county).toUpperCase();
					apiUrl = apiUrl + "&planState="+criteria.medicare.state;
				}
				catch( e)
				{

				}
			}
			return apiUrl;
		}
		function fetchResults (){
					// if($sessionStorage.filterSameResults != true){
					// 	setHospitalId('');
					// }
      				var results;
      				var deferred = $q.defer();
      				multipleLocations=getMultipleLocations();
      				findDoctors=getFindDoctors();
      				var criteria = ProviderSearchCriteriaService.getCriteria();
      				var ipaId=getIpaDetails();
      				var hospitalId=getHospitalId();
      				var updateURLForGroupIPA = true;
        			var apiUrl = configuration.providerSearch;
        			var clientId = configuration.providerSearchClientId;

        			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
        			{
        				apiUrl = configuration.externalProviderSearch;
            			clientId = configuration.providerSearchClientId;
        			}

					if( (criteria.fromDetailsStart == undefined || criteria.fromDetailsStart == false ) 
							|| ( criteria.fromDetailsStart == true && criteria.groupIPAaPI === "" ) )
					{
								criteria.fromDetailsStart = false;
			                    $sessionStorage.fromDetailsStart = false;
	                    
								if(multipleLocations==true){
									apiUrl=createURLforOfficeLocation(apiUrl);
									setMultipleLocations(false);
									setHideDistance(true);
									updateURLForGroupIPA = false;
								}
								else if(hospitalId!=""){
									apiUrl=createURLforHospitalAffiliations(apiUrl,hospitalId);
									// setHospitalId('');
									setHideDistance(true);
								}
								else if(groupId!="" && groupName!=""){
									apiUrl=createURLforGroupDetails(apiUrl,groupId,groupName,associatedProvidersSearchForGroup);
									// setGroupdetails('','');
									setHideDistance(true);
								}
								else if(ipaId!=""){
									apiUrl=createURLforIpaDetails(apiUrl,ipaId);
									// setIpaDetails('');
									setHideDistance(true);
								}
								else if(findDoctors!=""){
									apiUrl=createURLforFindDoctors(apiUrl);
									if(!criteria.isFindDoctor){
										setFindDoctors('');
									}
									setHideDistance(true);
								}
								else{
									apiUrl = createURLforSearch(apiUrl);
								}

								/* Do not update the URL if the search was for Other locations pleat */
								if( updateURLForGroupIPA == true )
								{
									criteria.groupIPAaPI = apiUrl;
									$sessionStorage.criteria.groupIPAaPI = apiUrl;
								}
          }else{
              criteria.fromDetailsStart = false;
              $sessionStorage.fromDetailsStart = false;
              apiUrl = criteria.groupIPAaPI;
          }

					apiUrl = 	addMedicareSpecificParameters(apiUrl);
					var siteId = criteria.siteId;
					var lang = criteria.language;

          // if(criteria.browserBack != true){
          //             criteria.browserBackAPI = criteria.browserCurrentAPI;
          //             criteria.browserCurrentAPI = apiUrl;
          // }
           /*if((criteria.isProviderForIPA != true && criteria.isProviderForGroup != true) && criteria.browserBack != true){
                      // var criteriaABC = $sessionStorage.abc;
                		  // var criteriaABC =	CommonUtilsService.getTempObject();
                      var stateObj = {'stateAPI': criteriaABC, 'groupIPAClicked': true};
                      history.pushState(stateObj, "Aetna", "/#/contentPage?page=providerResults&site_id=dse&language=en&navigate");
                      history.pushState(stateObj, "Aetna", "/#/contentPage?page=providerResults&site_id=dse&language=en&navigate");
          }*/
					/*Browser history */
				 /*if(criteria.browserBack != undefined && criteria.browserBack == true){
					      apiUrl = criteria.browserBackAPI;
                criteria.browserBack = false;
                criteria.browserBackAPI = '';
           }*/

					AnalyticsService.captureSearchDetails(apiUrl);

        			return $http({
        				method: 'GET',
        				url:apiUrl,
        				params: {siteId:siteId, responseLanguagePreference:lang},
        				headers : {
        					accept : 'application/json',
        					'X-IBM-Client-Id' : clientId
        				}
        			}) .then(
      					function success(response)
      					{

      						//alert ("Perfecto issue : Before :  Search results normal call : 3 " + response.status);
      						//alert ("Perfecto issue : Success :  Search results normal call " + reponse.status);

      						if (response.data && response.data) {
      							results = response.data;
      							deferred.resolve(results);
      						} else {
      							deferred.resolve('No Results found');
      						}
      						// promise is returned
      						printResponseDetails(response);
      						return deferred.promise;
      					},
      					function error(response)
      					{
      						//alert ("Perfecto issue : Before :  Search results normal call : 4 " + response.status);
      						/* Perfecto issue changes */
    						var perfectoSwitch = configuration.perfectoSwitch;

    						//alert ("Search results normal call " + response.status);
      						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
							{
								return fetchResultsExternalCall( );
							}
      						else{
      							printResponseDetails(response);
      							deferred.reject(response);
      							return deferred.promise;
      						}
      					});

	            };

	            /* Perfecto issue - External Call */
	            function fetchResultsExternalCall (){
      				var results;
      				var deferred = $q.defer();
      				multipleLocations=getMultipleLocations();
      				var criteria = ProviderSearchCriteriaService.getCriteria();
      				findDoctors=criteria.isFindDoctor;
      				var updateURLForGroupIPA = true;
      				var ipaId=getIpaDetails();
      				var hospitalId=getHospitalId();
        			var apiUrl = configuration.externalProviderSearch;
        			var clientId = configuration.providerSearchClientId;

    				if( (criteria.fromDetailsStart == undefined || criteria.fromDetailsStart == false ) 
							|| ( criteria.fromDetailsStart == true && criteria.groupIPAaPI === "" ) )
    				{
									criteria.fromDetailsStart = false;
				                    $sessionStorage.fromDetailsStart = false;
                        
                					if(multipleLocations==true){
                						apiUrl=createURLforOfficeLocation(apiUrl);
                						setMultipleLocations(false);
                						setHideDistance(true);
                						updateURLForGroupIPA = false;
                					}
                					else if(hospitalId!=""){
                						apiUrl=createURLforHospitalAffiliations(apiUrl,hospitalId);
                						// setHospitalId('');
                						setHideDistance(true);
                					}
                					else if(groupId!="" && groupName!=""){
                						apiUrl=createURLforGroupDetails( apiUrl, groupId, groupName, associatedProvidersSearchForGroup);
                						// setGroupdetails('','');
                						setHideDistance(true);
                					}
                					else if(ipaId!=""){
                						apiUrl=createURLforIpaDetails(apiUrl,ipaId);
                						// setIpaDetails('');
                						setHideDistance(true);
                					}
                					else if(findDoctors!=""){
                						apiUrl=createURLforFindDoctors(apiUrl);
										if(!criteria.isFindDoctor){
											setFindDoctors('');
										}
                						setHideDistance(true);
                					}
									else{
										apiUrl = createURLforSearch(apiUrl);
									}
                					/* Do not update the URL if the search was for Other locations pleat */
                					if( updateURLForGroupIPA == true )
                					{
                						criteria.groupIPAaPI = apiUrl;
                            			$sessionStorage.criteria.groupIPAaPI = apiUrl;
                					}
                }else{
                    criteria.fromDetailsStart = false;
                    $sessionStorage.fromDetailsStart = false;
                    apiUrl = criteria.groupIPAaPI;
                }
    				apiUrl = addMedicareSpecificParameters(apiUrl);
					//alert("apiUrl : " + apiUrl);
					var siteId = criteria.siteId;
					var lang = criteria.language;
					//alert ("Before Search results external call " + apiUrl  + "      " + clientId );

					AnalyticsService.captureSearchDetails(apiUrl);

        			return $http({
        				method: 'GET',
        				url:apiUrl,
        				params: {siteId:siteId, responseLanguagePreference:lang},
        				headers : {
        					accept : 'application/json',
        					'X-IBM-Client-Id' : clientId
        				}
        			}) .then(
        					function success(response)
        					{

        						$sessionStorage.isExternal = true;

        						if (response.data && response.data) {
        							results = response.data;
        							deferred.resolve(results);
        						} else {
        							deferred.resolve('No Results found');
        						}
        						// promise is returned
        						printResponseDetails(response);
        						return deferred.promise;
        					},
        					function error(response)
        					{
        						//alert ("After Search results external call : Error : " + response.status );

        						printResponseDetails(response);
        						deferred.reject(response);
        						return deferred.promise;
        					});

	            };

/**
 * Logs the response details.
 */
	var printResponseDetails = function(response)
	{
      		$log.debug("API :" + response.config.url);
      		$log.debug("Response Header :" + response.status + " " + response.statusText);
      		if(response.data!=null && response.data.error)
    			{
    				$log.error("Error: " + response.data.error +" - " + response.data.error_description);
    			}
	};

	var setProvider = function(data){
		provider = data;
		$sessionStorage.provider = provider;
		return provider;
	};

	var setCurrentPage = function(page){
		currentPage = page;
	};
	var setUpdatedDate = function(date){
		updatedDate= date;
	};
	var getUpdatedDate = function(){
		return updatedDate;
	};

	function setHideDistance(flag){
		hideDistance=flag;
	}

	function getHideDistance() {
		return hideDistance;
	}

	function setMultipleLocations(val){
		multipleLocations = val;
	};

	function getCurrentPage() {
		return currentPage;
	}

	function setHospitalId(id){
		hospitalId = id;
		if(id != ""){
			groupId =  '';
			groupName = '';
			associatedProvidersSearchForGroup = false;
			ipaId = '';
		}
	}
	function setIpaDetails(id){
		ipaId = id;

		if(id != ""){
			hospitalId = '';
			groupId =  '';
			groupName = '';
			associatedProvidersSearchForGroup = false;
		}
	};

	function getIpaDetails() {
		return ipaId;
	};

	function setGroupdetails(id,name,isAssociatedProvidersSearchForGroup){
		groupId = id;
		groupName=name;
		associatedProvidersSearchForGroup = isAssociatedProvidersSearchForGroup;

		if(id != ""){
			ipaId = '';
			hospitalId = '';
		}
	};

	function getGroupId() {
		return groupId;
	}
	function getGroupName() {
		return groupName;
	}
	
	function getAssociatedProvidersSearchForGroup()
	{
		return associatedProvidersSearchForGroup;
	}

	function setNewSearchClicked(val){
		newSearchClicked=val;
	};

	function getNewSearchClicked() {
		return newSearchClicked;
	}

	function setCancelFilter(val){
		cancelFilter=val;
	};

	function setFindDoctors(val){
		findDoctors=val;

		if(val != "" && val !=null){
			ipaId = '';
			hospitalId = '';
			groupId =  '';
			groupName = '';
			associatedProvidersSearchForGroup = false;
		}

	};

	function getFindDoctors() {
		return findDoctors;
	}

	function getCancelFilter() {
		return cancelFilter;
	}
	function setOkFilter(val){
		okFilter=val;
	};

	function getOkFilter() {
		return okFilter;
	}
	function setUpdatedDate(date){
		updatedDate=date;
	};

	function getUpdatedDate() {
		return updatedDate;
	}

	function setProviderType(type){
		providerType=type;
	}

	function getProviderType() {
		return providerType;
	}

	/**
	 * Fetch the provider detials.
	 */
	// var getProviderDetails = function (apiUrl){
 // var getProviderDetails = function (){
 // 	var deferred = $q.defer();
 //
 //    var apiUrl = configuration.
 // 	//var auth = DataCacheService.getToken();
 //
 // 	apiUrl = createURLforProviderDetails(apiUrl);
 // 	var url=$sessionStorage.apiHandlerUrl+"?navDestinationURL="+apiUrl;
 // 	return $http({
 // 		method: 'GET',
 // 		url: url,
 // 		headers: {Accept: 'application/json'}
 // 	}) .then(
 //
 // 			function success(response)
 // 			{
 // 				if (response.data && response.data) {
 //
 // 					results = response.data;
 // 					deferred.resolve(results);
 // 				} else {
 // 					deferred.resolve('No Provider Details found');
 // 				}
 //
 // 				return deferred.promise;
 // 			},
 // 			function error(response)
 // 			{
 // 				deferred.reject(response);
 // 				return deferred.promise;
 // 			});
 //
 //
 // }
 var getProviderDetails = function (){

	 		/*alert( "Details call internal start  : " +
				"\n isExternal : $sessionStorage.isExternal : " + $sessionStorage.isExternal);*/

			var deferred = $q.defer();
			var clientId = configuration.providerDetailsClientId;

			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				apiUrl = createExternalURLforProviderDetails();
			}
			else
			{
				apiUrl = createURLforProviderDetails();
			}

			apiUrl = addMedicareSpecificParameters(apiUrl);
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;					

			provider = getProvider();
			var pType = provider.providerInformation.type;
			if(pType === "Individual")
				clientId = configuration.providerDetailsClientId;
			else if(pType === "Hospital")
				clientId = configuration.providerDetailsClientId;
			else if(pType === "Organization")
				clientId = configuration.providerDetailsClientId;

			return $http({
				method: 'GET',
				url: apiUrl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(

					function success(response)
					{
						if (response.data && response.data) {

							results = response.data;
							deferred.resolve(results);
						} else {
							deferred.resolve('No Provider Details found');
						}

						return deferred.promise;
					},
					function error(response)
					{
						/* Perfecto issue changes */
						var perfectoSwitch = configuration.perfectoSwitch;

						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
						{
							return fetchDetailsExternalCall( );
						}
						else
						{
							deferred.reject(response);
							return deferred.promise;
						}
					});
		};

		/* Perfecto issue - External call */
		function fetchDetailsExternalCall(){
			var deferred = $q.defer();
			var clientId = configuration.providerDetailsClientId;
			apiUrl = createExternalURLforProviderDetails();
			var criteria = ProviderSearchCriteriaService.getCriteria();
			var siteId = criteria.siteId;
			var lang = criteria.language;

			provider = getProvider();
			var pType = provider.providerInformation.type;
			if(pType === "Individual")
				clientId = configuration.providerDetailsClientId;
			else if(pType === "Hospital")
				clientId = configuration.providerDetailsClientId;
			else if(pType === "Organization")
				clientId = configuration.providerDetailsClientId;

			apiUrl = 	addMedicareSpecificParameters(apiUrl);

			return $http({
				method: 'GET',
				url: apiUrl,
				params: {siteId:siteId, responseLanguagePreference:lang},
				headers : {
					accept : 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(

					function success(response)
					{

						$sessionStorage.isExternal = true;

						/*alert( "Details calls external  : " +
								"\n isExternal : $sessionStorage.isExternal : " + $sessionStorage.isExternal);*/

						if (response.data && response.data) {

							results = response.data;
							deferred.resolve(results);
						} else {
							deferred.resolve('No Provider Details found');
						}

						return deferred.promise;
					},
					function error(response)
					{
						deferred.reject(response);
						return deferred.promise;
					});
		};

	/***Function to display flag***/

	var openURL = function(URL)
	{
		if(URL!=null && URL!=undefined && URL.indexOf("COMServlet")!= -1)
			{
				URL = URL; //+ "&callback=JSON_CALLBACK";
				$.ajax({
				    type: 'GET',
				    url: URL,
				    crossDomain: true,
				    dataType: 'xml',
				    success: function(responseData, textStatus, jqXHR) {

				        //var value = responseData.someKey;
				        var value = $(responseData).find("link")[0].innerHTML;
				        if(value!=null && value != undefined)
				        	{
				        		$window.open(value,"","");
				        	}

				    },
				    error: function (responseData, textStatus, errorThrown) {
				        $log.error('Unable to make a connection to fetch the resource');
				    }
				});

			}
		else if(URL!=null && URL!=undefined && URL!=""){
			window.open(URL, '_blank');
			// $window.open(URL,"","");
		}

	}

	var showDisclaimer = function(url, type, label){
var criteria = ProviderSearchCriteriaService.getCriteria();
var lang = criteria.language;
    	var goTo = type + "Disclaimer";
		var disclaimerUrl = $state.href('disclaimerPage', {page: goTo,language:lang, storeURL: url});
		var resultUrl = disclaimerUrl.split("~2F").join("/");
		window.open(resultUrl, '_blank');
	}

	var identifyMedicareMember = ProviderSearchCriteriaService.identifyMedicareMember();

	function encodeRFC5987ValueChars (str) {
		str =  str.replace("&","&amp;");
	    return encodeURIComponent(str).
	        // Note that although RFC3986 reserves "!", RFC5987 does not,
	        // so we do not need to escape it
	        replace(/['()]/g, escape). // i.e., %27 %28 %29
	        replace(/\*/g, '%2A').
	            // The following are not required for percent-encoding per RFC5987,
	            //  so we can allow for a little better readability over the wire: |`^
	            replace(/%(?:7C|60|5E)/g, unescape);
	}

	function compareInit() {
		compareData.items = [];  // holds providers to compare in the order they were added
		compareData.lookup = {};  // holds providers to compare by key for fast lookup
	}


	//get old filters
	function concateOldFilters(uri1, uri2){

		var str1 = uri2.slice(3,uri2.length-3);

		var res = str1.concat("%2C");
		res = res.concat(uri1);

		return res;

		// var n = uri1.lastIndexOf("%22");
		// var str3 = uri1.slice(0, n);

		// var n2 = uri2.lastIndexOf("%3A%22");
		// var str4 = uri2.slice(n2+6, uri2.length);
	}

	// get a unique key for a provider
	function getProviderKey(provider) {

		/*var providerLoc;*/

		/* Provider locations to Array after APIC mapping removal*/
		/*if( provider )
		{
			providerLoc = $filter('toArray')(provider.providerLocations);
		}*/

		// handle bad provider parameter
		if (!provider || !provider.providerInformation || !provider.providerInformation.providerID
			|| !provider.providerLocations
			|| !provider.providerLocations.locationID) {
			return null;  // bad data - no key
		}

		var key = provider.providerInformation.providerID
			+ '.'
			+ provider.providerLocations.locationID;
		return key;
	}
	
	//Getting access token for Report Incorrect Info API 
	function getTokenForReportIncorrect() {
		
		var clientId = configuration.tokenAPIClientID;
		var secretId = configuration.tokenAPISecretKey;
		var scope = configuration.tokenAPIScope;
		var grantType = configuration.tokenAPIGrantType;
		
		var apiUrl;
		
		if($sessionStorage.isExternal && $sessionStorage.isExternal == true) {
			apiUrl = configuration.externalTokenAPIURL;
		} else {
			apiUrl = configuration.internalTokenAPIURL;			
		}		
		
		return $http({
			method: 'POST',
			url: apiUrl,
			headers : {
				'Content-Type' : 'application/x-www-form-urlencoded'
			},
			data: 'scope='+scope+'&grant_type='+grantType+'&client_secret='+secretId+'&client_id='+clientId
		})
	}

  //Report Incorrect Info
    function submitData(apiUrl, data, provider, checkedData,isDescription, publicMember){
        var criteria = ProviderSearchCriteriaService.getCriteria();
        var member = '';    //Storing Current member info
        var PName = '';     //Storing Current Provider Name
        var checkedOptions = '';
        var menberEmail = publicMember.email ? publicMember.email : 'somethingtobedecided@Aetna.com';
        // for(var i=0;i<criteria.members.length;i++){
        // 	if(criteria.members[i].person.patientSequenceNumber === criteria.selectedMemberIndex){
        // 		member = criteria.members[i];
        // 	}
        // }
        member = publicMember;

        if ((window.location.href.indexOf("page=providerResults") > -1) && data){
          PName = encodeURIComponent(data.providerInformation.providerDisplayName.full);
          PNumber = data.contacts.primaryPhone.number; //data.contacts[0].primaryPhone.number;
          PStreet = encodeURIComponent(data.providerLocations.address.streetLine1);
          PCity = encodeURIComponent(data.providerLocations.address.city);
          PZip = data.providerLocations.address.postalCode;
          PState = data.providerLocations.address.state;
          PPin = data.providerInformation.providerIdentifier.idValue;
          PServiceId = data.providerLocations.locationIdentifier.idValue;
        }else{
            if((window.location.href.indexOf("page=providerHospDetails") > -1)  && data){
                PName = encodeURIComponent(data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerDisplayName.full);
                PNumber = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.contacts[0].primaryPhone.number;
                PStreet =encodeURIComponent( data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.streetLine1);
                PCity = encodeURIComponent(data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.city);
                PZip = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.postalCode;
                PState = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].address.state;
                PPin = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerID;
                PServiceId = data.providerDetailsResponse.hospitalProviderDetails.hospitalProvider.providerLocations[0].locationID;
            } else if((window.location.href.indexOf("page=providerDetails") > -1) && data){
                PName = encodeURIComponent(data.providerDetailsResponse.individualProviderDetails.practitioner.nameFull);
                PNumber = data.providerDetailsResponse.individualProviderDetails.contacts[0].primaryPhone.number;
                PStreet = encodeURIComponent(data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.streetLine1);
                PCity = encodeURIComponent(data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.city);
                PZip = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.postalCode;
                PState = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].address.state;
                PPin = data.providerDetailsResponse.individualProviderDetails.providerID;
                PServiceId = data.providerDetailsResponse.individualProviderDetails.providerLocations[0].locationID;
            } else if((window.location.href.indexOf("page=providerOrgDetails") > -1)  && data){
                PName = encodeURIComponent(data.providerDetailsResponse.organizationalProviderDetails.providerDisplayName.full);
                PNumber = data.providerDetailsResponse.organizationalProviderDetails.contacts[0].primaryPhone.number;
                PStreet = encodeURIComponent(data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.streetLine1);
                PCity = encodeURIComponent(data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.city);
                PZip = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.postalCode;
                PState = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].address.state;
                PPin = data.providerDetailsResponse.organizationalProviderDetails.providerID;
                PServiceId = data.providerDetailsResponse.organizationalProviderDetails.providerLocations[0].locationID;
            }else{}
        }

        if(checkedData){
          var incCount = 0;
          for(var i=0;i<checkedData.length;i++){
            checkedOptions = checkedOptions + ' ' + (++incCount) + '. ' + checkedData[i];
          }
        }

      var deferred = $q.defer();
      apiUrl = apiUrl + "?automate=Y&";
      apiUrl = apiUrl + "LName="+ member.lastName +"&";  //Member First Name
      apiUrl = apiUrl + "FName="+ member.firstName +"&";   //Member Last Name
      apiUrl = apiUrl + "from=" + member.email + "&";
      apiUrl = apiUrl + "PName=" + PName + "&";                  //Provider Full Name
      apiUrl = apiUrl + "ProviderType="+ provider +"&";
      apiUrl = apiUrl + "PhoneNum="+ PNumber +"&";    //Provider Phone Number
      apiUrl = apiUrl + "Street1=" + PStreet + "&";   //Provider Street
      apiUrl = apiUrl + "City="+ PCity +"&";
      apiUrl = apiUrl + "Zip="+ PZip +"&";
      apiUrl = apiUrl + "State=" + PState + "&";

      checkedOptions = checkedOptions.replace("/", " or ");
      apiUrl = apiUrl + "Steps=PIN : " + PPin + " ServiceLocation Id :" + PServiceId + " Updated Information :" + checkedOptions;

      //var url=$sessionStorage.apiHandlerUrl+"?navDestinationURL="+apiUrl;

      return apiUrl;
  }

	return {
		provider: provider,
		getProvider: getProvider,
		getCurrentPage:getCurrentPage,
		getResults: getResults,
		resultSearch:resultSearch,
		results_scopeID:results_scopeID,
		// getCost:getCost,
		setProvider:setProvider,
		setCurrentPage:setCurrentPage,
		getProviderDetails:getProviderDetails,
		setMultipleLocations:setMultipleLocations,
		getMultipleLocations:getMultipleLocations,
		multipleLocations:multipleLocations,
		openURL:openURL,
		hospitalId:hospitalId,
		setHospitalId:setHospitalId,
		getHospitalId:getHospitalId,
		setIpaDetails:setIpaDetails,
		getIpaDetails:getIpaDetails,
		setGroupdetails:setGroupdetails,
		getGroupId:getGroupId,
		getGroupName:getGroupName,
		getAssociatedProvidersSearchForGroup:getAssociatedProvidersSearchForGroup,
		scrollTo:scrollTo,
		getTokenForReportIncorrect:getTokenForReportIncorrect,
		submitData:submitData,
		setNewSearchClicked:setNewSearchClicked,
		getNewSearchClicked:getNewSearchClicked,
		setCancelFilter:setCancelFilter,
		getCancelFilter:getCancelFilter,
		identifyMedicareMember:identifyMedicareMember,
		setOkFilter:setOkFilter,
		getOkFilter:getOkFilter,
		setUpdatedDate:setUpdatedDate,
		getUpdatedDate:getUpdatedDate,
		setHideDistance:setHideDistance,
		getHideDistance:getHideDistance,
		setFindDoctors:setFindDoctors,
		getFindDoctors:getFindDoctors,
		showDisclaimer : showDisclaimer,
		compareData:compareData,
		compareInit:compareInit,
		getProviderKey:getProviderKey,
		setProviderType:setProviderType,
		getProviderType:getProviderType,
		concateOldFilters:concateOldFilters,
		getAllVariables:getAllVariables,
		setAllVariables:setAllVariables
	};

}

})();

},{}],62:[function(require,module,exports){
(function() {

	angular.module('nav-ui').service('ReviewsService', ReviewsService);

	ReviewsService.$inject = ['configuration','$http','$q','$log','$translate','$sessionStorage'];

	function ReviewsService(configuration,$http,$q,$log,$translate,$sessionStorage) {
		// service initialization

		var rating;  // holds rating information for single provider
		var reviews;  // holds all review information for single provider

		initialize();

		// clear everything in preparation to get another set of ratings
		function initialize() {
			rating = null;  // prepare for new ratings
			reviews = null;  // prepare for new reviews
		}

		// set the classes that produce the stars for ratings
		// 10 levels of stars from empty to full
		// names: an array of 10 strings containing class names
		function setStarClassNames(names) {
			stars = names;
		}

		// given a rating number and a star number, return the class needed to produce that star
		// rating: string with values '0' or '1.0' to '5.0'
		// star: 1 to 5
		function calculateStarClass(rating,star) {
			// get data in the form x.y
			rating += '';  // turn into a string
			if (rating.length == 1) {
				rating += ".0";
			} else if (rating.length < 3) {
				rating = '0.0';  // bad data
			} else if (rating.length > 3) {
				rating = rating.substr(0,3);
			}
			if (rating < '0.0' || rating > '5.0' || rating.length != 3) {
				rating = '0.0';  // bad data
			}

			// get the whole and decimal parts of the rating
			var whole = parseInt(rating.substr(0,1));
			var part = parseInt(rating.substr(2,3));

			if (star <= whole) {
				// full stars up to the rating number
				star = stars[9];
			} else if (star > whole+1) {
				// empty stars after the rating number and partial rating
				star = stars[0];
			} else {
				// doing partial rating star (decimal value 0 to 9
				star = stars[part];
			}
			return star;
		}

		// review status for an id.  The valid values are
		// - notFound: id was never added to be rated or service found no info on id
		// - added: id was added but not processed by web service
		// - found: id has info from the rating web service
		function reviewStatus() {
			if (!rating ) {
				return 'notFound';  // bad data means not rated
			} else {
				return rating.status;
			}
		}

		// get the rating
		function getRating() {
			if (!rating) {
				return 0;  // bad data means not rated
			} else {
				return rating.rating;
			}
		}

		// get the value for a particular star for the average rating
		function getAverageStarClass(star) {
			return calculateStarClass(getRating(), star);
		}

		// get the value for a particular star for a specific review
		function getSpecificStarClass(index,star) {
			return calculateStarClass(getReviewRating(index), star);
		}

		// get the number of ratings for the provider
		function getNumberOfRatings() {
			if (!rating) {
				return 0;  // bad data means not rated
			} else {
				return rating.numRatings;
			}
		}

		// get the url to add a review for this provider
		function getAddReviewURL() {
			if (!rating) {
				return null;  // bad data means not rated
			} else {
				return rating.addReviewURL;
			}
		}

		// get the url to read the reviews for this provider
		function getReadReviewsURL() {
			if (!rating) {
				return null;  // bad data means not rated
			} else {
				return rating.readReviewsURL;
			}
		}

		// get the number of reviews available to display
		function getNumberOfAvailableReviews() {
			if (!reviews || !reviews[0] ) {
				return -1;  // bad data means no reviews
			} else {
				return reviews.length;
			}
		}

		// get the total number of reviews
		function getNumberOfReviews() {
			if (!rating) {
				return 0;  // bad data means not rated
			} else {
				return rating.numReviews; // asdf
			}
		}

		// get the date of a review
		function getReviewDate(index) {
			if (!reviews || index >= reviews.length) {
				return ;  // bad data
			} else if (typeof reviews[index].postedDate == 'string') {
				return reviews[index].postedDate;
			} else {
				return null;
			}
		}

		// get the rating of a review
		function getReviewRating(index) {
			if (!reviews || index >= reviews.length) {
				return 0;  // bad data
			} else {
				return reviews[index].rating;
			}
		}

		// get the text of a review
		function getReviewText(index) {
			if (!reviews || index >= reviews.length) {
				return null;  // bad data
			} else if (typeof reviews[index].reviewText == 'string') {
				return reviews[index].reviewText;
			} else {
				return null;  // empty review
			}
		}

		// get the site name of a review
		function getReviewSiteName(index) {
			if (!reviews || index >= reviews.length) {
				return '';  // bad data
			} else {
				return reviews[index].siteName;
			}
		}

		// get the site URL of a review
		function getReviewSiteURL(index) {
			if (!reviews || index >= reviews.length) {
				return '';  // bad data
			} else {
				return reviews[index].siteURL;
			}
		}

		// return the array of review data
		function getReviewData() {
			if (!reviews) {
				return null;  // bad data
			} else {
				return reviews;
			}
		}

		// process the ratings data from the reviews service.  Populate the global structure
		function processRatingsData(data) {
			var status = 'notFound';  // assume the worst
			var numRatings = 0;  // default
			var numReviews = 0;  // default
			var average = 0;  // default
			var addReviewURL = null;  // default
			var readReviewsURL = null;  // default
			if (data.ratingSummary) {
				status = 'found';
				numRatings = data.ratingSummary.numberOfRatings;
				numReviews = data.ratingSummary.numberOfReviews;
				average = data.ratingSummary.averageRating;
				addReviewURL = data.addReviewURL;
				readReviewsURL = data.readReviewsURL;
			}
			rating = {};  // found ratings
			rating.status = status;
			rating.numRatings = numRatings;
			rating.numReviews = numReviews;
			rating.rating = average;
			rating.addReviewURL = addReviewURL;
			rating.readReviewsURL = readReviewsURL;
		}

		// process the array of review data from the reviews service.  Populate the global structure
		function processReviewsData(data) {
			// always store as array, even if only one object
			if (!Array.isArray(data)) {
				// turn data into an array
				data = [data];
			}

			reviews = data; // store review data in global variable
		}

		// create the URL for the review service
		function buildReviewsServiceURL(id , APIurl ) {
			// pad the ID with zeros so it is length 10
			id = '0000000000' + id;
			id = id.substr(id.length - 10);
			id = '94~'+id;

			//Below is the number of revies expected in detail
			var maxNumberOfReviewsExpected = 3;

			var url = APIurl;

			// the ID needs to be put in the middle of the URL.  The config has {id}
			// where the ID should go
			url = url.replace('{id}',id);
			url = url.replace('{maxNoOfReviewsExpected}',maxNumberOfReviewsExpected);

			return url;
		}

		// call the reviews service for the specified ID
		function getReviews(id) {			

			var apiUrl;
			var clientId;
			
			if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
			{
				apiUrl = configuration.externalProviderReviewsServiceURL;
				clientId = configuration.externalProviderReviewsServiceURLClientId;
			}
			else
			{
				apiUrl = configuration.providerReviewsServiceURL;
				clientId = configuration.providerReviewsServiceURLClientId;
			}
			
			apiUrl = buildReviewsServiceURL( id , apiUrl);
			
			var results;

			var deferred = $q.defer();
			return $http({
				method: 'GET',
				url: apiUrl,
				headers: {
					Accept: 'application/json',
					'X-IBM-Client-Id' : clientId
				}
			}) .then(

				function success(response) {
					
					/*alert(JSON.stringify(response));*/
					
					if (response.data && // something back from the service
							response.data.providerReviewsResponse && // something valid from service
							response.data.providerReviewsResponse.status && // valid status from service
							response.data.providerReviewsResponse.status.statusCode == 0 && // good status
							response.data.providerReviewsResponse.readProviderReviewsResponse && // data returned
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews &&
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI &&
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI.rating &&
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI.rating.responseCode &&
							response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI.rating.responseCode === '000') {
						
								results = response.data;
								deferred.resolve(results);
								processRatingsData(response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI.rating); // single object
								processReviewsData(response.data.providerReviewsResponse.readProviderReviewsResponse.providerReviews.PrimaryNPI.rating.ratingDetail); // array of objects
					} else {
							deferred.resolve('No Results found');
					}

					// promise is returned
					return deferred.promise;
				},
				function error(response) {
					deferred.reject(response);
					return deferred.promise;
				});

		};

		return {
			initialize: initialize,
			setStarClassNames: setStarClassNames,
			getReviews: getReviews,
			reviewStatus: reviewStatus,
			getRating: getRating,
			getAverageStarClass: getAverageStarClass,
			getSpecificStarClass: getSpecificStarClass,
			getNumberOfRatings: getNumberOfRatings,
			getNumberOfAvailableReviews: getNumberOfAvailableReviews,
			getNumberOfReviews: getNumberOfReviews,
			getReviewDate: getReviewDate,
			getReviewRating: getReviewRating,
			getReviewText: getReviewText,
			getReviewSiteName: getReviewSiteName,
			getReviewSiteURL: getReviewSiteURL,
			getReadReviewsURL: getReadReviewsURL,
			getAddReviewURL: getAddReviewURL,
			getReviewData: getReviewData
		};
	}

})();

},{}],63:[function(require,module,exports){
(function() {

	angular
	.module('nav-ui')
	.service('ProviderSearchCriteriaService', ProviderSearchCriteriaService);

	ProviderSearchCriteriaService.$inject = ['configuration','$http','$q','$sessionStorage','$log','$rootScope','$translate','$window','$state'];

	function ProviderSearchCriteriaService(configuration,$http,$q,$sessionStorage,$log,$rootScope,$translate,$window,$state) {

		var criteria = {
			language:'',
			siteId:'',
			searchText: '',
			searchTextForBackEnd: '',
			anyLocationFlow: false,
			typeAheadSwitch: true,  // if we do type ahead
			minLength: 3,  // how many chars before type-ahead starts
			page: 1,
			perPage:25,
			selectedMemberFName: '',
			selectedMemberLName: '',
			selectedMemberId:'',
			distance: 25,
			typeAheadSearch: '',  // value in the search box
			typeAheadLocation: '',  // value in the location box
			typeAheadLocationClicked: null,  // what was clicked on for location search
			typeAheadLocationResults: {},  // what was chosen for location search
			typeAheadStatus: 'unknown',  // up, down, unknown
			typeAheadStatusText: 'unknown',  // up, down, unknown
			isGuidedSearch: false, //please et this be false by default. DO not change.
			isSinglePlan: false,
			currentView: 'Current',
			selectedMemberIndex : '0001',
			selectedMember:null, //this will stored the selected Member. Once this works we can remove slelectedMemberFName and sleectedMemberIndex
			members:{},
			text:{}, // text generated by JavaScript that can be translated
			order:'',
			isProviderForGroup:false,
			isProviderForIPA:false,
			isProviderForHospital:false,
			isFindDoctor: false,
			ipaId:'',
			ipaName:'',
			groupId: '',
			groupName:'',
			hospitalName:'',
			listSelections:'',
			maskZip:false,
			firstRecordOnPage:'',
			lastRecordOnPage:'',
			direction: '',
			total: '',
			isMedicare:false,
			compareListArray:[],
			isResetFilter: false,
			planProductCode: '',
			planName: '',
			planPipeName: '',
			dummyPlanCode: '',
			searchTextToDisplay: '',
			checkedItem:[],
			checkedItemChildren:[],
			filterOrder:"",
			provType:'',
			showPlanPleat:false,
			hospitalId:'',
			planValFromURL:'',
			pleatProId: '',
			pleatLocId: '',
			planValue:'',
			switchToShowAllPlanLink: false,
			statusBeg: true,
			statusLast: false,
			isAlphaSort: false,
			alphaSet:{},
			memberPleat: false,
			geoPleat: false,
			perResidencePleat: false,
			hospitalNavigator: null,
			fromGeo: false,
			groupIPAClicked: false,
			fromDetailsStart: false,
			groupIPAaPI: '',
			browserCurrentAPI: '',
			browserBack: false,
			browserBackAPI: '',
			medicare:{
				memberPleat: false,
			    geoPleat: false,
			    perResidencePleat: false,
				planTypeaHeadLocation:'',
				planYear:'',
				category:'',
				medicareLandingUrl:'',
				county : 'Hartford',
				state: 'CT',
				medOrDen: -1,
				fixedPlanName: "",
				isDebug: false,
				isLangCode:'en',
				areTypeAheadResultsReturned: true
			},
			returnUrl: '' // This may be used by DRX in medicare flow or other JV's. Hence keeping it seperate from medicare.
			/*isAssociatedProvidersSearchForGroup: false *//* used to indicate that the search is for assocaited providers by clicking on 
			 'Find Doctors associated to group' link. */
		};


		var planCriteria = {
			planArray:[],			
			planDebugInfo:[]
		};

		var init = function (){
			// initialization code
			initTypeAheadData();
			updateTranslatableText();  // called for initial language
		};

		// handle text used by JavaScript that must be translated into different languages

		function updateTranslatableText() {
			// get any translatable text that is built by JavaScript
			$translate('TA.CURRENT_LOCATION2').then(function (text) {
				criteria.text.currentLocation = text;
			}, function (translationId) {
				criteria.text.currentLocation = translationId;
			});
			$translate('W.MILES').then(function (text) {
				criteria.text.miles = text;
			}, function (translationId) {
				criteria.text.miles = translationId;
			});
		}

		$rootScope.$on('$translateChangeSuccess', function () {
			updateTranslatableText();  // called whenever language is changed
		});

		var getCriteria = function(){
			//var tempCriteria = sessionStorage.getItem('navcriteria');
			var tempCriteria = $sessionStorage.criteria;

			//console.log("$sessionStorage.criteria" + JSON.stringify($sessionStorage.criteria));

			if(tempCriteria!=null && tempCriteria!=undefined)
			{
				//criteria = JSON.parse(tempCriteria);
				criteria = tempCriteria;
			}
			else{
				if(sessionStorage.getItem("navcriteria")!= null)
				{
					tempCriteria = sessionStorage.getItem("navcriteria");
					try{
						
						tempCriteria = JSON.parse(tempCriteria);
						criteria = tempCriteria;
						$sessionStorage.criteria = criteria;
					}
					catch(e)
					{
						criteria = tempCriteria;
						$sessionStorage.criteria = criteria;
					}
				}
			}
			return criteria;

		};

		var getPlanCriteria = function(){
			//var tempCriteria = sessionStorage.getItem('navcriteria');
			var tempCriteria = $sessionStorage.planCriteria;

			//console.log("$sessionStorage.criteria" + JSON.stringify($sessionStorage.criteria));

			if(tempCriteria!=null && tempCriteria!=undefined)
			{
				//criteria = JSON.parse(tempCriteria);
				planCriteria = tempCriteria;
			}
			else{
				if(sessionStorage.getItem("navplanCriteria")!= null)
				{
					tempCriteria = sessionStorage.getItem("navplanCriteria");
					try{
						
						tempCriteria = JSON.parse(tempCriteria);
						planCriteria = tempCriteria;
						$sessionStorage.planCriteria = planCriteria;
					}
					catch(e)
					{
						planCriteria = tempCriteria;
						$sessionStorage.planCriteria = planCriteria;
					}
				}
			}
			return planCriteria;

		};

		/* Uncommenting and using this method to update sessionStorage */
		var setCriteria = function(){
		 		$sessionStorage.criteria = criteria;
		};
		var setPlanCriteria = function(){
				$sessionStorage.planCriteria = planCriteria;
		};


		//This function is to reset criteria when we return to landing page
		var resetCriteria = function(){
			criteria.searchText= '';
			criteria.searchTextForBackEnd='';
			criteria.anyLocationFlow= false;
			criteria.typeAheadSwitch= true;
			criteria.minLength= 3;
			criteria.page= 1;
			criteria.perPage=25;
			criteria.selectedMemberFName= '';
			criteria.selectedMemberLName= '';
			criteria.selectedMemberId='';
			criteria.distance= 25;
			criteria.typeAheadSearch= '';
			criteria.typeAheadLocation= '';
			criteria.typeAheadLocationClicked= null;
			criteria.typeAheadLocationResults= {};
			criteria.typeAheadStatus= 'unknown';
			criteria.typeAheadStatusText= 'unknown';
			criteria.isGuidedSearch= false;
			criteria.isSinglePlan= false;
			criteria.currentView= 'Current';
			criteria.selectedMemberIndex = '0001';
			criteria.selectedMember=null;
			criteria.members={};
			criteria.text={},
			criteria.order='',
			criteria.isProviderForGroup=false;
			criteria.isProviderForIPA=false;
			criteria.isProviderForHospital=false;
			criteria.isFindDoctor= false;
			criteria.ipaId='';
			criteria.ipaName='';
			criteria.groupId= '';
			criteria.groupName='';
			criteria.hospitalName='';
			criteria.listSelections='';
			criteria.maskZip=false;
			criteria.firstRecordOnPage='';
			criteria.lastRecordOnPage='';
			criteria.direction= '';
			criteria.total= '';
			criteria.isMedicare=false;
			criteria.compareListArray=[];
			criteria.isResetFilter= false;
			criteria.planProductCode= '';
			criteria.planName= '';
			criteria.planPipeName= '';
			criteria.dummyPlanCode= '';
			criteria.searchTextToDisplay= '';
			criteria.checkedItem=[];
			criteria.checkedItemChildren=[];
			criteria.filterOrder='';
			criteria.provType='';
			criteria.showPlanPleat=false;
			criteria.hospitalId='';
			criteria.planValFromURL='';
			criteria.pleatProId= '';
			criteria.pleatLocId= '';
			criteria.planValue='';
			criteria.switchToShowAllPlanLink= false;
			criteria.statusBeg= true;
			criteria.statusLast= false;
			criteria.isAlphaSort= false;
			criteria.alphaSet={};
			criteria.memberPleat= false;
			criteria.geoPleat= false;
			criteria.hospitalNavigator= null;
			criteria.typeahead= {};
			criteria.typeaheadLocation= '';
			criteria.fromGeo= false;
			planCriteria.planArray=[];
			planCriteria.planDebugInfo=[];
			criteria.medicare = {};
			setCriteria();
			setPlanCriteria();
			/*isAssociatedProvidersSearchForGroup: false;*/

		};

		/*function getIsAssociatedProvidersSearchForGroup()
		{
			return criteria.isAssociatedProvidersSearchForGroup;
		}*/
		
		/*var setIsAssociatedProvidersSearchForGroup = function(isAssociatedProvidersSearchForGroup)
		{
			criteria.isAssociatedProvidersSearchForGroup = isAssociatedProvidersSearchForGroup;
			if($sessionStorage.criteria != undefined){
					$sessionStorage.criteria.isAssociatedProvidersSearchForGroup 
						= isAssociatedProvidersSearchForGroup;
			}
		}*/
		
		function getGroupId() {
			return criteria.groupId;
		};
		function getGroupName() {
			return criteria.groupName;
		};
		var getListSelection = function(){
			return criteria.listSelections;
		};
		var getisDidYouMean = function(){
			return criteria.isDidYouMean;
		};
		var setListSelection = function(listSelections){
			criteria.listSelections = listSelections;
			if($sessionStorage.criteria != undefined){
					$sessionStorage.criteria.listSelections = listSelections;
			}
			/*console.log("$sessionStorage.criteria" + JSON.stringify($sessionStorage.criteria.listSelections));
			console.log("criteria" + JSON.stringify(criteria.listSelections));*/
		};
		var getOrder = function(){
			return criteria.order;
		};
		var setOrder = function(order){
			criteria.order = order;
		};
		var getDistance = function(){
			return criteria.distance;
		};
		var setDistance = function(dist){
			criteria.distance = dist;
		};

		var setHospitalNavigator = function( hospitalNavigator ){
			criteria.hospitalNavigator = hospitalNavigator;
		};
		var getHospitalNavigator = function(){
			return criteria.hospitalNavigator;
		};

		function setPlanProductCode(val) {
			criteria.planProductCode=val;

			console.log("val" + val + " criteria.planProductCode " + criteria.planProductCode);
		}

		function getPlanProductCode() {
			return criteria.planProductCode;
		}

		function setPlanPipeName(val) {
			criteria.planPipeName=val;
		}

		function getPlanPipeName() {
			return criteria.planPipeName;
		}

		function setPlanPleatShow(data){
			criteria.showPlanPleat = data;
		};

		function getPlanPleatShow(data){
			return criteria.showPlanPleat;
		};

		function setPlanName(val) {
			criteria.planName=val;

			console.log("val" + val + " criteria.planName " + criteria.planName);
		}

		function getPlanName() {
			return criteria.planName;
		}

		var setSearchText = function(text){
			criteria.searchText = text;
		};

		var setSearchTextForBackEnd = function(text){
			criteria.searchTextForBackEnd = text;
		};
		
		var setSelectedMemberFName = function(name){
			criteria.selectedMemberFName = name;
		};

		var setSelectedMemberLName=function(Lname){
			criteria.selectedMemberLName = Lname;
		};
		var setSelectedMemberId=function(Id){
			criteria.selectedMemberId = Id;
		};

		var setAlphabetOrder = function(alphabetObj){
			criteria.alphaSet = alphabetObj;
		};
		var getAlphabetOrder = function(){
			return criteria.alphaSet;
		};
		var setPage = function(num){
			criteria.page = num;
		};

		function getSearchText() {
			return criteria.searchText;
		}

		function getSearchTextForBackEnd() {
			return criteria.searchTextForBackEnd;
		}
		
		function getSelectedMemberFName() {
			return criteria.selectedMemberFName;
		}

		function getSelectedMemberLName(){
			return criteria.selectedMemberLName;
		}
		function getSelectedMemberId(){
			return criteria.selectedMemberId;
		}

		var getPage = function(){
			return criteria.page;
		};

		function setFirstRecordOnPage(val) {
			criteria.firstRecordOnPage=val;
		}

		function getFirstRecordOnPage() {
			return criteria.firstRecordOnPage;
		}

		function setLastRecordOnPage(val) {
			criteria.lastRecordOnPage=val;
		}

		function getLastRecordOnPage() {
			return criteria.lastRecordOnPage;
		}

		function setDirection(val) {
			criteria.direction=val;
		}

		function getDirection() {
			return criteria.direction;
		}

		function setIsSinglePlan(val) {
			criteria.isSinglePlan=val;
		}

		function getIsSinglePlan() {
			return criteria.isSinglePlan;
		}

		function setTotal(val) {
			criteria.total=val;
		}

		function getTotal() {
			return criteria.total;
		}

		function setSearchTextToDisplay(val) {
			criteria.searchTextToDisplay=val;
		}

		function getSearchTextToDisplay() {
			return criteria.searchTextToDisplay;
		}

		function setPleatProId(val) {
			criteria.pleatProId=val;
		}

		function getPleatProId() {
			return criteria.pleatProId;
		}

		function setPleatLocId(val) {
			criteria.pleatLocId=val;
		}

		function getPleatLocId() {
			return criteria.pleatLocId;
		}
		function setFromGeo(val) {
			criteria.fromGeo=val;
		}
		function getFromGeo() {
			return criteria.fromGeo;
		}

		// type-ahead functionality
		var checkForACOClassCodeBeforeDisplaying = function (acoCatObject) {
			return $.inArray('ACO', acoCatObject.classcodes) > -1 &&
			$.inArray('V98', acoCatObject.classcodes) > -1;
		};

		var initTypeAheadData = function () {
			// determine if type ahead switch is on or off
			criteria.typeAheadSwitch = getTypeAheadSwitch();

			// search results limits
			criteria.dymLimit = 3;
			criteria.specLimit = 3;
			criteria.hospLimit = 3;
			criteria.catLimit = 3;
			criteria.styLimit = 3;
			criteria.condLimit = 3;

			// location limits
			criteria.stateLimit = 3;
			criteria.cityLimit = 3;
			criteria.zipLimit = 3;
			criteria.countyLimit = 3;
		};

		// determine if we use open text instead of type-ahead for doing search.
		// There are 2 ways type-ahead can be turned off
		// - globally by a configuration property
		// - by the features API which allows a particular plan sponsor to turn it off
		var getTypeAheadSwitch = function() {
			// test for global switch
			var switchValue = configuration.typeAheadSwitch;
			if (switchValue) {
				switchValue = (switchValue === 'on');
			} else {
				// check the features API
				switchValue = true;  // default
				var features = $sessionStorage.PSfeatures;
				if (features != null) {
					if (!angular.isArray(features)) {
						features = [features];
					}

					// search for the open text feature
					for (var i=0; i<features.length; i++) {
						if (features[i].featureName === "providerSearchOpenText" && features[i].featureEvaluatedResult === "true") {
							switchValue = false;
							break;
						} // feature found
					} // searh features
				} // API successful
			} // use config or API

			return switchValue;
		}

		/**
		* Returns true if we should show all items in the type-ahead
		* group.  The rules are as follows:
		* - If there are 3 or less items, show them
		* - If there are 5 or more items, don't show them all
		* - If there are 4 items, change the limit for this group
		*   from 3 to 4 and then show them.
		*/
		var showAllItems = function(group, count) {
			var r = false;  // don't return all items yet
			if (group == 'specialist') {
				if (count <= criteria.specLimit) {
					r = true;
				} else if (count == criteria.specLimit + 1) {
					r = true;
					criteria.specLimit = count;
				}
			} else if (group == 'hospital') {
				if (count <= criteria.hospLimit) {
					r = true;
				} else if (count == criteria.hospLimit + 1) {
					r = true;
					criteria.hospLimit = count;
				}
			} else if (group == 'categorycode') {
				if (count <= criteria.catLimit) {
					r = true;
				} else if (count == criteria.catLimit + 1) {
					r = true;
					criteria.catLimit = count;
				}
			} else if (group == 'specialty') {
				if (count <= criteria.styLimit) {
					r = true;
				} else if (count == criteria.styLimit + 1) {
					r = true;
					criteria.styLimit = count;
				}
			} else if (group == 'condition') {
				if (count <= criteria.condLimit) {
					r = true;
				} else if (count == criteria.condLimit + 1) {
					r = true;
					criteria.condLimit = count;
				}
			} else if (group == 'zipcode') {
				if (count <= criteria.zipLimit) {
					r = true;
				} else if (count == criteria.zipLimit + 1) {
					r = true;
					criteria.zipLimit = count;
				}
			} else if (group == 'city') {
				if (count <= criteria.cityLimit) {
					r = true;
				} else if (count == criteria.cityLimit + 1) {
					r = true;
					criteria.cityLimit = count;
				}
			} else if (group == 'county') {
				if (count <= criteria.countyLimit) {
					r = true;
				} else if (count == criteria.countyLimit + 1) {
					r = true;
					criteria.countyLimit = count;
				}
			} else if (group == 'state') {
				if (count <= criteria.stateLimit) {
					r = true;
				} else if (count == criteria.stateLimit + 1) {
					r = true;
					criteria.stateLimit = count;
				}
			}
			return r;
		};

		/*
		* Adjust the limit variable for the appropriate group if we want to view all of the
		* items in that group.
		*/
		var clickViewMore = function(group, limit) {
			if (group == 'specialist') {
				criteria.specLimit = limit;
			} else if (group == 'hospital') {
				criteria.hospLimit = limit;
			} else if (group == 'categorycode') {
				criteria.catLimit = limit;
			} else if (group == 'specialty') {
				criteria.styLimit = limit;
			} else if (group == 'condition') {
				criteria.condLimit = limit;
			} else if (group == 'zipcode') {
				criteria.zipLimit = limit;
			} else if (group == 'city') {
				criteria.cityLimit = limit;
			} else if (group == 'county') {
				criteria.countyLimit = limit;
			} else if (group == 'state') {
				criteria.stateLimit = limit;
			}
		};

		// what to do when type-ahead search result is clicked on
		var setTypeAheadForSearch = function(item)
		{
			criteria.typeahead = item;
			criteria.isGuidedSearch = false;
			criteria.searchText = item.label;
			criteria.typeahead.label = item.label;
			//criteria.searchText = criteria.typeahead.label;

			$sessionStorage.criteria = criteria;
			//console.log("criteria" +JSON.stringify(criteria));
		};

		// what to do when location is clicked on
		var setTypeAheadForLocation = function(item)
		{
			criteria.typeAheadLocationClicked = item;  // what was clicked on
			typeaheadInterimResults.results = [];
			typeaheadInterimResults.count = 3;
		};

		// what to do when location pop-up is closed / accepted
		var acceptChangeLocation = function(item)
		{
			if (criteria.typeAheadLocationClicked != null) {
				criteria.typeAheadLocationResults = criteria.typeAheadLocationClicked;  // what was clicked on
				criteria.typeAheadLocationClicked = null;
			} else if (criteria.position) {  // we are using current location
				var item = {};  // create item from current location
				item.label = criteria.text.currentLocation;  // translated message
				item.category = "location";
				item.subcategory = "coordinates";
				item.coordinates = "" + criteria.position.coords.latitude + "," + criteria.position.coords.longitude;
				item.stateabbr = criteria.position.state;
				criteria.typeAheadLocationResults = item;  // current location
				// if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i)
				// || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)
				// || navigator.userAgent.match(/Windows Phone/i)
				// ){
				// 				alert("criteria.position.state = ");
				// 				alert(criteria.position.state);
				// 				alert("Inside criteria.typeAheadLocationResult and stateabbr = ");
				// 				alert(criteria.typeAheadLocationResults.stateabbr);
				//  }
			} else {
			}
		};

		// what to do when location pop-up is closed / canceled
		var closeChangeLocation = function() {
			criteria.typeAheadLocationClicked = null;
		};
		var callDidYouMeanService=function(val){
			var deferred = $q.defer();
			var obj;
			var didYouMeanUrl='';
			//added url from config.json
			didYouMeanUrl = configuration.didYouMeanUrl;
			/* below code no longer needed to get url
			if($sessionStorage.PSfeatures != undefined){
				for(var i=0;i<$sessionStorage.PSfeatures.length;i++){
					if($sessionStorage.PSfeatures[i].featureName=="didYouMeanUrl" && $sessionStorage.PSfeatures[i].featureEvaluatedResult=='true'){
						didYouMeanUrl=$sessionStorage.PSfeatures[i].featureUrl;
						break;
					}
				}
			}*/
			var url = didYouMeanUrl;
			//url = "https://vmc-apistage04.talix.com/api/service/2.0/docfind?partnerId=bf78eecc-f663-4eaa-bb1e-7992e8510c8a";
			return $http({
				method: 'GET',
				url: url,
				params: {searchTerms:val},
				crossDomain: true,
				//headers: {accept: 'text/xml'}
			}) .then(
				function success(response)
				{

					if (response.data ) {
						deferred.resolve(response.data);
					} else {
						deferred.resolve('There is no questionarre information found (List of Products) in response');
					}

					// promise is returned
					return deferred.promise;
				},
				function error(response)
				{
					// the following line rejects the promise
					deferred.reject(response);

					// promise is returned
					return deferred.promise;
				});
			};

			// type-ahead search service call
			var getTypeAheadSearchInfo = function(val) {
				initTypeAheadData();
				var catdata=[];
				var apiURL = buildTypeAdhedURLforSearch(val);
				/* criteria.isDidYouMean=false; */

				return $http.jsonp(apiURL,{withCredentials:false})
				.then(function success(response) {
					// Service is up, but it might not have returned any data
					if (response.data && response.data.data && response.data.data.length >= 1) {
						// data returned, so service is ok
						criteria.typeAheadStatus = 'up';
						criteria.isDidYouMean=false;
					} else { // no data returned from service
						// We need to see if service is up or if there is a
						// data problem.  To do this, we call the service again but this time
						// pass it a good query that should always return data
						// asdf
						apiURL = buildTypeAdhedURLforSearch('john');
						return $http.jsonp(apiURL,{withCredentials:false})
						.then(function success(response) {
							// Service is up, but it might not have returned any data
							if (response.data && response.data.data && response.data.data.length >= 1) {
								// data returned, so service is ok
								criteria.typeAheadStatus = 'up';

								// since service is up, but no data was returned, we will
								// call the didYouMean service for suggestions
								criteria.isDidYouMean=true;
								return callDidYouMeanService(val).then(function success(response) {
									var parser = new DOMParser();
									var xmlDoc = parser.parseFromString(response,"text/xml");
									var x = xmlDoc.getElementsByTagName("category");
									for(var i=0;i<x.length;i++){
										obj={};
										if(x[i].attributes[0].nodeValue=="didYouMean"){
											obj={category:'didYouMean',label:x[i].textContent};
											catdata.push(obj);
										}
									}
									return catdata.map(function(item, index) {
										return {
											id: index,
											label: item.label,
											category: item.category,
										};
									});
								});
							} else { // no data, so typeAhead is down
								// create a typeAhead category with a single selectable item - the value the user typed in.
								// This allows an open-text search if type-ahead is not returning data correctly.
								criteria.typeAheadStatus = 'down';
								return [{
									id: 0,
									label: val,
									category: 'down',
									aetnaid: '',
									lastname: '',
									firstname: '',
									zipcode: '',
									coordinates: '',
									categorycode: ''
								}];
							}
						}, // success
						function error(response) {
							criteria.typeAheadStatus = 'down';

							// Since type-ahead is down, put the search term as the only
							// type-ahead suggestion
							return [{
								id: 0,
								label: val,
								category: 'down',
								aetnaid: '',
								lastname: '',
								firstname: '',
								zipcode: '',
								coordinates: '',
								categorycode: ''
							}];

						}); // error calling typeAhead with good query

					} // call typeAhead service

					// If we get here, we return the results from the original
					// typeAhead service call.  The service is up and it returned
					// data.
					var categorydata = buildTypeAheadResultsForSearch(response.data.data);
					return categorydata.map(function(item, index) {
						return {
							id: index,
							label: item.label,
							url: item.url,
							category: item.category,
							subcategory: item.subcategory,
							aetnaid: item.aetnaid,
							lastname: item.lastname,
							firstname: item.firstname,
							zipcode: item.zipcode,
							coordinates: item.coordinates,
							categorycode: item.categorycode
						};
					});

				}, // success

				function error(response) {
					criteria.typeAheadStatus = 'down';

					// Since type-ahead is down, put the search term as the only
					// type-ahead suggestion
					return [{
						id: 0,
						label: val,
						category: 'down',
						aetnaid: '',
						lastname: '',
						firstname: '',
						zipcode: '',
						coordinates: '',
						categorycode: ''
					}];

				}); // error

			}; // getTypeAheadSearchInfo
			var typeaheadInterimResults = {
				results: [],
				count: 3
			}
			// type-ahead location service call
			var getTypeAheadLocationInfo = function(val) {
				// utility function to test for an integer
				function isInt(val) {
					var x;
					if (isNaN(val)) {
						return false;
					}
					var x = parseFloat(val);
					return (x | 0) === x;
				}

				// utility function to test for valid 5-digit zip code
				function isZipCode(val) {
					return val.trim().length === 5 && isInt(val);
				}

				initTypeAheadData();  // number of items in each group to display
				//Replacing comma with a comma and space to support searches like hartford,ct. Talix is not able to support this.
				val = val.replace(",",", ");
				var apiURL = buildTypeAdhedURLforLocation(val);
				return $http.jsonp(apiURL,{withCredentials:false})
				.then(function success(response) {
					criteria.medicare.areTypeAheadResultsReturned = true;
					// we know if the service is up and if good data is coming back
					if (response.data && response.data.data && response.data.data.length >= 1) {
						{
							criteria.typeAheadStatus = 'up';
							//This is to solve for when typeahead speed issues so that user does not see a lag.
							typeaheadInterimResults.results = response.data.data;
							//Initialise the mistake count everytime we get response from talix
							typeaheadInterimResults.count = 3;
						}
					} else {
						// we got no data.  We need to see if service is up or if there is a
						// data problem.
						testForBadData("location", val);
						//means the typeahead was successful but no results returned. In this case, use the intermin results upto 3 times.
						if(response.data.data && response.data.data.length>0 && response.data.meta && response.data.meta.code == 200 && typeaheadInterimResults.results.length > 0 && typeaheadInterimResults.count > 0)
						{
							//below if added if user clears everything in type ahead and enters an invalid text such as 'yyy' show error
							if(val.length==2){
								typeaheadInterimResults.results=[];
								typeaheadInterimResults.count=0;
								return null;
							}
							if(val.length==5 && isZipCode(val)){
								typeaheadInterimResults.results=[];
								typeaheadInterimResults.count=0;
								return null;
							}

							response.data.data = typeaheadInterimResults.results;
							typeaheadInterimResults.count = typeaheadInterimResults.count - 1;

						}
						else
							criteria.medicare.areTypeAheadResultsReturned = false;
						// we also need to return something if there is an error condition.
						// We can't determine it yet, because the bad data test is async.
						// We will have to rely on a previous test.  If a previous test found
						// bad data, it would have set the service to down.
						if (criteria.typeAheadStatus === "down") {
							// if we have a valid zip code anyway, return it as though it were a valid
							// type-ahead suggestion
							if (isZipCode(val)) {
								return [{
									id: 0,
									label: val,
									category: 'location',
									subcategory: 'zipcode',
									stateabbr: '',
									zipcode: val,
									coordinates: '',
									cityalias: ''
								}];

							} else {
								return null;  // not a zip code
							} // valid zip code test
						} // server down test
					} // data returned test

					// whether or not we got data, we return the results.
					var categorydata = buildTypeAheadResultsForLocation(response.data.data);
					return categorydata.map(function(item, index) {
						return {
							id: index,
							label: item.label,
							category: item.category,
							subcategory: item.subcategory,
							stateabbr: item.stateabbr,
							county: item.county,
							zipcode: item.zipcode,
							coordinates: item.coordinates,
							cityalias: item.cityalias
						};
					});
				},

				function error(response) {
					criteria.medicare.areTypeAheadResultsReturned = true;
					criteria.typeAheadStatus = 'down';
						criteria.typeAheadStatusText = 'unknown';

					// if we have a valid zip code anyway, return it as though it were a valid
					// type-ahead suggestion
					if (isZipCode(val)) {
						return [{
							id: 0,
							label: val,
							category: 'location',
							subcategory: 'zipcode',
							stateabbr: '',
							zipcode: val,
							coordinates: '',
							cityalias: ''
						}];

					}
					else if(!isInt(val)){
						criteria.typeAheadStatusText = 'downWithText';
						return null;
					} else {
						return null;  // not a zip code
					}
				});

			};

			var groupByForSearch = function(array, predicate) {
				var grouped = {};
				var orderedGroup = {};
				if (array != null && array.length > 0) {
					// fix the array
					for (var i = 0; i < array.length; i++) {
						if (array[i].type == 'specialist_any_location') {
							array[i].type = 'specialist';
							array[i].result = array[i].result + ' (any location)';
						}
						if (array[i].type == 'ipa') {
							array[i].type = 'specialist';
							array[i].subtype = 'ipa';
						}
						if (array[i].type == 'group') {
							array[i].type = 'specialist';
							array[i].subtype = 'group';
						}
						if (array[i].type == 'procedure') {
							array[i].type = 'condition';
						}
						if (array[i].type == 'facility') {
							array[i].type = 'hospital';
						}
					}

					// make the groups
					for (var i = 0; i < array.length; i++) {
						var groupKey = predicate(array[i]);
						if (typeof(grouped[groupKey]) === "undefined") {
							if (array[i].type == 'categorycode') {
								if (checkForACOClassCodeBeforeDisplaying(array[i])) {
									grouped[groupKey] = [];
								}
							} else {
								grouped[groupKey] = [];
							}
						}

						if (array[i].type == 'categorycode') {
							if (checkForACOClassCodeBeforeDisplaying(array[i])) {
								grouped[groupKey].push(array[i]);
							}
						} else {
							grouped[groupKey].push(array[i]);
						}
					} // making groups
				} // if array exists

				if (grouped.specialist != null && grouped.specialist.length > 0) {
					var arrLength = 0;
					if (grouped.specialist_any_location != null && grouped.specialist_any_location != 'undefined') {
						arrLength = grouped.specialist_any_location.length;
					}
					if (arrLength > 0) {
						for (var count = 0; count < arrLength; count++) {
							grouped.specialist.splice(count, 0, grouped.specialist_any_location[count]);
							orderedGroup.specialist = grouped.specialist;
						}
					} else {
						orderedGroup.specialist = grouped.specialist;
					}
				}

				if (grouped.hospital != null && grouped.hospital.length > 0) {
					orderedGroup.hospital = grouped.hospital;
				}

				if (grouped.categorycode != null && grouped.categorycode.length > 0) {
					orderedGroup.categorycode = grouped.categorycode;
				}

				if (grouped.facility != null && grouped.facility.length > 0) {
					orderedGroup.facility = grouped.facility;
				}

				if (grouped.specialty != null && grouped.specialty.length > 0) {
					orderedGroup.specialty = grouped.specialty;
				}

				if (grouped.condition != null && grouped.condition.length > 0) {
					orderedGroup.condition = grouped.condition;
				}

				if (grouped.procedure != null && grouped.procedure.length > 0) {
					orderedGroup.procedure = grouped.procedure;
				}

				if (grouped.practice != null && grouped.practice.length > 0) {
					orderedGroup.practice = grouped.practice;
				}

				return orderedGroup;
			};

			var groupByForLocation = function(array, predicate) {
				var grouped = {};
				var orderedGroup = {};
				for (var i = 0; i < array.length; i++) {
					var groupKey = predicate(array[i]);
					if (typeof(grouped[groupKey]) === "undefined") {
						grouped[groupKey] = [];
					}

					grouped[groupKey].push(array[i]);
				}
				if (grouped.location != null && grouped.location.length > 0) {
					orderedGroup.location = grouped.location;
				}

				return orderedGroup;
			};

			var buildTypeAheadResultsForSearch = function(json) {
				var data = [];
				resetDisplayedGroupCount();
				var groupData = groupByForSearch(json, function(obj) {
					return obj.type;
				});
				var oArray = null;
				$.each(groupData, function(key, val) {
					oArray = val;
					$.each(oArray, function(i, v) {
						data.push({
							label: v["result"],
							url: v["url"],
							category: v["type"],
							subcategory: v["subtype"],
							aetnaid: v["aetnaid"],
							lastname: v["lastname"],
							firstname: v["firstname"],
							zipcode: v["zipcode"],
							coordinates: v["coordinates"],
							categorycode: v["categorycode"]
						});
					});
				});
				return data;
			};

			var buildTypeAheadResultsForLocation = function(json) {
				var data = [];
				resetDisplayedGroupCount();
				var groupData = groupByForLocation(json, function(obj) {
					return obj.type;
				});
				var oArray = null;
				$.each(groupData, function(key, val) {
					oArray = val;
					$.each(oArray, function(i, v) {
						// add city/state to zip code label
						if (!v.subtype) {
							v.subtype = 'zipcode';
						}
						if (v.subtype == 'zipcode' && v.city && v.stateabbr ) {
							v.result = v.zipcode + ' (' + v.city + ', ' + v.stateabbr + ')';
						}
						// add county, extracted from label
						if (v.subtype == 'county') {
							v.county = v.result.split(',')[0];
						}

						data.push({
							label: v.result,
							category: v.type,
							subcategory: v.subtype,
							stateabbr: v.stateabbr || v.state,
							zipcode: v.zipcode,
							county: v.county,
							coordinates: v.coordinates,
							cityalias: v.cityalias
						});
					});
				});
				return data;
			};

			function getURLBase() {
				// var typeAheadUrl='';
				// if($sessionStorage.PSfeatures != undefined){
				// 	for(var i=0;i<$sessionStorage.PSfeatures.length;i++){
				// 		if($sessionStorage.PSfeatures[i].featureName=="typeAheadUrl" && $sessionStorage.PSfeatures[i].featureEvaluatedResult=='true'){
				// 			typeAheadUrl=$sessionStorage.PSfeatures[i].featureUrl;
				// 			break;
				// 		}
				// 	}
				// }

				var urlBase = configuration.typeAheadUrl;
				return urlBase;
			}

			function buildTypeAdhedURLforSearch(val){
				// URL base
				var urlBase = getURLBase();

				// URL parameters
				var parmQ = "&q=" + encodeURIComponent(val);  // search term
				var parmRadius = "";  // we don't know if we need this
				var parmZip = "";  // we don't know if we need this
				var parmState = "";  // we don't know if we need this
				var parmCounty = "";  // we don't know if we need this
				var parmCoordinates = "";  // we don't know if we need this

				var loc = criteria.typeAheadLocationResults;  // what location user clicked on

				if (loc === null) {  // clicked on nothing
					// is this valid?
				} else if (loc.subcategory === 'city' || loc.subcategory == 'zipcode') {
					parmRadius = "&radius=" + getDistance();  // from slider
					parmZip = "&zipcode=" + loc.zipcode;
				} else if (loc.subcategory === 'state') {
					parmState = "&stateabbr=" + loc.stateabbr;
				} else if (loc.subcategory === 'county') {
					parmState = "&stateabbr=" + loc.stateabbr;
					parmCounty = "&county=" + (loc.county).toUpperCase();
				} else if (loc.subcategory === 'coordinates') {
					parmCoordinates = "&latlong=" + loc.coordinates;
				} else {
					// invalid search
				}

				var  typeAheadURL = urlBase + parmQ
				+ parmRadius + parmZip + parmState + parmCounty;

				return typeAheadURL;
			};

			function buildTypeAdhedURLforLocation(val){

				// URL base
				var urlBase = getURLBase();

				var  typeAheadURL = urlBase
				+ "&q=" + encodeURIComponent(val)
				+ "&wherebox=1&counties=true"
				;

				return typeAheadURL;
			};

			function setInitialLocation(zip) {
				// sanitize zip code
				zip = zip.trim().length > 5 ? zip.trim().substring(0,5) : zip.trim();

				// set initial search as a zip code search
				criteria.typeAheadLocationResults.zipcode = zip;
				criteria.typeAheadLocationResults.label = zip;
				criteria.typeAheadLocationResults.type = 'location';
				criteria.typeAheadLocationResults.subcategory = 'zipcode';
				criteria.typeAheadLocationResults.coordinates = "";

				// get the coordinates from the type-ahead service
				var apiURL = buildTypeAdhedURLforLocation(zip);
				var service = $http.jsonp(apiURL,{withCredentials:false});
				service.then(function success(response) {
					if (response.data && response.data.data && response.data.data.length >= 1) {
						var loc = response.data.data[0];  // data for zip code
						criteria.typeAheadLocationResults.coordinates = loc.coordinates;
						// add city/state to zip code label
						if (loc.city && loc.state) {
							criteria.typeAheadLocationResults.label = zip + ' (' + loc.city + ', ' + loc.state + ')';
						}
					} else {
						criteria.typeAheadLocationResults.coordinates = "";
					}

				},function error(response) {
				});

			};

			// Test if type-ahead service is having data issues.  It will pass a known set of
			// parameters to the service and see if data comes back.  If it does not, the service
			// may be up, but it is having problems, so it will be flagged as down.
			// The following will be tested
			// - for a location search with numbers, test with a valid zip code
			// - for a location search with letters, test with a valid state name
			// - for a provider search, test with a valid condition name

			// the following functions build service URLs for testing the various scenarios
			function buildTypeAdhedURLforSearchTest(){
				var urlBase = getURLBase();

				// URL parameters
				var parmQ = "&q=heart";  // valid test condition
				var parmRadius = "&radius=25";  // valid test radius
				var parmZip = "&zipcode=55124";  // valid test zip code

				var  typeAheadURL = urlBase + parmQ
				+ parmRadius + parmZip;

				return typeAheadURL;
			};

			function buildTypeAdhedURLforZipTest(){
				// URL base
				var urlBase = getURLBase();

				var  typeAheadURL = urlBase
				+ "&q=551"
				+ "&wherebox=1&counties=true"
				;

				return typeAheadURL;
			};

			function buildTypeAdhedURLforStateTest(){
				// URL base
				var urlBase = getURLBase();

				var  typeAheadURL = urlBase
				+ "&q=north"
				+ "&wherebox=1&counties=true"
				;

				return typeAheadURL;
			};

			function testForBadData(searchType, searchValue) {
				var serviceURL;

				if (searchType == "location" && searchValue >= '0' && searchValue <= '9') {
					// zip code search
					serviceURL = buildTypeAdhedURLforZipTest();
					searchType = "zip";  // clarify the search type
				} else if (searchType == "location") {
					// city,state,county search
					serviceURL = buildTypeAdhedURLforStateTest();
					searchType = "state";  // clarify the search type
				} else {
					// provider search
					serviceURL = buildTypeAdhedURLforSearchTest();
				}

				// do the test service call.  When the call completes, we should be able to update
				// the state of the service and data.
				var service = $http.jsonp(serviceURL,{withCredentials:false});
				service.then(function success(response) {
					if (response.data && response.data.data && response.data.data.length >= 1) {
						// we know the service is up and that good data is coming back
						criteria.typeAheadStatus = 'up';
					} else {
						// we know that the service is returning bad data
						criteria.typeAheadStatus = 'down';  // we will say it's down
					};

				},function error(response) {
					// we know the service is down
					criteria.typeAheadStatus = 'down';
				});

			}

			// reverse geolocation functionality

			// URL for geo service
			function buildReverseGeoURL(lat,lon) {
				var urlBase = configuration.reverseGeoAPI;
				var url = urlBase + "location=" + lat + "," + lon;
				return url;
			}

			// geo search service call
			var getReverseGeoInfo = function(lat,lon) {
				var apiURL = buildReverseGeoURL(lat,lon);
				alert("api for reverse getReverseGeoInfo");
				alert(apiURL);
				return $http.jsonp(apiURL,{withCredentials:false})
				.then(function success(response) {
					// store the state
					criteria.position.state = response.data.results[0].locations[0].adminArea3;
										alert("response.data.results[0].locations[0].adminArea3 == ");
										alert(response.data.results[0].locations[0].adminArea3);
										alert("fddfd criteria.position.state == ");
										alert(criteria.position.state);


				}, // success

				function error(response) {
					alert("service error");
					alert(response);
				}); // error

			}; // getReverseGeoInfo

			// this needs to be called at the start of displaying type-ahead groups
			var resetDisplayedGroupCount = function() {
				criteria.displayedGroupCount = 0;
			};

			init();


			function setMembers(data)
			{
				criteria.members = data;
				// notify listeners and provide the data that changed [optional]
				//  $rootScope.$broadcast('providerCriteria:updated',criteria);
			}

			var identifyMedicareMember = function()
			{
				var features  = $sessionStorage.PSfeatures;
				if(features!=null)
				{
					if (angular.isArray(features)) {

					} else {
						features  =  [features];
					}

					for(var i=0;i<features.length;i++)
					{
						if(features[i].featureName == "providerSearchMedicare" && features[i].featureEvaluatedResult == "true")
						return true;
					}
				}

				return false;
			};
			
			function buildTypeAdhedURLforCounties(item,url,debug){
			//	var url = configuration.PublicCountiesServiceURL; 
				if(item && item.subcategory && item.subcategory == 'zipcode'){
					url = url + 'zip=' + item.zipcode;
					if(item.stateabbr){
						url = url + '&state=' + item.stateabbr;
					}
				} else if(item && item.subcategory && item.subcategory == 'state'){
					url = url + 'state=' + item.stateabbr;
				} else if(item && item.subcategory && item.subcategory == 'city'){
					var city = item.label;
					city = city.substr(0,city.indexOf(','));
					url = url + 'state=' + item.stateabbr + '&city=' + city;
				}
				if(debug)
					url = url + '&debug=' + debug;
				return url;
			};
			
			//This will check internal or external. By default internal.  
			function getCounties(item,debug){
				var clientId = configuration.PublicCountiesServiceClientId;
				var apiUrl = configuration.PublicCountiesServiceURL;
				if( $sessionStorage.isExternal && $sessionStorage.isExternal == true )
    			{
    				apiUrl = configuration.externalPublicCountiesServiceURL;
        			clientId = configuration.externalPublicCountiesServiceClientId;
    			}
				
				var url = buildTypeAdhedURLforCounties(item,apiUrl,debug);
				var criteria = getCriteria();
				
				var deferred = $q.defer();
				return $http({
        				method: 'GET',
        				url:url,
        				params: {siteId:criteria.siteId, responseLanguagePreference:criteria.lang},
        				headers : {
        					accept : 'application/json',
        					'X-IBM-Client-Id' : clientId
        				}
        			}) .then(
      					function success(response)
      					{
							if (response.data && response.data) {
								results = response.data;
      							deferred.resolve(results);
      						} else {
      							deferred.resolve('No Results found');
      						}
      						// promise is returned
      						return deferred.promise;
						}, 
						function error(response){
							var perfectoSwitch = configuration.perfectoSwitch;

    						//alert ("Search results normal call " + response.status);
      						if( ( response.status == -1 || response.status == 404 ) && perfectoSwitch )
							{
								return getCountiesExternal(item);
							}
      						else{
      						
      							deferred.reject(response);
      							return deferred.promise;
      						} 						
							
							
						});
			} 
			
			//This will always make external call. 
			function getCountiesExternal(item){
				var apiUrl = configuration.externalPublicCountiesServiceURL;
        		var clientId = configuration.externalPublicCountiesServiceClientId;
    			
        		var url = buildTypeAdhedURLforCounties(item,apiUrl,false);
				var criteria = getCriteria();
				
				
				
				
				var deferred = $q.defer();
				return $http({
        				method: 'GET',
        				url:url,
        				params: {siteId:criteria.siteId, responseLanguagePreference:criteria.lang},
        				headers : {
        					accept : 'application/json',
        					'X-IBM-Client-Id' : clientId
        				}
        			}) .then(
      					function success(response)
      					{
							if (response.data && response.data) {
								results = response.data;
      							deferred.resolve(results);
      						} else {
      							deferred.resolve('No Results found');
      						}
      						// promise is returned
      						return deferred.promise;
						}, 
						function error(response){				      						
      							deferred.reject(response);
      							return deferred.promise;							
						});
			} 

			
			/*For Medicare Only*/
			if($state.params.year && $state.params.category && $state.params.site_id == 'medicare')
			{
					//Possible DRX flow. 
				criteria.medicare.planYear = $state.params.year;
    			criteria.medicare.category = $state.params.category;			
    			/**When this happens we will show the user directly the Perm Res section and ignore the Links that display**/
    			//document.getElementsByClassName('columnOne')[0].style.display = "none";
                //document.getElementById('dynamicTemplate').style.display = "block";
			}
			if($state.params.RETURN_URL)
			{
				criteria.returnUrl= $state.params.RETURN_URL;
			}
			

			return {
				/*criteria:criteria,*/
				init : init,
				getSearchText: getSearchText,
				setSearchText: setSearchText,
				getSearchTextForBackEnd: getSearchTextForBackEnd,
				setSearchTextForBackEnd: setSearchTextForBackEnd,
				getSelectedMemberFName: getSelectedMemberFName,
				setSelectedMemberFName: setSelectedMemberFName,
				setSelectedMemberLName: setSelectedMemberLName,
				getSelectedMemberLName: getSelectedMemberLName,
				getSelectedMemberId:getSelectedMemberId,
				setSelectedMemberId:setSelectedMemberId,
				setInitialLocation: setInitialLocation,
				getCriteria: getCriteria,
				setCriteria:setCriteria,
				getPlanCriteria:getPlanCriteria,
				setPlanCriteria:setPlanCriteria,
				getDistance: getDistance,
				setDistance: setDistance,
				setHospitalNavigator:setHospitalNavigator,
				getHospitalNavigator:getHospitalNavigator,
				getTypeAheadLocationInfo: getTypeAheadLocationInfo,
				getTypeAheadSearchInfo: getTypeAheadSearchInfo,
				showAllItems: showAllItems,
				clickViewMore: clickViewMore,
				setTypeAheadForSearch: setTypeAheadForSearch,
				setTypeAheadForLocation: setTypeAheadForLocation,
				acceptChangeLocation: acceptChangeLocation,
				closeChangeLocation: closeChangeLocation,
				setMembers:setMembers,
				getOrder:getOrder,
				setOrder:setOrder,
				getListSelection:getListSelection,
				setListSelection:setListSelection,
				setPage:setPage,
				getisDidYouMean:getisDidYouMean,
				setFirstRecordOnPage:setFirstRecordOnPage,
				getFirstRecordOnPage:getFirstRecordOnPage,
				setLastRecordOnPage:setLastRecordOnPage,
				getLastRecordOnPage:setLastRecordOnPage,
				setDirection:setDirection,
				getDirection:getDirection,
				setPlanName:setPlanName,
				getPlanName:getPlanName,
				setPlanProductCode:setPlanProductCode,
				getPlanProductCode:getPlanProductCode,
				setPlanPipeName:setPlanPipeName,
				getPlanPipeName:getPlanPipeName,
				getReverseGeoInfo:getReverseGeoInfo,
				setTotal:setTotal,
				getTotal:getTotal,
				identifyMedicareMember:identifyMedicareMember,
				getGroupId:getGroupId,
				getGroupName:getGroupName,
				setSearchTextToDisplay:setSearchTextToDisplay,
				getSearchTextToDisplay:getSearchTextToDisplay,
				setPlanPleatShow:setPlanPleatShow,
				getPlanPleatShow:getPlanPleatShow,
				setIsSinglePlan:setIsSinglePlan,
				getIsSinglePlan:getIsSinglePlan,
				setPleatProId:setPleatProId,
				getPleatProId:getPleatProId,
				setPleatLocId:setPleatLocId,
				getPleatLocId:getPleatLocId,
				getAlphabetOrder:getAlphabetOrder,
				setAlphabetOrder: setAlphabetOrder,
				resetCriteria:resetCriteria,
				setFromGeo:setFromGeo,
				getFromGeo:getFromGeo,
				getCounties: getCounties,
				/*getIsAssociatedProvidersSearchForGroup: getIsAssociatedProvidersSearchForGroup,
				setIsAssociatedProvidersSearchForGroup: setIsAssociatedProvidersSearchForGroup*/
			};
		}
	})();

},{}],64:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],65:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var esapi = {
    codecs: {}
};


esapi.codecs.Codec = function() {
    return {
        /**
         * Encode a String so that it can be safely used in a specific context.
         *
         * @param aImmune
         *              array of immune characters
         * @param sInput
         *              the String to encode
         * @return the encoded String
         */
        encode: function(aImmune, sInput) {
            var out = '';
            for (var i = 0; i < sInput.length; i ++) {
                var c = sInput.charAt(i);
                out += this.encodeCharacter(aImmune, c);
            }
            return out;
        },

        /**
         * Default implementation that should be overridden in specific codecs.
         *
         * @param aImmune
         *              array of immune characters
         * @param c
         *              the Character to encode
         * @return
         *              the encoded Character
         */
        encodeCharacter: function(aImmune, c) {
            return c;
        },

        /**
         * Decode a String that was encoded using the encode method in this Class
         *
         * @param sInput
         *              the String to decode
         * @return
         *              the decoded String
         */
        decode: function(sInput) {
            var out = '';
            var pbs = new esapi.codecs.PushbackString(sInput);
            while (pbs.hasNext()) {
                var c = this.decodeCharacter(pbs);
                if (c != null) {
                    out += c;
                } else {
                    out += pbs.next();
                }
            }
            return out;
        },

        /**
         * Returns the decoded version of the next character from the input string and advances the
         * current character in the PushbackString.  If the current character is not encoded, this
         * method MUST reset the PushbackString.
         *
         * @param oPushbackString the Character to decode
         * @return the decoded Character
         */
        decodeCharacter: function(oPushbackString) {
            return oPushbackString.next();
        }
    };
};

esapi.codecs.Codec.getHexForNonAlphanumeric = function(c) {
    if (c.charCodeAt(0) < 256) {
        return esapi.codecs.Codec.hex[c.charCodeAt(0)];
    }
    return c.charCodeAt(0).toString(16);
};

esapi.codecs.Codec.hex = [];
for ( var c = 0; c < 0xFF; c ++ ) {
    if ( c >= 0x30 && c <= 0x39 || c>= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A ) {
        esapi.codecs.Codec.hex[c] = null;
    } else {
        esapi.codecs.Codec.hex[c] = c.toString(16);
    }
};

esapi.codecs.Base64 = {
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encode: function(sInput) {
        if (!sInput) {
            return null;
        }

        var out = '';
        var ch1,ch2,ch3,enc1,enc2,enc3,enc4;
        var i = 0;

        var input = esapi.codecs.UTF8.encode(sInput);

        while (i < input.length) {
            ch1 = input.charCodeAt(i++);
            ch2 = input.charCodeAt(i++);
            ch3 = input.charCodeAt(i++);

            enc1 = ch1 >> 2;
            enc2 = ((ch1 & 3) << 4) | (ch2 >> 4);
            enc3 = ((ch2 & 15) << 2) | (ch3 >> 6);
            enc4 = ch3 & 63;

            if (isNaN(ch2)) {
                enc3 = enc4 = 64;
            }
            else if (isNaN(ch3)) {
                enc4 = 64;
            }

            out += this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
        }

        return out;
    },

    decode: function(sInput) {
        if (!sInput) {
            return null;
        }

        var out = '';
        var ch1, ch2, ch3, enc1, enc2, enc3, enc4;
        var i = 0;

        var input = sInput.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {
            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            ch1 = (enc1 << 2) | (enc2 >> 4);
            ch2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            ch3 = ((enc3 & 3) << 6) | enc4;

            out += String.fromCharCode(ch1);
            if (enc3 != 64) {
                out += String.fromCharCode(ch2);
            }
            if (enc4 != 64) {
                out += String.fromCharCode(ch3);
            }
        }

        out = esapi.codecs.UTF8.decode(out);
        return out;
    }
};


esapi.codecs.CSSCodec = function() {
    var _super = new esapi.codecs.Codec();

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (utils.contains(aImmune, c)) {
                return c;
            }

            var hex = esapi.codecs.Codec.getHexForNonAlphanumeric(c);
            if (hex == null) {
                return c;
            }

            return "\\" + hex + " ";
        },

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null) {
                oPushbackString.reset();
                return null;
            }

            if (first != '\\') {
                oPushbackString.reset();
                return null;
            }

            var second = oPushbackString.next();
            if (second == null) {
                oPushbackString.reset();
                return null;
            }

            if (oPushbackString.isHexDigit(second)) {
                var out = second;
                for (var i = 0; i < 6; i ++) {
                    var c = oPushbackString.next();
                    if (c == null || c.charCodeAt(0) == 0x20) {
                        break;
                    }
                    if (oPushbackString.isHexDigit(c)) {
                        out += c;
                    } else {
                        input.pushback(c);
                        break;
                    }
                }

                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            }

            return second;
        }
    };
};


var entityToCharacterMap = [];
entityToCharacterMap["&quot"]        = "34";      /* 34 : quotation mark */
entityToCharacterMap["&amp"]         = "38";      /* 38 : ampersand */
entityToCharacterMap["&lt"]          = "60";        /* 60 : less-than sign */
entityToCharacterMap["&gt"]          = "62";        /* 62 : greater-than sign */
entityToCharacterMap["&nbsp"]        = "160";      /* 160 : no-break space */
entityToCharacterMap["&iexcl"]       = "161";     /* 161 : inverted exclamation mark */
entityToCharacterMap["&cent"]			= "162";	/* 162  : cent sign */
entityToCharacterMap["&pound"]			= "163";	/* 163  : pound sign */
entityToCharacterMap["&curren"]			= "164";	/* 164  : currency sign */
entityToCharacterMap["&yen"]			= "165";	/* 165  : yen sign */
entityToCharacterMap["&brvbar"]			= "166";	/* 166  : broken bar */
entityToCharacterMap["&sect"]			= "167";	/* 167  : section sign */
entityToCharacterMap["&uml"]			= "168";	/* 168  : diaeresis */
entityToCharacterMap["&copy"]			= "169";	/* 169  : copyright sign */
entityToCharacterMap["&ordf"]			= "170";	/* 170  : feminine ordinal indicator */
entityToCharacterMap["&laquo"]          = "171";    /* 171 : left-pointing double angle quotation mark */
entityToCharacterMap["&not"]			= "172";	/* 172  : not sign */
entityToCharacterMap["&shy"]			= "173";	/* 173  : soft hyphen */
entityToCharacterMap["&reg"]			= "174";	/* 174  : registered sign */
entityToCharacterMap["&macr"]			= "175";	/* 175  : macron */
entityToCharacterMap["&deg"]			= "176";	/* 176  : degree sign */
entityToCharacterMap["&plusmn"]         = "177";    /* 177 : plus-minus sign */
entityToCharacterMap["&sup2"]			= "178";	/* 178  : superscript two */
entityToCharacterMap["&sup3"]			= "179";	/* 179  : superscript three */
entityToCharacterMap["&acute"]			= "180";	/* 180  : acute accent */
entityToCharacterMap["&micro"]			= "181";	/* 181  : micro sign */
entityToCharacterMap["&para"]			= "182";	/* 182  : pilcrow sign */
entityToCharacterMap["&middot"]			= "183";	/* 183  : middle dot */
entityToCharacterMap["&cedil"]			= "184";	/* 184  : cedilla */
entityToCharacterMap["&sup1"]			= "185";	/* 185  : superscript one */
entityToCharacterMap["&ordm"]			= "186";	/* 186  : masculine ordinal indicator */
entityToCharacterMap["&raquo"]          = "187";    /* 187 : right-pointing double angle quotation mark */
entityToCharacterMap["&frac14"]			= "188";	/* 188  : vulgar fraction one quarter */
entityToCharacterMap["&frac12"]			= "189";	/* 189  : vulgar fraction one half */
entityToCharacterMap["&frac34"]			= "190";	/* 190  : vulgar fraction three quarters */
entityToCharacterMap["&iquest"]			= "191";	/* 191  : inverted question mark */
entityToCharacterMap["&Agrave"]			= "192";	/* 192  : Latin capital letter a with grave */
entityToCharacterMap["&Aacute"]			= "193";	/* 193  : Latin capital letter a with acute */
entityToCharacterMap["&Acirc"]			= "194";	/* 194  : Latin capital letter a with circumflex */
entityToCharacterMap["&Atilde"]			= "195";	/* 195  : Latin capital letter a with tilde */
entityToCharacterMap["&Auml"]			= "196";	/* 196  : Latin capital letter a with diaeresis */
entityToCharacterMap["&Aring"]			= "197";	/* 197  : Latin capital letter a with ring above */
entityToCharacterMap["&AElig"]			= "198";	/* 198  : Latin capital letter ae */
entityToCharacterMap["&Ccedil"]			= "199";	/* 199  : Latin capital letter c with cedilla */
entityToCharacterMap["&Egrave"]			= "200";	/* 200  : Latin capital letter e with grave */
entityToCharacterMap["&Eacute"]			= "201";	/* 201  : Latin capital letter e with acute */
entityToCharacterMap["&Ecirc"]			= "202";	/* 202  : Latin capital letter e with circumflex */
entityToCharacterMap["&Euml"]			= "203";	/* 203  : Latin capital letter e with diaeresis */
entityToCharacterMap["&Igrave"]			= "204";	/* 204  : Latin capital letter i with grave */
entityToCharacterMap["&Iacute"]			= "205";	/* 205  : Latin capital letter i with acute */
entityToCharacterMap["&Icirc"]			= "206";	/* 206  : Latin capital letter i with circumflex */
entityToCharacterMap["&Iuml"]			= "207";	/* 207  : Latin capital letter i with diaeresis */
entityToCharacterMap["&ETH"]			    = "208";	/* 208  : Latin capital letter eth */
entityToCharacterMap["&Ntilde"]			= "209";	/* 209  : Latin capital letter n with tilde */
entityToCharacterMap["&Ograve"]			= "210";	/* 210  : Latin capital letter o with grave */
entityToCharacterMap["&Oacute"]			= "211";	/* 211  : Latin capital letter o with acute */
entityToCharacterMap["&Ocirc"]           = "212";  /* 212 : Latin capital letter o with circumflex */
entityToCharacterMap["&Otilde"]			= "213";	 /* 213 : Latin capital letter o with tilde */
entityToCharacterMap["&Ouml"]			= "214";	 /* 214 : Latin capital letter o with diaeresis */
entityToCharacterMap["&times"]			= "215";	 /* 215 : multiplication sign */
entityToCharacterMap["&Oslash"]			= "216";	 /* 216 : Latin capital letter o with stroke */
entityToCharacterMap["&Ugrave"]			= "217";	 /* 217 : Latin capital letter u with grave */
entityToCharacterMap["&Uacute"]			= "218";	 /* 218 : Latin capital letter u with acute */
entityToCharacterMap["&Ucirc"]			= "219";	 /* 219 : Latin capital letter u with circumflex */
entityToCharacterMap["&Uuml"]			= "220";	 /* 220 : Latin capital letter u with diaeresis */
entityToCharacterMap["&Yacute"]			= "221";	 /* 221 : Latin capital letter y with acute */
entityToCharacterMap["&THORN"]			= "222";	 /* 222 : Latin capital letter thorn */
entityToCharacterMap["&szlig"]           = "223";   /* 223 : Latin small letter sharp s, German Eszett */
entityToCharacterMap["&agrave"]			= "224";	 /* 224 : Latin small letter a with grave */
entityToCharacterMap["&aacute"]			= "225";	 /* 225 : Latin small letter a with acute */
entityToCharacterMap["&acirc"]			= "226";	 /* 226 : Latin small letter a with circumflex */
entityToCharacterMap["&atilde"]			= "227";	 /* 227 : Latin small letter a with tilde */
entityToCharacterMap["&auml"]			= "228";	 /* 228 : Latin small letter a with diaeresis */
entityToCharacterMap["&aring"]			= "229";	 /* 229 : Latin small letter a with ring above */
entityToCharacterMap["&aelig"]			= "230";	 /* 230 : Latin lowercase ligature ae */
entityToCharacterMap["&ccedil"]			= "231";	 /* 231 : Latin small letter c with cedilla */
entityToCharacterMap["&egrave"]			= "232";	 /* 232 : Latin small letter e with grave */
entityToCharacterMap["&eacute"]			= "233";	 /* 233 : Latin small letter e with acute */
entityToCharacterMap["&ecirc"]			= "234";	 /* 234 : Latin small letter e with circumflex */
entityToCharacterMap["&euml"]			= "235";	 /* 235 : Latin small letter e with diaeresis */
entityToCharacterMap["&igrave"]			= "236";	 /* 236 : Latin small letter i with grave */
entityToCharacterMap["&iacute"]			= "237";	 /* 237 : Latin small letter i with acute */
entityToCharacterMap["&icirc"]			= "238";	 /* 238 : Latin small letter i with circumflex */
entityToCharacterMap["&iuml"]			= "239";	 /* 239 : Latin small letter i with diaeresis */
entityToCharacterMap["&eth"]			    = "240";	 /* 240 : Latin small letter eth */
entityToCharacterMap["&ntilde"]			= "241";	 /* 241 : Latin small letter n with tilde */
entityToCharacterMap["&ograve"]			= "242";	 /* 242 : Latin small letter o with grave */
entityToCharacterMap["&oacute"]			= "243";	 /* 243 : Latin small letter o with acute */
entityToCharacterMap["&ocirc"]			= "244";	 /* 244 : Latin small letter o with circumflex */
entityToCharacterMap["&otilde"]			= "245";	 /* 245 : Latin small letter o with tilde */
entityToCharacterMap["&ouml"]			= "246";	 /* 246 : Latin small letter o with diaeresis */
entityToCharacterMap["&divide"]			= "247";	 /* 247 : division sign */
entityToCharacterMap["&oslash"]			= "248";	 /* 248 : Latin small letter o with stroke */
entityToCharacterMap["&ugrave"]			= "249";	 /* 249 : Latin small letter u with grave */
entityToCharacterMap["&uacute"]			= "250";	 /* 250 : Latin small letter u with acute */
entityToCharacterMap["&ucirc"]			= "251";	 /* 251 : Latin small letter u with circumflex */
entityToCharacterMap["&uuml"]			= "252";	 /* 252 : Latin small letter u with diaeresis */
entityToCharacterMap["&yacute"]			= "253";	 /* 253 : Latin small letter y with acute */
entityToCharacterMap["&thorn"]			= "254";	 /* 254 : Latin small letter thorn */
entityToCharacterMap["&yuml"]			= "255";	 /* 255 : Latin small letter y with diaeresis */
entityToCharacterMap["&OElig"]			= "338";	 /* 338 : Latin capital ligature oe */
entityToCharacterMap["&oelig"]			= "339";	 /* 339 : Latin small ligature oe */
entityToCharacterMap["&Scaron"]			= "352";	 /* 352 : Latin capital letter s with caron */
entityToCharacterMap["&scaron"]			= "353";	 /* 353 : Latin small letter s with caron */
entityToCharacterMap["&Yuml"]			= "376";	 /* 376 : Latin capital letter y with diaeresis */
entityToCharacterMap["&fnof"]			= "402";	 /* 402 : Latin small letter f with hook */
entityToCharacterMap["&circ"]			= "710";	 /* 710 : modifier letter circumflex accent */
entityToCharacterMap["&tilde"]			= "732";	 /* 732 : small tilde */
entityToCharacterMap["&Alpha"]			= "913";	 /* 913 : Greek capital letter alpha */
entityToCharacterMap["&Beta"]			= "914";	 /* 914 : Greek capital letter beta */
entityToCharacterMap["&Gamma"]			= "915";	 /* 915 : Greek capital letter gamma */
entityToCharacterMap["&Delta"]			= "916";	 /* 916 : Greek capital letter delta */
entityToCharacterMap["&Epsilon"]			= "917";	 /* 917 : Greek capital letter epsilon */
entityToCharacterMap["&Zeta"]			= "918";	 /* 918 : Greek capital letter zeta */
entityToCharacterMap["&Eta"]			    = "919";	 /* 919 : Greek capital letter eta */
entityToCharacterMap["&Theta"]			= "920";	 /* 920 : Greek capital letter theta */
entityToCharacterMap["&Iota"]			= "921";	 /* 921 : Greek capital letter iota */
entityToCharacterMap["&Kappa"]			= "922";	 /* 922 : Greek capital letter kappa */
entityToCharacterMap["&Lambda"]			= "923";	 /* 923 : Greek capital letter lambda */
entityToCharacterMap["&Mu"]			= "924";	 /* 924 : Greek capital letter mu */
entityToCharacterMap["&Nu"]			= "925";	 /* 925 : Greek capital letter nu */
entityToCharacterMap["&Xi"]			= "926";	 /* 926 : Greek capital letter xi */
entityToCharacterMap["&Omicron"]			= "927";	 /* 927 : Greek capital letter omicron */
entityToCharacterMap["&Pi"]			= "928";	 /* 928 : Greek capital letter pi */
entityToCharacterMap["&Rho"]			= "929";	 /* 929 : Greek capital letter rho */
entityToCharacterMap["&Sigma"]			= "931";	 /* 931 : Greek capital letter sigma */
entityToCharacterMap["&Tau"]			= "932";	 /* 932 : Greek capital letter tau */
entityToCharacterMap["&Upsilon"]			= "933";	 /* 933 : Greek capital letter upsilon */
entityToCharacterMap["&Phi"]			= "934";	 /* 934 : Greek capital letter phi */
entityToCharacterMap["&Chi"]			= "935";	 /* 935 : Greek capital letter chi */
entityToCharacterMap["&Psi"]			= "936";	 /* 936 : Greek capital letter psi */
entityToCharacterMap["&Omega"]			= "937";	 /* 937 : Greek capital letter omega */
entityToCharacterMap["&alpha"]			= "945";	 /* 945 : Greek small letter alpha */
entityToCharacterMap["&beta"]			= "946";	 /* 946 : Greek small letter beta */
entityToCharacterMap["&gamma"]			= "947";	 /* 947 : Greek small letter gamma */
entityToCharacterMap["&delta"]			= "948";	 /* 948 : Greek small letter delta */
entityToCharacterMap["&epsilon"]			= "949";	 /* 949 : Greek small letter epsilon */
entityToCharacterMap["&zeta"]			= "950";	 /* 950 : Greek small letter zeta */
entityToCharacterMap["&eta"]			= "951";	 /* 951 : Greek small letter eta */
entityToCharacterMap["&theta"]			= "952";	 /* 952 : Greek small letter theta */
entityToCharacterMap["&iota"]			= "953";	 /* 953 : Greek small letter iota */
entityToCharacterMap["&kappa"]			= "954";	 /* 954 : Greek small letter kappa */
entityToCharacterMap["&lambda"]			= "955";	 /* 955 : Greek small letter lambda */
entityToCharacterMap["&mu"]			= "956";	 /* 956 : Greek small letter mu */
entityToCharacterMap["&nu"]			= "957";	 /* 957 : Greek small letter nu */
entityToCharacterMap["&xi"]			= "958";	 /* 958 : Greek small letter xi */
entityToCharacterMap["&omicron"]			= "959";	 /* 959 : Greek small letter omicron */
entityToCharacterMap["&pi"]			= "960";	 /* 960 : Greek small letter pi */
entityToCharacterMap["&rho"]			= "961";	 /* 961 : Greek small letter rho */
entityToCharacterMap["&sigmaf"]			= "962";	 /* 962 : Greek small letter final sigma */
entityToCharacterMap["&sigma"]			= "963";	 /* 963 : Greek small letter sigma */
entityToCharacterMap["&tau"]			= "964";	 /* 964 : Greek small letter tau */
entityToCharacterMap["&upsilon"]			= "965";	 /* 965 : Greek small letter upsilon */
entityToCharacterMap["&phi"]			= "966";	 /* 966 : Greek small letter phi */
entityToCharacterMap["&chi"]			= "967";	 /* 967 : Greek small letter chi */
entityToCharacterMap["&psi"]			= "968";	 /* 968 : Greek small letter psi */
entityToCharacterMap["&omega"]			= "969";	 /* 969 : Greek small letter omega */
entityToCharacterMap["&thetasym"]			= "977";	 /* 977 : Greek theta symbol */
entityToCharacterMap["&upsih"]			= "978";	 /* 978 : Greek upsilon with hook symbol */
entityToCharacterMap["&piv"]			= "982";	 /* 982 : Greek pi symbol */
entityToCharacterMap["&ensp"]			= "8194";	 /* 8194 : en space */
entityToCharacterMap["&emsp"]			= "8195";	 /* 8195 : em space */
entityToCharacterMap["&thinsp"]			= "8201";	 /* 8201 : thin space */
entityToCharacterMap["&zwnj"]            = "8204"; /* 8204 : zero width non-joiner */
entityToCharacterMap["&zwj"]			= "8205";	 /* 8205 : zero width joiner */
entityToCharacterMap["&lrm"]             = "8206"; /* 8206 : left-to-right mark */
entityToCharacterMap["&rlm"]             = "8207"; /* 8207 : right-to-left mark */
entityToCharacterMap["&ndash"]			= "8211";	 /* 8211 : en dash */
entityToCharacterMap["&mdash"]			= "8212";	 /* 8212 : em dash */
entityToCharacterMap["&lsquo"]			= "8216";	 /* 8216 : left single quotation mark */
entityToCharacterMap["&rsquo"]			= "8217";	 /* 8217 : right single quotation mark */
entityToCharacterMap["&sbquo"]           = "8218";  /* 8218 : single low-9 quotation mark */
entityToCharacterMap["&ldquo"]			= "8220";	 /* 8220 : left double quotation mark */
entityToCharacterMap["&rdquo"]			= "8221";	 /* 8221 : right double quotation mark */
entityToCharacterMap["&bdquo"]           = "8222";  /* 8222 : double low-9 quotation mark */
entityToCharacterMap["&dagger"]			= "8224";	 /* 8224 : dagger */
entityToCharacterMap["&Dagger"]			= "8225";	 /* 8225 : double dagger */
entityToCharacterMap["&bull"]			= "8226";	 /* 8226 : bullet */
entityToCharacterMap["&hellip"]			= "8230";	 /* 8230 : horizontal ellipsis */
entityToCharacterMap["&permil"]			= "8240";	 /* 8240 : per mille sign */
entityToCharacterMap["&prime"]			= "8242";	 /* 8242 : prime */
entityToCharacterMap["&Prime"]			= "8243";	 /* 8243 : double prime */
entityToCharacterMap["&lsaquo"]          = "8249";  /* 8249 : single left-pointing angle quotation mark */
entityToCharacterMap["&rsaquo"]          = "8250";  /* 8250 : single right-pointing angle quotation mark */
entityToCharacterMap["&oline"]			= "8254";	 /* 8254 : overline */
entityToCharacterMap["&frasl"]			= "8260";	 /* 8260 : fraction slash */
entityToCharacterMap["&euro"]			= "8364";	 /* 8364 : euro sign */
entityToCharacterMap["&image"]           = "8365";  /* 8465 : black-letter capital i */
entityToCharacterMap["&weierp"]          = "8472";  /* 8472 : script capital p, Weierstrass p */
entityToCharacterMap["&real"]            = "8476";  /* 8476 : black-letter capital r */
entityToCharacterMap["&trade"]			= "8482";	 /* 8482 : trademark sign */
entityToCharacterMap["&alefsym"]			= "8501";	 /* 8501 : alef symbol */
entityToCharacterMap["&larr"]			= "8592";	 /* 8592 : leftwards arrow */
entityToCharacterMap["&uarr"]			= "8593";	 /* 8593 : upwards arrow */
entityToCharacterMap["&rarr"]			= "8594";	 /* 8594 : rightwards arrow */
entityToCharacterMap["&darr"]			= "8595";	 /* 8595 : downwards arrow */
entityToCharacterMap["&harr"]			= "8596";	 /* 8596 : left right arrow */
entityToCharacterMap["&crarr"]			= "8629";	 /* 8629 : downwards arrow with corner leftwards */
entityToCharacterMap["&lArr"]			= "8656";	 /* 8656 : leftwards double arrow */
entityToCharacterMap["&uArr"]			= "8657";	 /* 8657 : upwards double arrow */
entityToCharacterMap["&rArr"]			= "8658";	 /* 8658 : rightwards double arrow */
entityToCharacterMap["&dArr"]			= "8659";	 /* 8659 : downwards double arrow */
entityToCharacterMap["&hArr"]			= "8660";	 /* 8660 : left right double arrow */
entityToCharacterMap["&forall"]			= "8704";	 /* 8704 : for all */
entityToCharacterMap["&part"]			= "8706";	 /* 8706 : partial differential */
entityToCharacterMap["&exist"]			= "8707";	 /* 8707 : there exists */
entityToCharacterMap["&empty"]			= "8709";	 /* 8709 : empty set */
entityToCharacterMap["&nabla"]			= "8711";	 /* 8711 : nabla */
entityToCharacterMap["&isin"]			= "8712";	 /* 8712 : element of */
entityToCharacterMap["&notin"]			= "8713";	 /* 8713 : not an element of */
entityToCharacterMap["&ni"]			    = "8715";	 /* 8715 : contains as member */
entityToCharacterMap["&prod"]            = "8719";  /* 8719 : n-ary product */
entityToCharacterMap["&sum"]             = "8721";  /* 8721 : n-ary summation */
entityToCharacterMap["&minus"]			= "8722";	 /* 8722 : minus sign */
entityToCharacterMap["&lowast"]			= "8727";	 /* 8727 : asterisk operator */
entityToCharacterMap["&radic"]			= "8730";	 /* 8730 : square root */
entityToCharacterMap["&prop"]			= "8733";	 /* 8733 : proportional to */
entityToCharacterMap["&infin"]			= "8734";	 /* 8734 : infinity */
entityToCharacterMap["&ang"]			= "8736";	 /* 8736 : angle */
entityToCharacterMap["&and"]			= "8743";	 /* 8743 : logical and */
entityToCharacterMap["&or"]			= "8744";	 /* 8744 : logical or */
entityToCharacterMap["&cap"]			= "8745";	 /* 8745 : intersection */
entityToCharacterMap["&cup"]			= "8746";	 /* 8746 : union */
entityToCharacterMap["&int"]			= "8747";	 /* 8747 : integral */
entityToCharacterMap["&there4"]			= "8756";	 /* 8756 : therefore */
entityToCharacterMap["&sim"]			= "8764";	 /* 8764 : tilde operator */
entityToCharacterMap["&cong"]			= "8773";	 /* 8773 : congruent to */
entityToCharacterMap["&asymp"]			= "8776";	 /* 8776 : almost equal to */
entityToCharacterMap["&ne"]			= "8800";	 /* 8800 : not equal to */
entityToCharacterMap["&equiv"]           = "8801";   /* 8801 : identical to, equivalent to */
entityToCharacterMap["&le"]              = "8804"; /* 8804 : less-than or equal to */
entityToCharacterMap["&ge"]              = "8805"; /* 8805 : greater-than or equal to */
entityToCharacterMap["&sub"]			= "8834";	 /* 8834 : subset of */
entityToCharacterMap["&sup"]			= "8835";	 /* 8835 : superset of */
entityToCharacterMap["&nsub"]			= "8836";	 /* 8836 : not a subset of */
entityToCharacterMap["&sube"]			= "8838";	 /* 8838 : subset of or equal to */
entityToCharacterMap["&supe"]			= "8839";	 /* 8839 : superset of or equal to */
entityToCharacterMap["&oplus"]			= "8853";	 /* 8853 : circled plus */
entityToCharacterMap["&otimes"]			= "8855";	 /* 8855 : circled times */
entityToCharacterMap["&perp"]			= "8869";	 /* 8869 : up tack */
entityToCharacterMap["&sdot"]			= "8901";	 /* 8901 : dot operator */
entityToCharacterMap["&lceil"]			= "8968";	 /* 8968 : left ceiling */
entityToCharacterMap["&rceil"]			= "8969";	 /* 8969 : right ceiling */
entityToCharacterMap["&lfloor"]			= "8970";	 /* 8970 : left floor */
entityToCharacterMap["&rfloor"]			= "8971";	 /* 8971 : right floor */
entityToCharacterMap["&lang"]            = "9001";  /* 9001 : left-pointing angle bracket */
entityToCharacterMap["&rang"]            = "9002";  /* 9002 : right-pointing angle bracket */
entityToCharacterMap["&loz"]			= "9674";	 /* 9674 : lozenge */
entityToCharacterMap["&spades"]			= "9824";	 /* 9824 : black spade suit */
entityToCharacterMap["&clubs"]			= "9827";	 /* 9827 : black club suit */
entityToCharacterMap["&hearts"]			= "9829";	 /* 9829 : black heart suit */
entityToCharacterMap["&diams"]			= "9830";	 /* 9830 : black diamond suit */

var characterToEntityMap = [];

for ( var entity in entityToCharacterMap ) {
    characterToEntityMap[entityToCharacterMap[entity]] = entity;
}

esapi.codecs.HTMLEntityCodec = function() {
    var _super = new esapi.codecs.Codec();

    var getNumericEntity = function(input) {
        var first = input.peek();
        if (first == null) {
            return null;
        }

        if (first == 'x' || first == 'X') {
            input.next();
            return parseHex(input);
        }
        return parseNumber(input);
    };

    var parseNumber = function(input) {
        var out = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[0-9]/)) {
                out += c;
                input.next();
            } else if (c == ';') {
                input.next();
                break;
            } else {
                break;
            }
        }

        try {
            return parseInt(out);
        } catch (e) {
            return null;
        }
    };

    var parseHex = function(input) {
        var out = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[0-9A-Fa-f]/)) {
                out += c;
                input.next();
            } else if (c == ';') {
                input.next();
                break;
            } else {
                break;
            }
        }
        try {
            return parseInt(out, 16);
        } catch (e) {
            return null;
        }
    };

    var getNamedEntity = function(input) {
        var entity = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[A-Za-z]/)) {
                entity += c;
                input.next();
                if (utils.containsKey(entityToCharacterMap, '&' + entity)) {
                    if (input.peek(';')) input.next();
                    break;
                }
            } else if (c == ';') {
                input.next();
            } else {
                break;
            }
        }

        return String.fromCharCode(entityToCharacterMap.getCaseInsensitive('&' + entity));
    };

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (utils.contains(aImmune, c)) {
                return c;
            }

            var hex = esapi.codecs.Codec.getHexForNonAlphanumeric(c);
            if (hex == null) {
                return c;
            }

            var cc = c.charCodeAt(0);
            if (( cc <= 0x1f && c != '\t' && c != '\n' && c != '\r' ) || ( cc >= 0x7f && cc <= 0x9f ) || c == ' ') {
                return " ";
            }

            var entityName = characterToEntityMap[cc];
            if (entityName != null) {
                return entityName + ";";
            }

            return "&#x" + hex + ";";
        },

        decodeCharacter: function(oPushbackString) {
            //noinspection UnnecessaryLocalVariableJS
            var input = oPushbackString;
            input.mark();
            var first = input.next();
            if (first == null || first != '&') {
                input.reset();
                return null;
            }

            var second = input.next();
            if (second == null) {
                input.reset();
                return null;
            }

            if (second == '#') {
                var c = getNumericEntity(input);
                if (c != null) {
                    return c;
                }
            } else if (second.match(/[A-Za-z]/)) {
                input.pushback(second);
                c = getNamedEntity(input);
                if (c != null) {
                    return c;
                }
            }
            input.reset();
            return null;
        }
    };
};


esapi.codecs.JavascriptCodec = function() {
    var _super = new esapi.codecs.Codec();

    return {
        encode: function(aImmune, sInput) {
            var out = '';
            for (var idx = 0; idx < sInput.length; idx ++) {
                var ch = sInput.charAt(idx);
                if (utils.contains(aImmune, ch)) {
                    out += ch;
                }
                else {
                    var hex = esapi.codecs.Codec.getHexForNonAlphanumeric(ch);
                    if (hex == null) {
                        out += ch;
                    }
                    else {
                        var tmp = ch.charCodeAt(0).toString(16);
                        if (ch.charCodeAt(0) < 256) {
                            var pad = "00".substr(tmp.length);
                            out += "\\x" + pad + tmp.toUpperCase();
                        }
                        else {
                            pad = "0000".substr(tmp.length);
                            out += "\\u" + pad + tmp.toUpperCase();
                        }
                    }
                }
            }
            return out;
        },

        decode: _super.decode,

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null) {
                oPushbackString.reset();
                return null;
            }

            if (first != '\\') {
                oPushbackString.reset();
                return null;
            }

            var second = oPushbackString.next();
            if (second == null) {
                oPushbackString.reset();
                return null;
            }

            // \0 collides with the octal decoder and is non-standard
            // if ( second.charValue() == '0' ) {
            //      return Character.valueOf( (char)0x00 );
            if (second == 'b') {
                return 0x08;
            } else if (second == 't') {
                return 0x09;
            } else if (second == 'n') {
                return 0x0a;
            } else if (second == 'v') {
                return 0x0b;
            } else if (second == 'f') {
                return 0x0c;
            } else if (second == 'r') {
                return 0x0d;
            } else if (second == '\"') {
                return 0x22;
            } else if (second == '\'') {
                return 0x27;
            } else if (second == '\\') {
                return 0x5c;
            } else if (second.toLowerCase() == 'x') {
                out = '';
                for (var i = 0; i < 2; i++) {
                    var c = oPushbackString.nextHex();
                    if (c != null) {
                        out += c;
                    } else {
                        input.reset();
                        return null;
                    }
                }
                try {
                    n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            } else if (second.toLowerCase() == 'u') {
                out = '';
                for (i = 0; i < 4; i++) {
                    c = oPushbackString.nextHex();
                    if (c != null) {
                        out += c;
                    } else {
                        input.reset();
                        return null;
                    }
                }
                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            } else if (oPushbackString.isOctalDigit(second)) {
                var out = second;
                var c2 = oPushbackString.next();
                if (!oPushbackString.isOctalDigit(c2)) {
                    oPushbackString.pushback(c2);
                } else {
                    out += c2;
                    var c3 = oPushbackString.next();
                    if (!oPushbackString.isOctalDigit(c3)) {
                        oPushbackString.pushback(c3);
                    } else {
                        out += c3;
                    }
                }

                try {
                    n = parseInt(out, 8);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            }
            return second;
        }
    };
};


esapi.codecs.PercentCodec = function() {
    var _super = new esapi.codecs.Codec();

    var ALPHA_NUMERIC_STR = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    var RFC_NON_ALPHANUMERIC_UNRESERVED_STR = "-._~";
    var ENCODED_NON_ALPHA_NUMERIC_UNRESERVED = true;
    var UNENCODED_STR = ALPHA_NUMERIC_STR + (ENCODED_NON_ALPHA_NUMERIC_UNRESERVED ? "" : RFC_NON_ALPHANUMERIC_UNRESERVED_STR);

    var getTwoUpperBytes = function(b) {
        var out = '';
        if (b < -128 || b > 127) {
            throw new IllegalArgumentException("b is not a byte (was " + b + ")");
        }
        b &= 0xFF;
        if (b < 0x10) {
            out += '0';
        }
        return out + b.toString(16).toUpperCase();
    };

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (UNENCODED_STR.indexOf(c) > -1) {
                return c;
            }

            var bytes = esapi.codecs.UTF8.encode(c);
            var out = '';
            for (var b = 0; b < bytes.length; b++) {
                out += '%' + getTwoUpperBytes(bytes.charCodeAt(b));
            }
            return out;
        },

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null || first != '%') {
                oPushbackString.reset();
                return null;
            }

            var out = '';
            for (var i = 0; i < 2; i++) {
                var c = oPushbackString.nextHex();
                if (c != null) {
                    out += c;
                }
            }
            if (out.length == 2) {
                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                }
            }
            oPushbackString.reset();
            return null;
        }
    };
};

esapi.codecs.PushbackString = function(sInput) {
    var _input = sInput,
        _pushback = '',
        _temp = '',
        _index = 0,
        _mark = 0;

    return {
        pushback: function(c) {
            _pushback = c;
        },

        index: function() {
            return _index;
        },

        hasNext: function() {
            if (_pushback != null) return true;
            return !(_input == null || _input.length == 0 || _index >= _input.length);

        },

        next: function() {
            if (_pushback != null) {
                var save = _pushback;
                _pushback = null;
                return save;
            }
            if (_input == null || _input.length == 0 || _index >= _input.length) {
                return null;
            }
            return _input.charAt(_index++);
        },

        nextHex: function() {
            var c = this.next();
            if (this.isHexDigit(c)) return c;
            return null;
        },

        nextOctal: function() {
            var c = this.next();
            if (this.isOctalDigit(c)) return c;
            return null;
        },

        isHexDigit: function(c) {
            return c != null && ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'f' ) || ( c >= 'A' && c <= 'F' ) );
        },

        isOctalDigit: function(c) {
            return c != null && ( c >= '0' && c <= '7' );
        },

        peek: function(c) {
            if (!c) {
                if (_pushback != null) return _pushback;
                if (_input == null || _input.length == 0 || _index >= _input.length) return null;
                return _input.charAt(_index);
            } else {
                if (_pushback != null && _pushback == c) return true;
                if (_input == null || _input.length == 0 || _index >= _input.length) return false;
                return _input.charAt(_index) == c;
            }
        },

        mark: function() {
            _temp = _pushback;
            _mark = _index;
        },

        reset: function() {
            _pushback = _temp;
            _index = _mark;
        },

        remainder: function() {
            var out = _input.substr(_index);
            if (_pushback != null) {
                out = _pushback + out;
            }
            return out;
        }
    };
};

esapi.codecs.UTF8 = {
    encode: function(sInput) {
        var input = sInput.replace(/\r\n/g, "\n");
        var utftext = '';

        for (var n = 0; n < input.length; n ++) {
            var c = input.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if (( c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }

        return utftext;
    }
    ,

    decode: function(sInput) {
        var out = '';
        var i, c, c1, c2, c3, string;
        i = c = c1 = c2 = 0;

        while (i < sInput.length) {
            c = sInput.charCodeAt(i);

            if (c < 128) {
                out += String.fromCharCode(c);
                i ++;
            }
            else if ((c > 191) && (c < 224)) {
                c2 = sInput.charCodeAt(i + 1);
                out += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }

        return out;
    }
};



esapi.DefaultEncoder = function(aCodecs) {
    var _codecs = [],
        _htmlCodec = new esapi.codecs.HTMLEntityCodec(),
        _javascriptCodec = new esapi.codecs.JavascriptCodec(),
        _cssCodec = new esapi.codecs.CSSCodec(),
        _percentCodec = new esapi.codecs.PercentCodec();

    if (!aCodecs) {
        _codecs.push(_htmlCodec);
        _codecs.push(_javascriptCodec);
        _codecs.push(_cssCodec);
        _codecs.push(_percentCodec);
    } else {
        _codecs = aCodecs;
    }

    var IMMUNE_HTML = new Array(',', '.', '-', '_', ' ');
    var IMMUNE_HTMLATTR = new Array(',', '.', '-', '_');
    var IMMUNE_CSS = new Array();
    var IMMUNE_JAVASCRIPT = new Array(',', '.', '_');

    return {
        cananicalize: function(sInput, bStrict) {
            if (!sInput) {
                return null;
            }
            var working = sInput, codecFound = null, mixedCount = 1, foundCount = 0, clean = false;
            while (!clean) {
                clean = true;

                _codecs.each(function(codec) {
                    var old = working;
                    working = codec.decode(working);

                    if (old != working) {
                        if (codecFound != null && codecFound != codec) {
                            mixedCount ++;
                        }
                        codecFound = codec;
                        if (clean) {
                            foundCount ++;
                        }
                        clean = false;
                    }
                });
            }

            if (foundCount >= 2 && mixedCount > 1) {
                if (bStrict) {
                    throw new esapi.IntrusionException("Input validation failure", "Multiple (" + foundCount + "x) and mixed encoding (" + mixedCount + "x) detected in " + sInput);
                }
            }
            else if (foundCount >= 2) {
                if (bStrict) {
                    throw new esapi.IntrusionException("Input validation failure", "Multiple (" + foundCount + "x) encoding detected in " + sInput);
                }
            }
            else if (mixedCount > 1) {
                if (bStrict) {
                    throw new esapi.IntrusionException("Input validation failure", "Mixed (" + mixedCount + "x) encoding detected in " + sInput);
                }
            }
            return working;
        },

        normalize: function(sInput) {
            return sInput.replace(/[^\x00-\x7F]/g, '');
        },

        encodeForHTML: function(sInput) {
            return !sInput ? null : _htmlCodec.encode(IMMUNE_HTML, sInput);
        },

        decodeForHTML: function(sInput) {
            return !sInput ? null : _htmlCodec.decode(sInput);
        },

        encodeForHTMLAttribute: function(sInput) {
            return !sInput ? null : _htmlCodec.encode(IMMUNE_HTMLATTR, sInput);
        },

        encodeForCSS: function(sInput) {
            return !sInput ? null : _cssCodec.encode(IMMUNE_CSS, sInput);
        },

        encodeForJavaScript: function(sInput) {
            return !sInput ? null : _javascriptCodec.encode(IMMUNE_JAVASCRIPT, sInput);
        },

        encodeForJavascript: this.encodeForJavaScript,

        encodeForJS: this.encodeForJavascript,

        encodeForURL: function(sInput) {
            return !sInput ? null : escape(sInput);
        },

        decodeFromURL: function(sInput) {
            return !sInput ? null : unescape(sInput);
        },

        encodeForBase64: function(sInput) {
            return !sInput ? null : esapi.codecs.Base64.encode(sInput);
        },

        decodeFromBase64: function(sInput) {
            return !sInput ? null : esapi.codecs.Base64.decode(sInput);
        }
    };
};

module.exports = {
    encoder: function () {
        return esapi.DefaultEncoder();
    },
    middleware: function () {
        return utils.middleware;
    }
};
},{"./utils":66}],66:[function(require,module,exports){
(function (__dirname){(function (){
'use strict';

function contains(arr, val) {
    return arr.some(function (elem) {
        if(( val.equals && val.equals(e) ) || elem === val) {
            return true;
        }
    });
}

module.exports.contains = contains;

function containsKey(arr, key) {
    if(typeof key === 'string') {
        var comp = key.toLowerCase();
        return arr.some(function (elem, index) {
            if(comp === index || (typeof index === 'string' && comp === index.toLowerCase())) {
                return true;
            }
        });
    }
    return false;
}

module.exports.containsKey = containsKey;

function middleware(req, res, next) {
    switch(req.url) {
        case '/esapi/esapi.js':
            res.sendfile(__dirname + '/public/esapi.js');
            break;
        case '/esapi/esapi-compressed.js':
            res.sendfile(__dirname + '/public/esapi-compressed.js');
            break;
        case '/esapi/resources/Base.esapi.properties.js':
            res.sendfile(__dirname + '/public/resources/Base.esapi.properties.js');
            break;
        case '/esapi/resources/i18n/ESAPI_Standard_en_US.properties.js':
            res.sendfile(__dirname + '/public/resources/i18n/ESAPI_Standard_en_US.properties.js');
            break;
        default:
            next();
            break;
    }
}

module.exports.middleware = middleware;
}).call(this)}).call(this,"/node_modules/node-esapi/lib")
},{}]},{},[19]);
